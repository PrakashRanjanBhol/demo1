async renderStream(text, chunkSize = 5, delay = 30) {
    this.contentElement.innerHTML = '';
    this.buffer = '';
    this.lastRenderedIndex = 0;
    this.currentMarkdownElement = null;
    this.currentCodeBlock = null;
    this.inCodeBlock = false;
    this.codeBlockLanguage = '';
    this.codeBlockContent = '';
    
    // Add streaming cursor
    const cursor = document.createElement('span');
    cursor.className = 'streaming-cursor';
    this.contentElement.appendChild(cursor);
    
    // Simulate streaming by adding characters chunk by chunk
    for (let i = 0; i < text.length; i += chunkSize) {
        const chunk = text.slice(i, i + chunkSize);
        this.buffer += chunk;
        
        // Process the buffer incrementally
        this.processBufferIncremental();
        
        // Re-add cursor at the end
        if (cursor.parentNode) {
            cursor.parentNode.removeChild(cursor);
        }
        this.contentElement.appendChild(cursor);
        
        await new Promise(resolve => setTimeout(resolve, delay));
    }
    
    // Final processing
    this.finalizeStream();
    
    // Remove cursor
    if (cursor.parentNode) {
        cursor.parentNode.removeChild(cursor);
    }
}

processBufferIncremental() {
    // Check if we're entering a code block
    const codeBlockStart = /```(\w+)?\s*\n/g;
    const codeBlockEnd = /\n```/g;
    
    // If not in code block, check if we're starting one
    if (!this.inCodeBlock) {
        codeBlockStart.lastIndex = this.lastRenderedIndex;
        const startMatch = codeBlockStart.exec(this.buffer);
        
        if (startMatch && startMatch.index === this.lastRenderedIndex) {
            // Render any pending markdown before code block starts
            if (this.currentMarkdownElement && this.currentMarkdownElement.textContent.trim()) {
                this.contentElement.insertBefore(
                    this.currentMarkdownElement, 
                    this.contentElement.lastChild
                );
                this.currentMarkdownElement = null;
            }
            
            // Start code block
            this.inCodeBlock = true;
            this.codeBlockLanguage = startMatch[1] || 'plaintext';
            this.codeBlockContent = '';
            this.lastRenderedIndex = codeBlockStart.lastIndex;
            
            // Create code block structure
            this.currentCodeBlock = this.createCodeBlock(this.codeBlockLanguage, '');
            this.contentElement.insertBefore(
                this.currentCodeBlock, 
                this.contentElement.lastChild
            );
            
            return;
        }
    }
    
    // If in code block, check if we're ending it
    if (this.inCodeBlock) {
        codeBlockEnd.lastIndex = this.lastRenderedIndex;
        const endMatch = codeBlockEnd.exec(this.buffer);
        
        if (endMatch) {
            // Extract code content up to the end marker
            this.codeBlockContent = this.buffer.slice(
                this.lastRenderedIndex, 
                endMatch.index
            );
            
            // Update code block with final content
            this.updateCodeBlockContent(this.currentCodeBlock, this.codeBlockContent);
            
            // Exit code block
            this.inCodeBlock = false;
            this.currentCodeBlock = null;
            this.lastRenderedIndex = codeBlockEnd.lastIndex;
            return;
        } else {
            // Still in code block, update content
            this.codeBlockContent = this.buffer.slice(this.lastRenderedIndex);
            this.updateCodeBlockContent(this.currentCodeBlock, this.codeBlockContent);
            return;
        }
    }
    
    // Regular markdown content
    if (!this.inCodeBlock) {
        const newContent = this.buffer.slice(this.lastRenderedIndex);
        
        if (newContent) {
            if (!this.currentMarkdownElement) {
                this.currentMarkdownElement = document.createElement('div');
                this.currentMarkdownElement.className = 'regular-text';
                this.contentElement.insertBefore(
                    this.currentMarkdownElement, 
                    this.contentElement.lastChild
                );
            }
            
            // Update markdown content
            const html = marked.parse(newContent);
            this.currentMarkdownElement.innerHTML = html;
        }
    }
}

updateCodeBlockContent(codeBlock, content) {
    if (!codeBlock) return;
    
    const pre = codeBlock.querySelector('pre');
    if (!pre) return;
    
    const codeElement = pre.querySelector('code');
    if (!codeElement) return;
    
    // Update with highlighted content
    const highlightedContent = hljs.highlightAuto(content).value;
    codeElement.innerHTML = highlightedContent;
    
    // Update copy button
    const copyBtn = codeBlock.querySelector('.code-block-copy');
    if (copyBtn) {
        copyBtn.onclick = () => this.copyCode(content, copyBtn);
    }
}

finalizeStream() {
    // Finalize any pending markdown
    if (this.currentMarkdownElement) {
        const newContent = this.buffer.slice(this.lastRenderedIndex);
        if (newContent.trim()) {
            const html = marked.parse(newContent);
            this.currentMarkdownElement.innerHTML = html;
        }
    }
    
    // Reset state
    this.lastRenderedIndex = 0;
    this.currentMarkdownElement = null;
    this.currentCodeBlock = null;
    this.inCodeBlock = false;
}









constructor(contentElement) {
    this.contentElement = contentElement;
    this.buffer = '';
    this.lastRenderedIndex = 0;
    this.currentMarkdownElement = null;
    this.currentCodeBlock = null;
    this.inCodeBlock = false;
    this.codeBlockLanguage = '';
    this.codeBlockContent = '';
}
