export class ChunkedJsonParserComponent implements OnInit {
  // ... existing properties ...
  public isCompleted = false; // ADD THIS

  // MODIFY setupCallbacks - set completed flag
  private setupCallbacks(): void {
    this.parserService.setCallbacks({
      onToolDetected: (toolData: ToolData) => {
        this.logToolDetected(toolData);
        this.updateLists();
        
        if (toolData.tool === 'READ') {
          this.appendReadContent(toolData);
        }
      },
      onApprovalRequest: (approvalRequest: ApprovalRequest) => {
        this.isWaitingForApproval = true;
        this.currentApprovalRequest = approvalRequest;
        this.isApprovingChanges = false;
        this.logWaitingForApproval(approvalRequest.data);
        this.updateLists();
        this.cdr.detectChanges();
      },
      onCompletion: () => {
        this.isProcessing = false;
        this.isApprovingChanges = false;
        this.hasReceivedFirstChunk = false;
        this.isCompleted = true; // SET completed to true
        this.logCompleted();
        this.updateLists();
        this.cdr.detectChanges();
      },
      onError: (error: string) => {
        this.isProcessing = false;
        this.isApprovingChanges = false;
        this.hasReceivedFirstChunk = false;
        this.logError(error);
      },
      onFirstChunk: () => {
        this.hasReceivedFirstChunk = true;
        this.logFirstChunkReceived();
        this.cdr.detectChanges();
      }
    });
  }

  // MODIFY runDemo - reset completed flag
  public async runDemo(): Promise<void> {
    console.clear();
    console.log('ðŸš€ Starting streaming process...\n');
    
    // Reset lists
    this.executedItems = [];
    this.queuedItems = [];
    this.groupedExecutedItems = [];
    this.hasReceivedFirstChunk = false;
    this.isCompleted = false; // RESET on new run
    
    // Clear the streaming container
    this.clearStreamingContainer();
    
    // Setup callbacks before starting the stream
    this.setupCallbacks();
    
    this.isProcessing = true;
    
    try {
      await this.parserService.startStreaming();
    } catch (error) {
      if (error instanceof Error && error.name !== 'AbortError') {
        console.error('Failed to start streaming:', error);
      }
      this.isProcessing = false;
    }
  }

  // ... rest of existing methods ...
}











<div class="vibe-coding-header-right">
  <button 
    class="vibe-coding-btn vibe-coding-btn-primary" 
    (click)="runDemo()" 
    [disabled]="isProcessing">
    RUN
  </button>

  <!-- Processing Badge -->
  <span *ngIf="isProcessing && !isCompleted" class="vibe-coding-processing-badge">
    <span class="vibe-coding-processing-dot"></span>
    Processing
  </span>

  <!-- Completed Badge - NEW -->
  <span *ngIf="isCompleted" class="vibe-coding-completed-badge">
    <span class="vibe-coding-completed-icon">âœ“</span>
    Completed
  </span>

  <!-- Stop Icon (Blinking SVG Square) -->
  <button 
    *ngIf="isProcessing && !isCompleted"
    class="vibe-coding-stop-btn" 
    (click)="stopStreaming()"
    title="Stop Streaming">
    <svg class="vibe-coding-stop-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect x="6" y="6" width="12" height="12" fill="currentColor" rx="2"/>
    </svg>
  </button>
</div>














/* Light Mode Variables (Default) */
:root {
  /* ... existing variables ... */
  
  /* Completed Badge Colors - ADD THESE */
  --vibe-completed-bg: #d1fae5;
  --vibe-completed-text: #065f46;
  --vibe-completed-border: #10b981;
  --vibe-completed-icon-bg: #10b981;
  --vibe-completed-icon-text: #ffffff;
}

/* Dark Mode Variables */
[data-theme="dark"] {
  /* ... existing variables ... */
  
  /* Completed Badge Colors - ADD THESE */
  --vibe-completed-bg: #064e3b;
  --vibe-completed-text: #6ee7b7;
  --vibe-completed-border: #059669;
  --vibe-completed-icon-bg: #059669;
  --vibe-completed-icon-text: #d1fae5;
}
