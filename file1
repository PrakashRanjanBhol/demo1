import { Component, ElementRef, ViewChild, AfterViewInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { formatDate } from '@angular/common';
import * as echarts from 'echarts';

@Component({
  selector: 'app-charts',
  templateUrl: './charts.component.html',
  styleUrls: ['./charts.component.scss']
})
export class ChartsComponent implements AfterViewInit {
  @ViewChild('chartContainer') chartContainer!: ElementRef;

  fromDate: string;
  toDate: string;
  todayStr: string = this.formatToDDMMYYYY(new Date());
  chartInstance: any;
  rawData: { date: string, language: string, lines: number }[] = [];

  languageColors: string[] = [
    '#facc15', '#60a5fa', '#f87171', '#38bdf8', '#a78bfa', '#34d399',
    '#fb923c', '#e879f9', '#f472b6', '#c084fc', '#fcd34d', '#4ade80',
    '#06b6d4', '#fca5a5', '#fde68a', '#93c5fd', '#d8b4fe', '#fdba74',
    '#86efac', '#fda4af', '#a5b4fc', '#99f6e4', '#fbbf24', '#cbd5e1',
    '#22d3ee', '#ef4444', '#eab308', '#7c3aed', '#0ea5e9', '#e11d48'
  ];
  languageColorMap: Record<string, string> = {};

  pageIndex = 0;
  pageSize = 5;
  totalPages = 0;
  allPeriodsSorted: string[] = [];
  formattedPeriods: string[] = [];
  periodsSubset: string[] = [];

  constructor(private http: HttpClient) {
    const today = new Date();
    const lastWeek = new Date();
    lastWeek.setDate(today.getDate() - 6);

    this.toDate = this.formatToDDMMYYYY(today);
    this.fromDate = this.formatToDDMMYYYY(lastWeek);
  }

  ngAfterViewInit() {
    this.chartInstance = echarts.init(this.chartContainer.nativeElement, 'dark');
    this.fetchChartData();
  }

  formatToDDMMYYYY(date: Date): string {
    return formatDate(date, 'dd-MM-yyyy', 'en-IN');
  }

  fetchChartData(): void {
    const payload = {
      from_date: this.fromDate,
      to_date: this.toDate
    };

    this.http.post<any[]>('/api/get-chart-data', payload).subscribe(data => {
      this.rawData = data;
      this.pageIndex = 0;
      this.updateChart();
    });
  }

  getColorForLang(lang: string): string {
    if (!this.languageColorMap[lang]) {
      const index = Object.keys(this.languageColorMap).length % this.languageColors.length;
      this.languageColorMap[lang] = this.languageColors[index];
    }
    return this.languageColorMap[lang];
  }

  getGroupingGranularity(from: string, to: string): 'day' | 'week' | 'month' | 'year' {
    const parse = (str: string) => {
      const [dd, mm, yyyy] = str.split('-').map(Number);
      return new Date(yyyy, mm - 1, dd);
    };

    const fromDate = parse(from);
    const toDate = parse(to);
    const diffDays = Math.ceil((+toDate - +fromDate) / (1000 * 60 * 60 * 24));

    if (diffDays <= 30) return 'day';
    if (diffDays <= 180) return 'week';
    if (diffDays <= 730) return 'month';
    return 'year';
  }

  formatPeriod(dateStr: string, granularity: string): string {
    const date = new Date(dateStr);
    const y = date.getFullYear();
    const m = (date.getMonth() + 1).toString().padStart(2, '0');
    const d = date.getDate().toString().padStart(2, '0');

    switch (granularity) {
      case 'day': return `${y}-${m}-${d}`;
      case 'week': {
        const temp = new Date(date);
        const day = temp.getDay();
        const diff = temp.getDate() - day + (day === 0 ? -6 : 1);
        const weekStart = new Date(temp.setDate(diff));
        const wm = (weekStart.getMonth() + 1).toString().padStart(2, '0');
        const wd = weekStart.getDate().toString().padStart(2, '0');
        return `${weekStart.getFullYear()}-${wm}-${wd}`;
      }
      case 'month': return `${y}-${m}`;
      case 'year': return `${y}`;
      default: return dateStr;
    }
  }

  formatDisplayLabel(dateStr: string, granularity: string): string {
    const date = new Date(dateStr);
    const y = date.getFullYear();
    const m = date.toLocaleString('default', { month: 'short' });
    const d = date.getDate();

    switch (granularity) {
      case 'day': return `${d} ${m} ${y}`;
      case 'week': return `Week of ${d} ${m} ${y}`;
      case 'month': return `${m} ${y}`;
      case 'year': return `${y}`;
      default: return `${d} ${m} ${y}`;
    }
  }

  nextPage() {
    if (this.pageIndex < this.totalPages - 1) {
      this.pageIndex++;
      this.updateChart();
    }
  }

  prevPage() {
    if (this.pageIndex > 0) {
      this.pageIndex--;
      this.updateChart();
    }
  }

  onDateChange(): void {
    this.fetchChartData();
  }

  updateChart(): void {
    if (!this.chartInstance || !this.rawData.length) return;

    this.languageColorMap = {};
    const parse = (str: string) => {
      const [dd, mm, yyyy] = str.split('-').map(Number);
      return new Date(yyyy, mm - 1, dd);
    };

    const from = this.fromDate;
    const to = this.toDate;
    const granularity = this.getGroupingGranularity(from, to);

    const fromISO = parse(from).toISOString().split('T')[0];
    const toISO = parse(to).toISOString().split('T')[0];

    const filtered = this.rawData.filter(d => d.date >= fromISO && d.date <= toISO);
    const grouped: Record<string, Record<string, number>> = {};
    const allPeriods = new Set<string>();
    const languageSet = new Set<string>();

    for (const entry of filtered) {
      const period = this.formatPeriod(entry.date, granularity);
      allPeriods.add(period);
      languageSet.add(entry.language);
      grouped[entry.language] = grouped[entry.language] || {};
      grouped[entry.language][period] = (grouped[entry.language][period] || 0) + entry.lines;
    }

    this.allPeriodsSorted = Array.from(allPeriods).sort();
    this.totalPages = Math.ceil(this.allPeriodsSorted.length / this.pageSize);

    const start = this.pageIndex * this.pageSize;
    const end = start + this.pageSize;
    this.periodsSubset = this.allPeriodsSorted.slice(start, end);
    this.formattedPeriods = this.periodsSubset.map(p => this.formatDisplayLabel(p, granularity));
    const languages = Array.from(languageSet).sort();

    const series = languages.map(lang => ({
      name: lang,
      type: 'bar',
      stack: 'total',
      emphasis: { focus: 'series' },
      itemStyle: {
        color: this.getColorForLang(lang)
      },
      data: this.periodsSubset.map(p => grouped[lang]?.[p] || 0)
    }));

    this.chartInstance.setOption({
      backgroundColor: '#2a2a2a',
      textStyle: { color: '#ffffff' },
      title: {
        text: `Line of Code by Languages (${granularity})`,
        textStyle: { color: '#ffffff', fontSize: 18, fontWeight: 'bold' },
        left: 'center'
      },
      tooltip: {
        trigger: 'axis',
        axisPointer: { type: 'shadow' },
        backgroundColor: '#333',
        borderColor: '#555',
        textStyle: { color: '#fff' }
      },
      legend: {
        data: languages,
        type: 'scroll',
        top: 30,
        bottom: 0,
        textStyle: { color: '#ddd', fontSize: 12 },
        pageIconColor: '#fff',
        pageTextStyle: { color: '#aaa' },
        padding: [0, 10, 0, 10],
        itemWidth: 14,
        itemHeight: 10
      },
      grid: {
        left: '3%',
        right: '4%',
        bottom: 100,
        top: 80,
        containLabel: true
      },
      xAxis: {
        type: 'category',
        data: this.formattedPeriods,
        axisLabel: {
          rotate: 45,
          interval: 0,
          fontSize: 10,
          color: '#ccc'
        },
        axisLine: { lineStyle: { color: '#999' } },
        splitLine: { show: false }
      },
      yAxis: {
        type: 'value',
        axisLabel: { color: '#ccc' },
        axisLine: { lineStyle: { color: '#999' } },
        splitLine: { lineStyle: { color: '#444' } }
      },
      series
    });
  }
}




<div class="container">
  <h2 class="header-title">üìä Lines of Code Overview</h2>

  <div class="filters">
    <input type="date" [(ngModel)]="fromDate" [max]="toDate" (change)="onDateChange()" />
    <input type="date" [(ngModel)]="toDate" [max]="todayStr" (change)="onDateChange()" />
  </div>

  <div class="pagination-controls">
    <button (click)="prevPage()" [disabled]="pageIndex === 0">‚¨ÖÔ∏è</button>
    <span>Page {{ pageIndex + 1 }} / {{ totalPages }}</span>
    <button (click)="nextPage()" [disabled]="pageIndex >= totalPages - 1">‚û°Ô∏è</button>
  </div>

  <div #chartContainer class="chart-container"></div>
</div>





.container {
  background-color: #2a2a2a;
  color: #ffffff;
  padding: 20px;
  font-family: 'Segoe UI', sans-serif;
  height: 100vh;
  overflow-y: auto;
}

.header-title {
  color: #ffffff;
  font-size: 22px;
  font-weight: 600;
  margin-bottom: 16px;
  text-align: center;
  letter-spacing: 0.5px;
}

.filters {
  display: flex;
  gap: 12px;
  margin-bottom: 20px;
  flex-wrap: wrap;
  justify-content: center;
}

.filters input {
  padding: 6px 12px;
  background-color: #3a3a3a;
  color: #fff;
  border: 1px solid #555;
  border-radius: 6px;
  font-size: 14px;
}

.pagination-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
}

.pagination-controls button {
  background-color: #444;
  border: 1px solid #666;
  color: #fff;
  padding: 6px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 16px;
  transition: all 0.2s ease-in-out;
}

.pagination-controls button:hover:not(:disabled) {
  background-color: #555;
}

.pagination-controls button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.pagination-controls span {
  color: #e0e0e0;
  font-size: 14px;
}

.chart-container {
  width: 100%;
  height: 400px; // üîΩ Reduced height
  overflow-x: auto;
  background-color: #2a2a2a;
}


languageColors: string[] = [
  '#f39c12', // Amber
  '#3498db', // Sky Blue
  '#e74c3c', // Soft Red
  '#1abc9c', // Aqua Green
  '#9b59b6', // Violet
  '#2ecc71', // Green
  '#e67e22', // Orange
  '#e84393', // Pink
  '#f1c40f', // Yellow
  '#7f8c8d'  // Muted Gray
];

