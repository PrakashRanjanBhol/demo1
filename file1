import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';

@Component({
  selector: 'app-code-parser',
  template: `
    <div class="code-container">
      <div class="code-section">
        <h3>HTML Code:</h3>
        <pre><code>{{ htmlCode }}</code></pre>
      </div>
      
      <div class="code-section">
        <h3>CSS Code:</h3>
        <pre><code>{{ cssCode }}</code></pre>
      </div>
      
      <div class="code-section">
        <h3>JavaScript Code:</h3>
        <pre><code>{{ jsCode }}</code></pre>
      </div>
    </div>
  `,
  styles: [`
    .code-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .code-section {
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 5px;
    }
    pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 3px;
      overflow-x: auto;
      white-space: pre-wrap;
    }
  `]
})
export class CodeParserComponent implements OnChanges {
  @Input() chunk: string = '';
  
  htmlCode: string = '';
  cssCode: string = '';
  jsCode: string = '';
  
  private buffer: string = '';
  private currentCodeType: 'html' | 'css' | 'js' | null = null;
  private insideCodeBlock: boolean = false;
  
  ngOnChanges(changes: SimpleChanges): void {
    if (changes['chunk'] && changes['chunk'].currentValue !== undefined) {
      this.processChunk(changes['chunk'].currentValue);
    }
  }
  
  private processChunk(newChunk: string): void {
    // Append incoming fragment to buffer
    this.buffer += newChunk;
    this.parseBuffer();
  }
  
  private parseBuffer(): void {
    let newlineIndex: number;

    // Only process full lines that end with \n
    while ((newlineIndex = this.buffer.indexOf('\n')) >= 0) {
      const line = this.buffer.slice(0, newlineIndex);
      this.buffer = this.buffer.slice(newlineIndex + 1);
      this.processLine(line);
    }

    // ⚠️ At this point, buffer may contain partial fences like "```ht"
    // We keep it until more chunks arrive
  }
  
  private processLine(line: string): void {
    const trimmedLine = line.trim();
    
    // Detect code fences
    if (trimmedLine.startsWith('```')) {
      if (!this.insideCodeBlock) {
        // Start new block
        this.insideCodeBlock = true;
        this.currentCodeType = this.detectCodeType(trimmedLine);
      } else {
        // End current block
        this.insideCodeBlock = false;
        this.currentCodeType = null;
      }
      return;
    }
    
    // Append to the correct buffer if inside a block
    if (this.insideCodeBlock && this.currentCodeType) {
      const codeContent = line + '\n';
      
      switch (this.currentCodeType) {
        case 'html':
          this.htmlCode += codeContent;
          break;
        case 'css':
          this.cssCode += codeContent;
          break;
        case 'js':
          this.jsCode += codeContent;
          break;
      }
    }
  }
  
  private detectCodeType(codeBlockStart: string): 'html' | 'css' | 'js' | null {
    const language = codeBlockStart.replace('```', '').toLowerCase().trim();
    
    if (language.includes('html') || language.includes('htm')) {
      return 'html';
    }
    
    if (language.includes('css')) {
      return 'css';
    }
    
    if (language.includes('javascript') || language.includes('js') || 
        language.includes('typescript') || language.includes('ts')) {
      return 'js';
    }
    
    // Couldn’t detect from marker → keep null until next line gives hint
    return null;
  }
  
  private detectCodeTypeByContent(): 'html' | 'css' | 'js' | null {
    // (Optional: smarter detection based on patterns if no explicit marker)
    return null;
  }
  
  public clearAll(): void {
    this.htmlCode = '';
    this.cssCode = '';
    this.jsCode = '';
    this.buffer = '';
    this.currentCodeType = null;
    this.insideCodeBlock = false;
  }
  
  public getAllCode(): { html: string, css: string, js: string } {
    return {
      html: this.htmlCode,
      css: this.cssCode,
      js: this.jsCode
    };
  }
}
