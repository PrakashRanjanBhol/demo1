public getDiffHtml(originalCode: string, modifiedCode: string, filename: string): string {
  const original = (originalCode || '').split('\n');
  const modified = (modifiedCode || '').split('\n');
  const language = this.getLanguageFromFilename(filename);
  
  const diff = this.computeDiff(original, modified);
  let diffHtml = '';
  let originalLineNum = 1;
  let modifiedLineNum = 1;
  
  for (const block of diff) {
    if (block.type === 'unchanged') {
      // Unchanged lines
      for (const line of block.lines) {
        const highlightedCode = this.highlightCode(line, language);
        diffHtml += `<div class="vibe-coding-diff-line vibe-coding-unchanged">`;
        diffHtml += `<span class="vibe-coding-line-number">${originalLineNum}</span>`;
        diffHtml += `<span class="vibe-coding-line-number">${modifiedLineNum}</span>`;
        diffHtml += `<span class="vibe-coding-line-prefix">  </span>`;
        diffHtml += `<span class="vibe-coding-line-content">${highlightedCode}</span>`;
        diffHtml += `</div>`;
        originalLineNum++;
        modifiedLineNum++;
      }
    } else if (block.type === 'changed') {
      // Group all removed lines first
      for (const line of block.removed) {
        const highlightedCode = this.highlightCode(line, language);
        diffHtml += `<div class="vibe-coding-diff-line vibe-coding-removed">`;
        diffHtml += `<span class="vibe-coding-line-number">${originalLineNum}</span>`;
        diffHtml += `<span class="vibe-coding-line-number"></span>`;
        diffHtml += `<span class="vibe-coding-line-prefix">- </span>`;
        diffHtml += `<span class="vibe-coding-line-content">${highlightedCode}</span>`;
        diffHtml += `</div>`;
        originalLineNum++;
      }
      
      // Then group all added lines
      for (const line of block.added) {
        const highlightedCode = this.highlightCode(line, language);
        diffHtml += `<div class="vibe-coding-diff-line vibe-coding-added">`;
        diffHtml += `<span class="vibe-coding-line-number"></span>`;
        diffHtml += `<span class="vibe-coding-line-number">${modifiedLineNum}</span>`;
        diffHtml += `<span class="vibe-coding-line-prefix">+ </span>`;
        diffHtml += `<span class="vibe-coding-line-content">${highlightedCode}</span>`;
        diffHtml += `</div>`;
        modifiedLineNum++;
      }
    }
  }
  
  return diffHtml;
}

private computeDiff(original: string[], modified: string[]): Array<{type: 'unchanged' | 'changed', lines?: string[], removed?: string[], added?: string[]}> {
  const diff: Array<{type: 'unchanged' | 'changed', lines?: string[], removed?: string[], added?: string[]}> = [];
  let i = 0, j = 0;
  
  while (i < original.length || j < modified.length) {
    // Collect unchanged lines
    const unchangedLines: string[] = [];
    while (i < original.length && j < modified.length && original[i] === modified[j]) {
      unchangedLines.push(original[i]);
      i++;
      j++;
    }
    
    if (unchangedLines.length > 0) {
      diff.push({ type: 'unchanged', lines: unchangedLines });
    }
    
    // Collect changed lines (removed and added)
    const removedLines: string[] = [];
    const addedLines: string[] = [];
    
    // Look ahead to find the next matching line
    let matchFound = false;
    let tempI = i;
    let tempJ = j;
    
    // Try to find a common line within a reasonable window (e.g., next 10 lines)
    const lookAheadWindow = 10;
    for (let offsetI = 0; offsetI < lookAheadWindow && tempI + offsetI < original.length; offsetI++) {
      for (let offsetJ = 0; offsetJ < lookAheadWindow && tempJ + offsetJ < modified.length; offsetJ++) {
        if (original[tempI + offsetI] === modified[tempJ + offsetJ]) {
          // Found a match
          // Collect all removed lines before the match
          for (let k = 0; k < offsetI; k++) {
            removedLines.push(original[i + k]);
          }
          // Collect all added lines before the match
          for (let k = 0; k < offsetJ; k++) {
            addedLines.push(modified[j + k]);
          }
          i += offsetI;
          j += offsetJ;
          matchFound = true;
          break;
        }
      }
      if (matchFound) break;
    }
    
    // If no match found within window, collect remaining lines
    if (!matchFound) {
      while (i < original.length && j < modified.length) {
        // Check if lines match
        if (original[i] === modified[j]) {
          break;
        }
        removedLines.push(original[i]);
        addedLines.push(modified[j]);
        i++;
        j++;
      }
      
      // Collect any remaining removed lines
      while (i < original.length && (j >= modified.length || original[i] !== modified[j])) {
        removedLines.push(original[i]);
        i++;
      }
      
      // Collect any remaining added lines
      while (j < modified.length && (i >= original.length || original[i] !== modified[j])) {
        addedLines.push(modified[j]);
        j++;
      }
    }
    
    if (removedLines.length > 0 || addedLines.length > 0) {
      diff.push({ type: 'changed', removed: removedLines, added: addedLines });
    }
  }
  
  return diff;
}

private highlightCode(code: string, language: string): string {
  if (!code || typeof hljs === 'undefined') {
    return this.escapeHtml(code);
  }
  
  try {
    if (language !== 'plaintext' && hljs.getLanguage(language)) {
      const result = hljs.highlight(code, { language: language, ignoreIllegals: true });
      return result.value;
    }
  } catch (e) {
    return this.escapeHtml(code);
  }
  
  return this.escapeHtml(code);
}

public getLanguageFromFilename(filename: string): string {
  if (!filename) return 'plaintext';
  
  const ext = filename.split('.').pop()?.toLowerCase();
  const langMap: { [key: string]: string } = {
    'js': 'javascript',
    'jsx': 'javascript',
    'ts': 'typescript',
    'tsx': 'typescript',
    'py': 'python',
    'java': 'java',
    'cpp': 'cpp',
    'c': 'c',
    'cs': 'csharp',
    'php': 'php',
    'rb': 'ruby',
    'go': 'go',
    'rs': 'rust',
    'swift': 'swift',
    'kt': 'kotlin',
    'sql': 'sql',
    'html': 'html',
    'css': 'css',
    'scss': 'scss',
    'json': 'json',
    'xml': 'xml',
    'yaml': 'yaml',
    'yml': 'yaml',
    'md': 'markdown',
    'sh': 'bash',
    'bash': 'bash'
  };
  return langMap[ext || ''] || 'plaintext';
}

private escapeHtml(text: string): string {
  if (!text) return '';
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}
