export interface ModelsResponse {
  status: string;
  result: string[];
}

@Injectable({
  providedIn: 'root'
})
export class UploadGenerateService {
  private apiUrl = 'http://localhost:3000/api';  // Replace with your API base URL

  constructor(private http: HttpClient) { }

  /**
   * Get available models
   */
  getModels(): Observable<ModelsResponse> {
    return this.http.get<ModelsResponse>('/content_analytics/get_models');
  }

  // ... rest of the methods remain the same
}







import { Component, EventEmitter, Output, Input, OnDestroy, OnChanges, SimpleChanges, OnInit } from '@angular/core';
import { HttpEventType } from '@angular/common/http';
import { Subscription, interval } from 'rxjs';
import { switchMap, takeWhile } from 'rxjs/operators';
import { 
  UploadGenerateService, 
  UploadResponse, 
  GenerateRequest, 
  GenerateResponse,
  ProgressResponse,
  ModelsResponse
} from 'src/app/services/upload-generate.service';

// ... interfaces remain the same

@Component({
  selector: 'app-upload-generate',
  templateUrl: './upload-generate.component.html',
  styleUrls: ['./upload-generate.component.css']
})
export class UploadGenerateComponent implements OnInit, OnDestroy, OnChanges {
  @Input() requestFile: RequestFile | null = null;
  @Output() onGenerate = new EventEmitter<{ file: any, prompts: string, mode: 'new' }>();
  @Output() onFileRemoved = new EventEmitter<{ id: string | number, name: string }>();
  @Output() onGenerationComplete = new EventEmitter<{ id: number, status: 'Success' | 'Failed' }>();
  @Output() onFileUploaded = new EventEmitter<{ id: number, original_name: string, created_at: string }>();

  // ... existing properties

  // Model properties
  availableModels: string[] = [];
  selectedModel: string = '';
  isLoadingModels: boolean = false;
  modelsLoadError: string = '';

  private subscriptions: Subscription[] = [];
  private highlightTimeout: any;
  private progressPollingSubscription: Subscription | null = null;

  constructor(
    private uploadGenerateService: UploadGenerateService
  ) { }

  ngOnInit(): void {
    this.loadModels();
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['requestFile']) {
      this.handleRequestFileChange(changes['requestFile'].currentValue);
    }
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach(sub => sub.unsubscribe());
    if (this.highlightTimeout) {
      clearTimeout(this.highlightTimeout);
    }
    this.stopProgressPolling();
  }

  // Load models from API
  loadModels(): void {
    this.isLoadingModels = true;
    this.modelsLoadError = '';

    const sub = this.uploadGenerateService.getModels().subscribe({
      next: (response: ModelsResponse) => {
        console.log('Models loaded:', response);
        
        if (response.status === 'Success' && response.result && response.result.length > 0) {
          this.availableModels = response.result;
          // Select first model by default
          this.selectedModel = this.availableModels[0];
        } else {
          this.modelsLoadError = 'No models available';
        }
        
        this.isLoadingModels = false;
      },
      error: (error) => {
        console.error('Error loading models:', error);
        this.modelsLoadError = 'Failed to load models';
        this.isLoadingModels = false;
      }
    });
    
    this.subscriptions.push(sub);
  }

  // Refresh models
  refreshModels(): void {
    this.loadModels();
  }

  // Handle model selection change
  onModelChange(model: string): void {
    this.selectedModel = model;
    console.log('Model changed to:', model);
  }

  // ... rest of the existing methods remain the same

  // Update the startGeneration method to use selectedModel:
  private startGeneration(): void {
    if (!this.selectedGenerateFile) return;

    this.isProcessing = true;
    this.processingProgress = 0;
    this.processingFileName = this.selectedGenerateFile.name;
    this.processingFileId = String(this.selectedGenerateFile.id);
    this.generationStatus = 'generating';
    this.generationErrorMessage = '';

    const request: GenerateRequest = {
      fileID: Number(this.selectedGenerateFile.id),
      model_name: this.selectedModel, // Use selected model instead of hardcoded 'a'
      optional_prompt: this.optionalPrompts || ''
    };

    const sub = this.uploadGenerateService.generateAnalysis(request).subscribe({
      next: (response: GenerateResponse) => {
        console.log('Generation API response:', response);
        
        if (response.status === 'Success') {
          // Start progress polling
          this.startProgressPolling(Number(this.selectedGenerateFile!.id));
        } else {
          // Generation failed to start
          this.handleGenerationError('Failed to start generation');
        }
      },
      error: (error) => {
        console.error('Generation error:', error);
        this.handleGenerationError('Failed to initiate generation: ' + (error.message || 'Unknown error'));
      }
    });
    this.subscriptions.push(sub);
  }

  // ... rest of the methods remain the same
}













<div class="panel">
    <div class="panel-header">
        <h3 class="panel-title">Upload & Generate</h3>
        
        <!-- Model Selector -->
        <div class="model-selector-container">
            <div class="model-selector-wrapper">
                <label class="model-selector-label">Model:</label>
                <select class="model-dropdown" 
                        [(ngModel)]="selectedModel" 
                        (change)="onModelChange(selectedModel)"
                        [disabled]="isLoadingModels || isProcessing || isUploading">
                    <option *ngFor="let model of availableModels" [value]="model">
                        {{ model }}
                    </option>
                </select>
                <button class="model-refresh-btn" 
                        (click)="refreshModels()" 
                        [disabled]="isLoadingModels || isProcessing || isUploading"
                        [title]="'Refresh models'">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                        stroke="currentColor" [class.spin]="isLoadingModels">
                        <path stroke-linecap="round" stroke-linejoin="round"
                            d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99" />
                    </svg>
                </button>
            </div>
            <p class="model-error-message" *ngIf="modelsLoadError">{{ modelsLoadError }}</p>
        </div>
    </div>
    
    <!-- Rest of the template remains the same -->
    <div class="panel-content">
        <!-- ... existing content ... -->
    </div>
</div>










/* Update panel-header to accommodate model selector */
.panel-header {
    position: sticky;
    top: 0;
    z-index: 10;
    padding: 20px;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
    background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(167, 139, 250, 0.08));
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 20px;
}

.panel-title {
    font-size: 16px;
    font-weight: 700;
    color: var(--text-color);
    margin: 0;
    position: relative;
    padding-left: 16px;
    flex-shrink: 0;
}

.panel-title::before {
    content: '';
    position: absolute;
    left: 0;
    width: 3px;
    height: 20px;
    background: linear-gradient(180deg, var(--primary-color), #a78bfa);
    border-radius: 2px;
}

/* Model Selector Styles */
.model-selector-container {
    display: flex;
    flex-direction: column;
    gap: 4px;
    flex-shrink: 0;
}

.model-selector-wrapper {
    display: flex;
    align-items: center;
    gap: 8px;
}

.model-selector-label {
    font-size: 12px;
    font-weight: 600;
    color: var(--text-color);
    white-space: nowrap;
}

.model-dropdown {
    padding: 6px 12px;
    background-color: var(--bg-color);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 13px;
    font-weight: 500;
    color: var(--text-color);
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 120px;
}

.model-dropdown:hover:not(:disabled) {
    border-color: var(--primary-color);
    background-color: var(--footer-bg);
}

.model-dropdown:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
}

.model-dropdown:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.model-refresh-btn {
    width: 32px;
    height: 32px;
    padding: 6px;
    background-color: var(--footer-bg);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.model-refresh-btn:hover:not(:disabled) {
    background: linear-gradient(135deg, var(--primary-color), #a78bfa);
    border-color: var(--primary-color);
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
}

.model-refresh-btn:hover:not(:disabled) svg {
    stroke: white;
}

.model-refresh-btn:active:not(:disabled) {
    transform: translateY(0);
}

.model-refresh-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.model-refresh-btn svg {
    width: 18px;
    height: 18px;
    stroke: var(--text-color);
    transition: all 0.3s ease;
}

.model-refresh-btn svg.spin {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}

.model-error-message {
    font-size: 11px;
    color: #ef4444;
    margin: 0;
    text-align: right;
}

/* Rest of the CSS remains the same */


