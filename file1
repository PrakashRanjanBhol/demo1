<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chunked JSON Parser</title>
</head>
<body>
    <button onclick="runDemo()">RUN</button>
    <button id="acceptBtn" onclick="approveAndContinue()" style="display: none;">ACCEPT AND CONTINUE</button>

    <script>
        class ChunkedJSONParser {
            constructor() {
                this.buffer = '';
            }

            processChunk(chunk) {
                this.buffer += chunk;

                try {
                    const parsed = JSON.parse(this.buffer);
                    const result = { success: true, data: parsed };
                    this.buffer = '';
                    return result;
                } catch (error) {
                    return { success: false, data: null };
                }
            }

            reset() {
                this.buffer = '';
            }
        }

        // Configuration - Update these values
        const API_URL = 'https://api.anthropic.com/v1/messages';
        const API_KEY = 'YOUR_API_KEY_HERE';
        const REQUEST_BODY = {
            model: 'claude-3-5-sonnet-20241022',
            max_tokens: 1024,
            messages: [
                {
                    role: 'user',
                    content: 'Generate 5 JSON objects with this exact structure: {"tool": "READ", "content": "..."}. Mix READ, WRITE, and MODIFY tools. Return only JSON objects, one per line, nothing else.'
                }
            ],
            stream: true
        };

        // Queue system for handling approvals
        let pendingQueue = [];
        let isWaitingForApproval = false;
        let isStreamComplete = false;
        let currentPendingData = null;

        function showAcceptButton(data) {
            document.getElementById('acceptBtn').style.display = 'inline-block';
            currentPendingData = data;
            console.log('\n‚ö†Ô∏è WAITING FOR APPROVAL - Click "ACCEPT AND CONTINUE" button');
        }

        function hideAcceptButton() {
            document.getElementById('acceptBtn').style.display = 'none';
            currentPendingData = null;
        }

        function approveAndContinue() {
            if (currentPendingData) {
                console.log('‚úÖ APPROVED AND LOGGED:');
                console.log(currentPendingData);
                console.log('');
                
                hideAcceptButton();
                isWaitingForApproval = false;
                
                // Process next item in queue
                processQueue();
            }
        }

        function processQueue() {
            if (pendingQueue.length > 0 && !isWaitingForApproval) {
                const nextItem = pendingQueue.shift();
                handleParsedJSON(nextItem);
            } else if (pendingQueue.length === 0 && isStreamComplete && !isWaitingForApproval) {
                // All done
                console.log('\nüéâ COMPLETED');
            }
        }

        function handleParsedJSON(data) {
            const tool = data.tool;

            if (tool === 'READ') {
                // READ tool - log immediately
                console.log('üìñ READ Tool:');
                console.log(data);
                console.log('');
                
                // Continue processing queue
                processQueue();
            } else if (tool === 'WRITE' || tool === 'MODIFY') {
                // WRITE/MODIFY tool - require approval
                console.log(`‚ö†Ô∏è ${tool} Tool detected:`);
                console.log(data);
                
                isWaitingForApproval = true;
                showAcceptButton(data);
            } else {
                // Unknown tool - log immediately
                console.log('Tool:');
                console.log(data);
                console.log('');
                
                // Continue processing queue
                processQueue();
            }
        }

        async function runDemo() {
            console.clear();
            console.log('üöÄ Starting...\n');
            
            // Reset state
            pendingQueue = [];
            isWaitingForApproval = false;
            isStreamComplete = false;
            hideAcceptButton();

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': API_KEY,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify(REQUEST_BODY)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                const parser = new ChunkedJSONParser();

                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) {
                        isStreamComplete = true;
                        
                        // Check if we're done or still waiting
                        if (!isWaitingForApproval && pendingQueue.length === 0) {
                            console.log('\nüéâ COMPLETED');
                        }
                        break;
                    }

                    const chunk = decoder.decode(value, { stream: true });

                    // Process each character in the chunk
                    for (let char of chunk) {
                        const result = parser.processChunk(char);
                        
                        if (result.success) {
                            let toolData = result.data;
                            
                            // Handle Anthropic API response format
                            if (result.data.type === 'content_block_delta' && result.data.delta?.text) {
                                try {
                                    // Try to parse each line as JSON
                                    const lines = result.data.delta.text.split('\n');
                                    for (const line of lines) {
                                        if (line.trim()) {
                                            try {
                                                toolData = JSON.parse(line.trim());
                                                if (toolData.tool) {
                                                    pendingQueue.push(toolData);
                                                    if (!isWaitingForApproval) {
                                                        processQueue();
                                                    }
                                                }
                                            } catch (e) {
                                                // Not a valid JSON line, continue
                                            }
                                        }
                                    }
                                } catch (e) {
                                    // Not JSON, skip
                                }
                            } else if (toolData.tool) {
                                // Direct tool format
                                pendingQueue.push(toolData);
                                if (!isWaitingForApproval) {
                                    processQueue();
                                }
                            }
                        }
                    }
                }

            } catch (error) {
                console.error('‚ùå Error:', error);
            }
        }
    </script>
</body>
</html>
