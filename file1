import { Component, OnInit } from '@angular/core';
import { ChunkedJsonParserService, ToolData, ApprovalRequest } from './chunked-json-parser.service';

interface GroupedItem {
  type: 'READ_GROUP' | 'FILE_OP';
  items?: ToolData[];
  item?: ToolData;
}

@Component({
  selector: 'vibe-coding-chunked-json-parser',
  templateUrl: './chunked-json-parser.component.html',
  styleUrls: ['./chunked-json-parser.component.css']
})
export class ChunkedJsonParserComponent implements OnInit {
  public isWaitingForApproval = false;
  public currentApprovalRequest: ApprovalRequest | null = null;
  public isProcessing = false;
  public executedItems: ToolData[] = [];
  public queuedItems: ToolData[] = [];
  public groupedExecutedItems: GroupedItem[] = [];

  constructor(private parserService: ChunkedJsonParserService) {}

  ngOnInit(): void {
    // Callbacks will be set up when user clicks RUN
  }

  private setupCallbacks(): void {
    this.parserService.setCallbacks({
      onToolDetected: (toolData: ToolData) => {
        this.logToolDetected(toolData);
        this.updateLists();
        
        // If it's a READ tool, append content using DOM manipulation
        if (toolData.tool === 'READ') {
          this.appendReadContent(toolData);
        }
      },
      onApprovalRequest: (approvalRequest: ApprovalRequest) => {
        this.isWaitingForApproval = true;
        this.currentApprovalRequest = approvalRequest;
        this.logWaitingForApproval(approvalRequest.data);
        this.updateLists();
      },
      onCompletion: () => {
        this.isProcessing = false;
        this.logCompleted();
        this.updateLists();
      },
      onError: (error: string) => {
        this.isProcessing = false;
        this.logError(error);
      },
      onFirstChunk: () => {
        this.logFirstChunkReceived();
      }
    });
  }

  private appendReadContent(toolData: ToolData): void {
    // Get the executed list container
    const executedListElement = document.getElementById('vibe-coding-executed-list');
    
    if (!executedListElement) {
      console.warn('Executed list element not found');
      return;
    }

    // Create the READ item element
    const readItemDiv = document.createElement('div');
    readItemDiv.className = 'vibe-coding-file-item vibe-coding-read-group vibe-coding-new';
    
    // Create file icon
    const iconDiv = document.createElement('div');
    iconDiv.className = 'vibe-coding-file-icon';
    iconDiv.textContent = 'READ';
    
    // Create file info container
    const infoDiv = document.createElement('div');
    infoDiv.className = 'vibe-coding-file-info';
    
    // Create file name
    const nameDiv = document.createElement('div');
    nameDiv.className = 'vibe-coding-file-name';
    nameDiv.textContent = this.getReadContent(toolData.content);
    
    // Append elements
    infoDiv.appendChild(nameDiv);
    readItemDiv.appendChild(iconDiv);
    readItemDiv.appendChild(infoDiv);
    
    // Find the approval request element (if exists) to insert before it
    const approvalElement = executedListElement.querySelector('.vibe-coding-awaiting-approval');
    
    if (approvalElement) {
      // Insert before approval request
      executedListElement.insertBefore(readItemDiv, approvalElement);
    } else {
      // Append at the end
      executedListElement.appendChild(readItemDiv);
    }
  }

  private updateLists(): void {
    this.executedItems = this.parserService.getCompletedTools();
    this.queuedItems = this.parserService.getPendingTools();
    this.groupExecutedItems();
  }

  private groupExecutedItems(): void {
    const grouped: GroupedItem[] = [];
    let currentReadGroup: ToolData[] = [];

    this.executedItems.forEach((item) => {
      if (item.tool === 'READ') {
        currentReadGroup.push(item);
      } else {
        // If we have accumulated READ operations, add them as a group
        if (currentReadGroup.length > 0) {
          grouped.push({ type: 'READ_GROUP', items: [...currentReadGroup] });
          currentReadGroup = [];
        }
        // Add the WRITE/MODIFY operation
        grouped.push({ type: 'FILE_OP', item: item });
      }
    });

    // Don't forget remaining READ operations
    if (currentReadGroup.length > 0) {
      grouped.push({ type: 'READ_GROUP', items: [...currentReadGroup] });
    }

    this.groupedExecutedItems = grouped;
  }

  private logToolDetected(toolData: ToolData): void {
    const tool = toolData.tool;
    
    if (tool === 'READ') {
      console.log('üìñ READ Tool detected:', toolData);
    } else if (tool === 'WRITE') {
      console.log('‚úèÔ∏è WRITE Tool detected:', toolData);
    } else if (tool === 'MODIFY') {
      console.log('üîß MODIFY Tool detected:', toolData);
    } else {
      console.log('üîπ Tool detected:', toolData);
    }
  }

  private logFirstChunkReceived(): void {
    console.log('üì¶ First chunk received from stream');
  }

  private logWaitingForApproval(toolData: ToolData): void {
    console.log(`‚ö†Ô∏è WAITING FOR APPROVAL - ${toolData.tool} Tool:`, toolData);
    console.log('Click "ACCEPT AND CONTINUE" button to proceed');
  }

  private logCompleted(): void {
    console.log('üéâ COMPLETED - All operations finished successfully');
  }

  private logError(error: string): void {
    console.error('‚ùå Error:', error);
  }

  public async runDemo(): Promise<void> {
    console.clear();
    console.log('üöÄ Starting streaming process...\n');
    
    // Reset lists
    this.executedItems = [];
    this.queuedItems = [];
    this.groupedExecutedItems = [];
    
    // Clear the executed list DOM
    const executedListElement = document.getElementById('vibe-coding-executed-list');
    if (executedListElement) {
      // Remove all children except empty state
      const emptyState = executedListElement.querySelector('.vibe-coding-empty-state');
      executedListElement.innerHTML = '';
      if (emptyState) {
        executedListElement.appendChild(emptyState);
      }
    }
    
    // Setup callbacks before starting the stream
    this.setupCallbacks();
    
    this.isProcessing = true;
    
    try {
      await this.parserService.startStreaming();
    } catch (error) {
      // Only log if it's not an abort error
      if (error instanceof Error && error.name !== 'AbortError') {
        console.error('Failed to start streaming:', error);
      }
      this.isProcessing = false;
    }
  }

  public stopStreaming(): void {
    console.log('üõë Stopping streaming process...\n');
    this.parserService.stopStreaming();
    this.isProcessing = false;
    this.isWaitingForApproval = false;
    this.currentApprovalRequest = null;
  }

  public approveAndContinue(): void {
    if (this.currentApprovalRequest) {
      console.log('‚úÖ APPROVED:', this.currentApprovalRequest.data);
      console.log('Continuing with next operation...\n');
      
      // Reset approval state
      this.isWaitingForApproval = false;
      this.currentApprovalRequest = null;
      
      this.parserService.approveAndContinue();
      this.updateLists();
    }
  }

  public rejectChanges(): void {
    if (this.currentApprovalRequest) {
      console.log('‚ùå REJECTED:', this.currentApprovalRequest.data);
      console.log('Continuing with next operation...\n');
      
      // Mark as rejected and continue
      const rejectedData = { ...this.currentApprovalRequest.data, rejected: true };
      
      // Reset approval state
      this.isWaitingForApproval = false;
      this.currentApprovalRequest = null;
      
      this.parserService.approveAndContinue();
      this.updateLists();
    }
  }

  public getToolIcon(tool: string): string {
    const icons: { [key: string]: string } = {
      'READ': 'READ',
      'WRITE': 'WRITE',
      'MODIFY': 'EDIT'
    };
    return icons[tool] || 'TOOL';
  }

  public getFileExtension(filename: string): string {
    return filename.split('.').pop()?.toUpperCase() || 'FILE';
  }

  public formatTime(date: Date): string {
    return date.toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  }

  public isReadContent(content: any): boolean {
    return typeof content === 'string';
  }

  public getReadContent(content: any): string {
    return typeof content === 'string' ? content : '';
  }

  public getReadContents(items: ToolData[]): string {
    return items.map(item => this.getReadContent(item.content)).join(', ');
  }

  public getFileDetails(content: any): any {
    if (typeof content === 'object' && content.files && content.files.length > 0) {
      return content.files[0];
    }
    return null;
  }

  public getReasoning(content: any): string {
    if (typeof content === 'object' && content.reasoning) {
      return content.reasoning;
    }
    return '';
  }
}










<div class="vibe-coding-container">
  <div class="vibe-coding-header">
    <h1>Execution Flow Tracker</h1>
    <p>Monitor your tool execution pipeline</p>
    
    <div class="vibe-coding-button-container">
      <button 
        class="vibe-coding-btn vibe-coding-btn-primary" 
        (click)="runDemo()" 
        [disabled]="isProcessing">
        {{ isProcessing ? 'Processing...' : 'RUN' }}
      </button>

      <button 
        *ngIf="isProcessing"
        class="vibe-coding-btn vibe-coding-btn-danger" 
        (click)="stopStreaming()">
        STOP
      </button>
    </div>
  </div>

  <div class="vibe-coding-content">
    <!-- Executed Files Section -->
    <div class="vibe-coding-section vibe-coding-executed">
      <div class="vibe-coding-section-header">
        <div class="vibe-coding-section-icon">‚úì</div>
        <div class="vibe-coding-section-title">
          <h2>Executed</h2>
          <div class="vibe-coding-count"><span>{{ executedItems.length }}</span> completed</div>
        </div>
      </div>
      <div class="vibe-coding-file-list" id="vibe-coding-executed-list">
        <!-- Empty State -->
        <div *ngIf="executedItems.length === 0 && !currentApprovalRequest" class="vibe-coding-empty-state">
          <div class="vibe-coding-empty-state-icon">‚Äî</div>
          <p>No items executed yet</p>
        </div>

        <!-- READ items will be appended here via DOM manipulation -->
        <!-- WRITE/MODIFY items rendered via Angular below -->

        <!-- File Operations (WRITE/MODIFY) -->
        <ng-container *ngFor="let group of groupedExecutedItems">
          <div *ngIf="group.type === 'FILE_OP' && group.item" class="vibe-coding-file-item">
            <div class="vibe-coding-file-icon">{{ getFileExtension(getFileDetails(group.item.content)?.file_name || '') }}</div>
            <div class="vibe-coding-file-info">
              <div class="vibe-coding-file-name">{{ getFileDetails(group.item.content)?.file_name }}</div>
              <div class="vibe-coding-file-path">{{ getFileDetails(group.item.content)?.file_path }}</div>
            </div>
            <div class="vibe-coding-file-time" *ngIf="group.item.executedAt">{{ formatTime(group.item.executedAt) }}</div>
            <div 
              class="vibe-coding-status-badge" 
              [ngClass]="{'vibe-coding-rejected': group.item.rejected}">
              {{ group.item.rejected ? 'REJECTED' : group.item.tool }}
            </div>
          </div>
        </ng-container>

        <!-- Approval Request (at bottom) -->
        <div *ngIf="currentApprovalRequest" class="vibe-coding-file-item vibe-coding-awaiting-approval">
          <div class="vibe-coding-approval-header">
            <div class="vibe-coding-file-icon">{{ getFileExtension(getFileDetails(currentApprovalRequest.data.content)?.file_name || '') }}</div>
            <div class="vibe-coding-file-info">
              <div class="vibe-coding-file-name">{{ getFileDetails(currentApprovalRequest.data.content)?.file_name }}</div>
              <div class="vibe-coding-file-path">{{ getFileDetails(currentApprovalRequest.data.content)?.file_path }}</div>
            </div>
            <div class="vibe-coding-approval-badge">{{ currentApprovalRequest.data.tool }}</div>
          </div>
          <div class="vibe-coding-reasoning-box">
            <h3>Reasoning</h3>
            <p>{{ getReasoning(currentApprovalRequest.data.content) }}</p>
          </div>
          <div class="vibe-coding-diff-container">
            <div class="vibe-coding-diff-header">Changes</div>
            <div class="vibe-coding-code-block">
              <pre>{{ getFileDetails(currentApprovalRequest.data.content)?.modified_code }}</pre>
            </div>
          </div>
          <div class="vibe-coding-approval-actions">
            <button class="vibe-coding-approval-btn vibe-coding-reject" (click)="rejectChanges()">‚úï Reject</button>
            <button class="vibe-coding-approval-btn vibe-coding-accept" (click)="approveAndContinue()">‚úì Accept & Continue</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Queued Files Section -->
    <div class="vibe-coding-section vibe-coding-queued">
      <div class="vibe-coding-section-header">
        <div class="vibe-coding-section-icon">‚ãØ</div>
        <div class="vibe-coding-section-title">
          <h2>Queued</h2>
          <div class="vibe-coding-count"><span>{{ queuedItems.length }}</span> pending</div>
        </div>
      </div>
      <div class="vibe-coding-file-list">
        <!-- Empty State -->
        <div *ngIf="queuedItems.length === 0 && !isProcessing" class="vibe-coding-empty-state">
          <div class="vibe-coding-empty-state-icon">‚Äî</div>
          <p>No items in queue</p>
        </div>

        <!-- Loading State -->
        <div *ngIf="queuedItems.length === 0 && isProcessing && executedItems.length > 0" class="vibe-coding-loading-state">
          <div class="vibe-coding-loading-spinner"></div>
          <h3>Generating Next Task<span class="vibe-coding-loading-dots"><span>.</span><span>.</span><span>.</span></span></h3>
          <p>Analyzing execution results</p>
        </div>

        <!-- Queued Items -->
        <div *ngFor="let item of queuedItems; let i = index" class="vibe-coding-file-item">
          <!-- READ Item -->
          <ng-container *ngIf="item.tool === 'READ'">
            <div class="vibe-coding-file-icon">{{ getToolIcon(item.tool) }}</div>
            <div class="vibe-coding-file-info">
              <div class="vibe-coding-file-name">{{ getReadContent(item.content) }}</div>
            </div>
            <div class="vibe-coding-status-badge">Position {{ i + 1 }}</div>
          </ng-container>

          <!-- File Operation Item -->
          <ng-container *ngIf="item.tool !== 'READ'">
            <div class="vibe-coding-file-icon">{{ getFileExtension(getFileDetails(item.content)?.file_name || '') }}</div>
            <div class="vibe-coding-file-info">
              <div class="vibe-coding-file-name">{{ getFileDetails(item.content)?.file_name }}</div>
              <div class="vibe-coding-file-path">{{ getFileDetails(item.content)?.file_path }}</div>
            </div>
            <div class="vibe-coding-status-badge">{{ item.tool }}</div>
          </ng-container>
        </div>
      </div>
    </div>
  </div>
</div>
