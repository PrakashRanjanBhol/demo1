// Compact diff for large files - shows only changes with context
private generateCompactDiff(file: DiffFile): DiffLine[] {
  const oldText = file.old_lines.join('\n');
  const newText = file.new_lines.join('\n');
  const diff = Diff.diffLines(oldText, newText);

  const allLines: DiffLine[] = [];
  let oldLineNum = 1;
  let newLineNum = 1;

  // First pass: generate all lines with their types
  diff.forEach(part => {
    const lineTexts = part.value.split('\n');
    if (lineTexts[lineTexts.length - 1] === '') {
      lineTexts.pop();
    }

    lineTexts.forEach(lineText => {
      if (part.added) {
        const comment = this.findCommentForLine(file, newLineNum, 'TO');
        allLines.push({
          type: 'added',
          newLineNum,
          content: this.highlightSyntax(lineText, file.file_path),
          comment
        });
        newLineNum++;
      } else if (part.removed) {
        const comment = this.findCommentForLine(file, oldLineNum, 'FROM');
        allLines.push({
          type: 'deleted',
          oldLineNum,
          content: this.highlightSyntax(lineText, file.file_path),
          comment
        });
        oldLineNum++;
      } else {
        const commentFrom = this.findCommentForLine(file, oldLineNum, 'FROM');
        const commentTo = this.findCommentForLine(file, newLineNum, 'TO');
        const comment = commentTo || commentFrom;
        
        allLines.push({
          type: 'context',
          oldLineNum,
          newLineNum,
          content: this.highlightSyntax(lineText, file.file_path),
          comment
        });
        oldLineNum++;
        newLineNum++;
      }
    });
  });

  // Second pass: identify ranges to show (changes + context + comments)
  const linesToShow = new Set<number>();
  
  allLines.forEach((line, index) => {
    // Include all changed lines
    if (line.type === 'added' || line.type === 'deleted') {
      linesToShow.add(index);
      // Add context lines around changes
      for (let i = Math.max(0, index - this.CONTEXT_LINES); i <= Math.min(allLines.length - 1, index + this.CONTEXT_LINES); i++) {
        linesToShow.add(i);
      }
    }
    
    // Include lines with comments and their context (EVEN IF NOT MODIFIED)
    if (line.comment) {
      linesToShow.add(index);
      // Add context lines around comments
      for (let i = Math.max(0, index - this.CONTEXT_LINES); i <= Math.min(allLines.length - 1, index + this.CONTEXT_LINES); i++) {
        linesToShow.add(i);
      }
    }
  });

  // Third pass: build final output with separators
  const compactLines: DiffLine[] = [];
  const sortedIndices = Array.from(linesToShow).sort((a, b) => a - b);
  
  let lastIndex = -1;
  sortedIndices.forEach(index => {
    // Add separator if there's a gap (more than 1 line)
    if (lastIndex !== -1 && index - lastIndex > 1) {
      compactLines.push({
        type: 'context',
        content: this.createSeparatorContent(lastIndex, index, allLines),
        oldLineNum: undefined,
        newLineNum: undefined
      });
    }
    
    compactLines.push(allLines[index]);
    lastIndex = index;
  });

  return compactLines;
}
