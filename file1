import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';

@Component({
  selector: 'app-chat',
  templateUrl: './chat.component.html',
  styleUrls: ['./chat.component.css']
})
export class ChatComponent implements OnChanges {
  @Input() chunk: string = '';

  htmlCode: string = '';
  cssCode: string = '';
  jsCode: string = '';
  otherCode: string = '';

  private buffer: string = '';       // entire incoming buffer
  private insideBlock = false;       // are we inside a code block?
  private currentLang: string | null = null; // language of current code block
  private blockBuffer: string = '';  // buffer for current code block content

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['chunk'] && this.chunk) {
      this.processChunk(this.chunk);
    }
  }

  private processChunk(chunk: string) {
    if (!chunk) return;

    // normalize newlines
    this.buffer += chunk.replace(/\\r\\n/g, '\n').replace(/\\n/g, '\n').replace(/\r/g, '');

    while (this.buffer.length > 0) {
      if (!this.insideBlock) {
        const fenceIndex = this.buffer.indexOf('```');
        if (fenceIndex === -1) break;

        this.insideBlock = true;
        this.buffer = this.buffer.slice(fenceIndex + 3);
        this.currentLang = null;
        this.blockBuffer = '';
      }

      if (this.insideBlock && this.currentLang === null) {
        // detect language
        const nlIndex = this.buffer.indexOf('\n');
        let langLine = '';
        if (nlIndex !== -1) {
          langLine = this.buffer.slice(0, nlIndex).trim().toLowerCase();
          this.buffer = this.buffer.slice(nlIndex + 1);
        } else {
          // wait for more data if no newline yet
          break;
        }

        if (langLine === 'html') this.currentLang = 'html';
        else if (langLine === 'css') this.currentLang = 'css';
        else if (langLine === 'js' || langLine === 'javascript') this.currentLang = 'js';
        else this.currentLang = 'other';
      }

      if (this.insideBlock && this.currentLang !== null) {
        const closingIndex = this.buffer.indexOf('```');
        if (closingIndex === -1) {
          // no closing fence yet -> append all to blockBuffer and wait
          this.blockBuffer += this.buffer;
          this.buffer = '';
          break;
        } else {
          // closing fence found -> append until closing
          this.blockBuffer += this.buffer.slice(0, closingIndex);
          this.appendToLanguageBucket(this.currentLang, this.blockBuffer);

          // remove used content + closing fence
          this.buffer = this.buffer.slice(closingIndex + 3);
          this.insideBlock = false;
          this.currentLang = null;
          this.blockBuffer = '';
        }
      }
    }
  }

  private appendToLanguageBucket(lang: string, content: string) {
    if (!content) return;
    switch (lang) {
      case 'html': this.htmlCode += content; break;
      case 'css': this.cssCode += content; break;
      case 'js': this.jsCode += content; break;
      default: this.otherCode += content; break;
    }
  }
}
