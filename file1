import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';

@Component({
  selector: 'app-code-renderer',
  template: `
    <div class="code-section" *ngIf="htmlCode">
      <h3>HTML</h3>
      <pre><code>{{ htmlCode }}</code></pre>
    </div>

    <div class="code-section" *ngIf="cssCode">
      <h3>CSS</h3>
      <pre><code>{{ cssCode }}</code></pre>
    </div>

    <div class="code-section" *ngIf="jsCode">
      <h3>JavaScript</h3>
      <pre><code>{{ jsCode }}</code></pre>
    </div>
  `,
  styles: [`
    .code-section { margin-bottom: 1rem; }
    pre { background: #1e1e1e; color: #dcdcdc; padding: 1rem; border-radius: 8px; overflow-x: auto; }
  `]
})
export class CodeRendererComponent implements OnChanges {
  @Input() chunk: string = '';

  htmlCode = '';
  cssCode = '';
  jsCode = '';

  private unprocessed = '';
  private isInsideBlock = false;
  private currentLang: string | null = null;
  private waitingForLang = false;

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['chunk']?.currentValue) {
      this.processChunk(changes['chunk'].currentValue);
    }
  }

  private processChunk(chunk: string) {
    this.unprocessed += chunk;

    while (this.unprocessed.length > 0) {
      if (!this.isInsideBlock) {
        // üîç Look for opening fence only if at line start
        const fenceMatch = this.unprocessed.match(/(^|\n)```/);
        if (!fenceMatch) break;

        const fenceIndex = fenceMatch.index!;
        const langLine = this.unprocessed.substring(fenceIndex + fenceMatch[0].length);
        const nextNewline = langLine.indexOf('\n');

        let lang = '';
        if (nextNewline !== -1) {
          lang = langLine.substring(0, nextNewline).trim().toLowerCase();
        } else {
          lang = langLine.trim().toLowerCase();
        }

        this.isInsideBlock = true;
        this.currentLang = lang || null;
        this.waitingForLang = !lang;

        this.unprocessed = this.unprocessed.substring(fenceIndex + fenceMatch[0].length + (nextNewline !== -1 ? nextNewline + 1 : 0));
      } else {
        // üîç Look for closing fence only if at line start
        const closingMatch = this.unprocessed.match(/(^|\n)```/);
        if (!closingMatch) {
          this.appendCode(this.unprocessed);
          this.unprocessed = '';
          break;
        }

        const closingIndex = closingMatch.index!;
        const codeBlock = this.unprocessed.substring(0, closingIndex);
        this.appendCode(codeBlock);

        this.isInsideBlock = false;
        this.currentLang = null;
        this.waitingForLang = false;

        this.unprocessed = this.unprocessed.substring(closingIndex + closingMatch[0].length);
      }
    }
  }

  private appendCode(text: string) {
    if (!this.currentLang) return;

    switch (this.currentLang) {
      case 'html':
        this.htmlCode += text + '\n';
        break;
      case 'css':
        this.cssCode += text + '\n';
        break;
      case 'js':
      case 'javascript':
        this.jsCode += text + '\n';
        break;
    }
  }
}
