<!-- ONLY SHOWING THE MODIFIED PART FOR KEYWORDS DISPLAY -->

<!-- Dynamic Result Content -->
<div class="result-content" *ngIf="selectedHistoryItem && !isLoadingResults && resultItems.length > 0">
    <!-- Result Items -->
    <div class="result-item" *ngFor="let item of resultItems"
        [class.selected]="selectedResultItemId === item.id">
        <div class="result-item-header">
            <div class="result-item-icon">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" [attr.d]="getIconPath(item.icon)" />
                </svg>
            </div>
            <div class="result-item-title-section">
                <h4 class="result-item-title">{{ item.title }}</h4>
            </div>
            <!-- Viewing Badge -->
            <div class="viewing-badge" *ngIf="selectedResultItemId === item.id">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round"
                        d="M2.036 12.322a1.012 1.012 0 010-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
                <span>Viewing</span>
            </div>
            <div class="result-actions">
                <button class="result-action-icon-btn" title="Expand" (click)="openDetail(item)">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round"
                            d="M15.75 4.5H19.5v3.75M19.5 4.5l-5.25 5.25M8.25 19.5H4.5v-3.75M4.5 19.5l5.25-5.25" />
                    </svg>
                </button>
                <button class="result-action-icon-btn" title="Copy" (click)="copyToClipboard(item.content)">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round"
                            d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 01-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 011.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 00-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 01-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 00-3.375-3.375h-1.5a1.125 1.125 0 01-1.125-1.125v-1.5a3.375 3.375 0 00-3.375-3.375H9.75" />
                    </svg>
                </button>
                <button class="result-action-icon-btn" title="Download" (click)="downloadContent(item)">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                        stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round"
                            d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" />
                    </svg>
                </button>
            </div>
        </div>

        <!-- MODIFIED CONTENT SECTION - Different display for keywords -->
        <div class="result-item-content">
            <!-- KEYWORDS - Show as chips -->
            <div *ngIf="item.type === 'keywords'" class="keywords-chips-container">
                <div class="keyword-chip" 
                     *ngFor="let keyword of getKeywordsArray(item); let i = index"
                     [style.background]="getChipBackground(i)"
                     [style.border-color]="getChipBorderColor(i)">
                    <span class="chip-text">{{ keyword }}</span>
                    <button class="chip-remove-btn" 
                            (click)="removeKeyword(item.id, keyword)"
                            title="Remove keyword">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                
                <!-- Show message if all keywords removed -->
                <p class="no-keywords-message" *ngIf="getKeywordsArray(item).length === 0">
                    No keywords available
                </p>
            </div>

            <!-- SUMMARY & QUESTIONS - Show with ellipsis -->
            <div *ngIf="item.type !== 'keywords'">
                <p class="result-text" 
                   [class.text-ellipsis]="shouldShowEllipsis(item)"
                   [class.text-expanded]="isExpanded(item.id)">
                    {{ item.content }}
                </p>
                
                <button class="read-more-btn" 
                        *ngIf="shouldShowEllipsis(item) && isContentLong(item.content)"
                        (click)="toggleExpand(item.id)">
                    {{ isExpanded(item.id) ? 'Read less' : 'Read more' }}
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" 
                         stroke="currentColor"
                         [class.rotate-180]="isExpanded(item.id)">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                    </svg>
                </button>
            </div>
        </div>
    </div>
</div>











// ONLY SHOWING THE MODIFIED/NEW PARTS

import { Component, Input } from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import { marked } from 'marked';

interface ResultItem {
  id: string;
  title: string;
  icon: string;
  content: string;
  type: 'summary' | 'keywords' | 'questions' | 'custom';
  keywords?: string[];  // NEW - Store keywords as array
}

// ... rest of interfaces remain same ...

@Component({
  selector: 'app-workspace',
  templateUrl: './workspace.component.html',
  styleUrls: ['./workspace.component.css']
})
export class WorkspaceComponent {
  @Input() selectedHistoryItem: HistoryItem | null = null;
  @Input() resultItems: ResultItem[] = [];
  @Input() isLoadingResults: boolean = false;

  isDetailOpen = false;
  selectedItemName = '';
  selectedItemDate = '';
  selectedItemContent: SafeHtml = '';
  selectedResultItemId: string = '';

  expandedItems: Set<string> = new Set();
  private readonly CHAR_LIMIT = 200;

  // NEW - Chip color schemes (gradient backgrounds)
  private chipColors = [
    { bg: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', border: '#667eea' },  // Purple
    { bg: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)', border: '#f093fb' },  // Pink
    { bg: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)', border: '#4facfe' },  // Blue
    { bg: 'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)', border: '#43e97b' },  // Green
    { bg: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)', border: '#fa709a' },  // Orange-Pink
    { bg: 'linear-gradient(135deg, #30cfd0 0%, #330867 100%)', border: '#30cfd0' },  // Teal
    { bg: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)', border: '#a8edea' },  // Pastel
    { bg: 'linear-gradient(135deg, #ff9a56 0%, #ff6a88 100%)', border: '#ff9a56' },  // Coral
    { bg: 'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)', border: '#ffecd2' },  // Peach
    { bg: 'linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%)', border: '#a1c4fd' },  // Sky Blue
  ];

  constructor(private sanitizer: DomSanitizer) { }

  // ... existing methods remain same (openDetail, closeDetail, getIconPath, etc.) ...

  // NEW METHODS FOR KEYWORD CHIPS

  /**
   * Get keywords as array from result item
   */
  getKeywordsArray(item: ResultItem): string[] {
    // If keywords are already an array (from API response)
    if (item.keywords && Array.isArray(item.keywords)) {
      return item.keywords;
    }
    
    // If content is a string with bullets, parse it
    if (item.content && typeof item.content === 'string') {
      return item.content
        .split('•')
        .map(k => k.trim())
        .filter(k => k.length > 0);
    }
    
    return [];
  }

  /**
   * Get chip background color based on index
   */
  getChipBackground(index: number): string {
    const colorIndex = index % this.chipColors.length;
    return this.chipColors[colorIndex].bg;
  }

  /**
   * Get chip border color based on index
   */
  getChipBorderColor(index: number): string {
    const colorIndex = index % this.chipColors.length;
    return this.chipColors[colorIndex].border;
  }

  /**
   * Remove a keyword from the list
   */
  removeKeyword(itemId: string, keyword: string): void {
    const item = this.resultItems.find(i => i.id === itemId);
    if (!item) return;

    if (item.keywords && Array.isArray(item.keywords)) {
      // Remove from keywords array
      item.keywords = item.keywords.filter(k => k !== keyword);
      
      // Update content string as well
      item.content = item.keywords.map(k => `• ${k}`).join(' ');
    } else {
      // Parse from content string
      const keywords = this.getKeywordsArray(item);
      const updatedKeywords = keywords.filter(k => k !== keyword);
      
      // Update both content and keywords array
      item.content = updatedKeywords.map(k => `• ${k}`).join(' ');
      item.keywords = updatedKeywords;
    }
  }

  /**
   * Copy all keywords to clipboard
   */
  copyToClipboard(content: string): void {
    navigator.clipboard.writeText(content).then(() => {
      console.log('Content copied to clipboard');
    });
  }

  // ... rest of existing methods remain same ...
}












/* ADD THESE STYLES TO workspace.component.css */

/* Keywords Chips Container */
.keywords-chips-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    padding: 0;
    min-height: 40px;
}

/* Individual Keyword Chip */
.keyword-chip {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 12px;
    border-radius: 20px;
    border: 1px solid;
    font-size: 12px;
    font-weight: 600;
    color: white;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
    animation: chipFadeIn 0.3s ease-out;
    position: relative;
    overflow: hidden;
}

/* Chip fade in animation */
@keyframes chipFadeIn {
    from {
        opacity: 0;
        transform: scale(0.8) translateY(-10px);
    }
    to {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

/* Chip hover effect */
.keyword-chip:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

/* Chip text */
.chip-text {
    line-height: 1;
    white-space: nowrap;
    user-select: none;
}

/* Chip remove button */
.chip-remove-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
    padding: 0;
    background: rgba(255, 255, 255, 0.3);
    border: none;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s ease;
    flex-shrink: 0;
}

.chip-remove-btn:hover {
    background: rgba(255, 255, 255, 0.5);
    transform: scale(1.1);
}

.chip-remove-btn svg {
    width: 10px;
    height: 10px;
    stroke: white;
    stroke-width: 2.5;
}

/* No keywords message */
.no-keywords-message {
    font-size: 12px;
    color: var(--text-color);
    opacity: 0.5;
    font-style: italic;
    margin: 0;
    padding: 8px 0;
}

/* Chip remove animation */
@keyframes chipRemove {
    0% {
        opacity: 1;
        transform: scale(1);
    }
    50% {
        opacity: 0.5;
        transform: scale(0.9);
    }
    100% {
        opacity: 0;
        transform: scale(0.5);
    }
}

.keyword-chip.removing {
    animation: chipRemove 0.3s ease-out forwards;
}

/* Responsive chips */
@media (max-width: 768px) {
    .keywords-chips-container {
        gap: 6px;
    }
    
    .keyword-chip {
        padding: 5px 10px;
        font-size: 11px;
    }
}

/* Chip shine effect on hover */
.keyword-chip::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    transition: left 0.5s ease;
}

.keyword-chip:hover::before {
    left: 100%;
}

/* Different chip sizes based on content length */
.keyword-chip.chip-small {
    padding: 5px 10px;
    font-size: 11px;
}

.keyword-chip.chip-medium {
    padding: 6px 12px;
    font-size: 12px;
}

.keyword-chip.chip-large {
    padding: 7px 14px;
    font-size: 13px;
}

/* Optional: Add pulse effect for newly added chips */
@keyframes chipPulse {
    0%, 100% {
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    50% {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
}

.keyword-chip.new-chip {
    animation: chipFadeIn 0.3s ease-out, chipPulse 1s ease-in-out;
}











// ONLY SHOWING THE MODIFIED PART

// MODIFIED METHOD - Map keywords as array instead of string
private mapResponseToResultItems(data: FileResultData): any[] {
  const items: any[] = [];

  // Add summary
  if (data.summary) {
    items.push({
      id: 'summary',
      title: 'Lecture Summary',
      icon: 'document',
      content: data.summary,
      type: 'summary'
    });
  }

  // MODIFIED - Add keywords as array
  if (data.keywords && data.keywords.length > 0) {
    items.push({
      id: 'keywords',
      title: 'Keywords',
      icon: 'tag',
      content: data.keywords.map(k => `• ${k}`).join(' '),  // Keep for clipboard copy
      keywords: data.keywords,  // NEW - Add keywords as array
      type: 'keywords'
    });
  }

  // Add FAQ as assessment questions
  if (data.faq && data.faq.length > 0) {
    data.faq.forEach((faqItem, index) => {
      items.push({
        id: `faq-${index}`,
        title: `Question ${index + 1}`,
        icon: 'question',
        content: `**Q: ${faqItem.question}**\n\n**A:** ${faqItem.answer}`,
        type: 'questions'
      });
    });
  }

  return items;
}
