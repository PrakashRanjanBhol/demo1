import { Component, OnInit } from '@angular/core';
import { ChunkedJsonParserService, ToolData, ApprovalRequest } from './chunked-json-parser.service';

interface GroupedItem {
  type: 'READ_GROUP' | 'FILE_OP';
  items?: ToolData[];
  item?: ToolData;
}

@Component({
  selector: 'vibe-coding-chunked-json-parser',
  templateUrl: './chunked-json-parser.component.html',
  styleUrls: ['./chunked-json-parser.component.css']
})
export class ChunkedJsonParserComponent implements OnInit {
  public isWaitingForApproval = false;
  public currentApprovalRequest: ApprovalRequest | null = null;
  public isProcessing = false;
  public executedItems: ToolData[] = [];
  public queuedItems: ToolData[] = [];
  public groupedExecutedItems: GroupedItem[] = [];

  constructor(private parserService: ChunkedJsonParserService) {}

  ngOnInit(): void {
    // Callbacks will be set up when user clicks RUN
  }

  private setupCallbacks(): void {
    this.parserService.setCallbacks({
      onToolDetected: (toolData: ToolData) => {
        this.logToolDetected(toolData);
        this.updateLists();
        
        // If it's a READ tool, append content using DOM manipulation
        if (toolData.tool === 'READ') {
          this.appendReadContent(toolData);
        }
      },
      onApprovalRequest: (approvalRequest: ApprovalRequest) => {
        this.isWaitingForApproval = true;
        this.currentApprovalRequest = approvalRequest;
        this.logWaitingForApproval(approvalRequest.data);
        this.updateLists();
      },
      onCompletion: () => {
        this.isProcessing = false;
        this.logCompleted();
        this.updateLists();
      },
      onError: (error: string) => {
        this.isProcessing = false;
        this.logError(error);
      },
      onFirstChunk: () => {
        this.logFirstChunkReceived();
      }
    });
  }

  private appendReadContent(toolData: ToolData): void {
    // Get the executed list container
    const executedListElement = document.getElementById('vibe-coding-executed-list');
    
    if (!executedListElement) {
      console.warn('Executed list element not found');
      return;
    }

    // Remove empty state if it exists
    const emptyState = executedListElement.querySelector('.vibe-coding-empty-state');
    if (emptyState) {
      emptyState.remove();
    }

    // Create the READ item element
    const readItemDiv = document.createElement('div');
    readItemDiv.className = 'vibe-coding-file-item vibe-coding-read-group vibe-coding-new vibe-coding-dom-item';
    readItemDiv.setAttribute('data-read-item', 'true'); // Mark as DOM-added item
    
    // Create file icon
    const iconDiv = document.createElement('div');
    iconDiv.className = 'vibe-coding-file-icon';
    iconDiv.textContent = 'READ';
    
    // Create file info container
    const infoDiv = document.createElement('div');
    infoDiv.className = 'vibe-coding-file-info';
    
    // Create file name
    const nameDiv = document.createElement('div');
    nameDiv.className = 'vibe-coding-file-name';
    nameDiv.textContent = this.getReadContent(toolData.content);
    
    // Append elements
    infoDiv.appendChild(nameDiv);
    readItemDiv.appendChild(iconDiv);
    readItemDiv.appendChild(infoDiv);
    
    // Find the approval request element (if exists) to insert before it
    const approvalElement = executedListElement.querySelector('.vibe-coding-awaiting-approval');
    
    if (approvalElement) {
      // Insert before approval request
      executedListElement.insertBefore(readItemDiv, approvalElement);
    } else {
      // Find the last Angular-rendered item (FILE_OP items)
      const angularItems = executedListElement.querySelectorAll('.vibe-coding-file-item:not([data-read-item])');
      if (angularItems.length > 0) {
        const lastAngularItem = angularItems[angularItems.length - 1];
        lastAngularItem.insertAdjacentElement('afterend', readItemDiv);
      } else {
        // Append at the end if no Angular items exist
        executedListElement.appendChild(readItemDiv);
      }
    }
  }

  private clearDOMReadItems(): void {
    const executedListElement = document.getElementById('vibe-coding-executed-list');
    if (!executedListElement) {
      return;
    }

    // Remove only DOM-added READ items, keep Angular-rendered items
    const readItems = executedListElement.querySelectorAll('[data-read-item="true"]');
    readItems.forEach(item => item.remove());
  }

  private updateLists(): void {
    this.executedItems = this.parserService.getCompletedTools();
    this.queuedItems = this.parserService.getPendingTools();
    this.groupExecutedItems();
  }

  private groupExecutedItems(): void {
    const grouped: GroupedItem[] = [];
    let currentReadGroup: ToolData[] = [];

    this.executedItems.forEach((item) => {
      if (item.tool === 'READ') {
        currentReadGroup.push(item);
      } else {
        // If we have accumulated READ operations, add them as a group
        if (currentReadGroup.length > 0) {
          grouped.push({ type: 'READ_GROUP', items: [...currentReadGroup] });
          currentReadGroup = [];
        }
        // Add the WRITE/MODIFY operation
        grouped.push({ type: 'FILE_OP', item: item });
      }
    });

    // Don't forget remaining READ operations
    if (currentReadGroup.length > 0) {
      grouped.push({ type: 'READ_GROUP', items: [...currentReadGroup] });
    }

    this.groupedExecutedItems = grouped;
  }

  private logToolDetected(toolData: ToolData): void {
    const tool = toolData.tool;
    
    if (tool === 'READ') {
      console.log('üìñ READ Tool detected:', toolData);
    } else if (tool === 'WRITE') {
      console.log('‚úèÔ∏è WRITE Tool detected:', toolData);
    } else if (tool === 'MODIFY') {
      console.log('üîß MODIFY Tool detected:', toolData);
    } else {
      console.log('üîπ Tool detected:', toolData);
    }
  }

  private logFirstChunkReceived(): void {
    console.log('üì¶ First chunk received from stream');
  }

  private logWaitingForApproval(toolData: ToolData): void {
    console.log(`‚ö†Ô∏è WAITING FOR APPROVAL - ${toolData.tool} Tool:`, toolData);
    console.log('Click "ACCEPT AND CONTINUE" button to proceed');
  }

  private logCompleted(): void {
    console.log('üéâ COMPLETED - All operations finished successfully');
  }

  private logError(error: string): void {
    console.error('‚ùå Error:', error);
  }

  public async runDemo(): Promise<void> {
    console.clear();
    console.log('üöÄ Starting streaming process...\n');
    
    // Reset lists
    this.executedItems = [];
    this.queuedItems = [];
    this.groupedExecutedItems = [];
    
    // Clear only DOM-added READ items, NOT the entire container
    this.clearDOMReadItems();
    
    // Setup callbacks before starting the stream
    this.setupCallbacks();
    
    this.isProcessing = true;
    
    try {
      await this.parserService.startStreaming();
    } catch (error) {
      // Only log if it's not an abort error
      if (error instanceof Error && error.name !== 'AbortError') {
        console.error('Failed to start streaming:', error);
      }
      this.isProcessing = false;
    }
  }

  public stopStreaming(): void {
    console.log('üõë Stopping streaming process...\n');
    this.parserService.stopStreaming();
    this.isProcessing = false;
    this.isWaitingForApproval = false;
    this.currentApprovalRequest = null;
  }

  public approveAndContinue(): void {
    if (this.currentApprovalRequest) {
      console.log('‚úÖ APPROVED:', this.currentApprovalRequest.data);
      console.log('Continuing with next operation...\n');
      
      // Reset approval state
      this.isWaitingForApproval = false;
      this.currentApprovalRequest = null;
      
      this.parserService.approveAndContinue();
      this.updateLists();
    }
  }

  public rejectChanges(): void {
    if (this.currentApprovalRequest) {
      console.log('‚ùå REJECTED:', this.currentApprovalRequest.data);
      console.log('Continuing with next operation...\n');
      
      // Mark as rejected and continue
      const rejectedData = { ...this.currentApprovalRequest.data, rejected: true };
      
      // Reset approval state
      this.isWaitingForApproval = false;
      this.currentApprovalRequest = null;
      
      this.parserService.approveAndContinue();
      this.updateLists();
    }
  }

  public getToolIcon(tool: string): string {
    const icons: { [key: string]: string } = {
      'READ': 'READ',
      'WRITE': 'WRITE',
      'MODIFY': 'EDIT'
    };
    return icons[tool] || 'TOOL';
  }

  public getFileExtension(filename: string): string {
    if (!filename) return 'FILE';
    return filename.split('.').pop()?.toUpperCase() || 'FILE';
  }

  public formatTime(date: Date): string {
    return date.toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  }

  public isReadContent(content: any): boolean {
    return typeof content === 'string';
  }

  public getReadContent(content: any): string {
    return typeof content === 'string' ? content : '';
  }

  public getReadContents(items: ToolData[]): string {
    return items.map(item => this.getReadContent(item.content)).join(', ');
  }

  public getFileDetails(content: any): any {
    if (!content) {
      return null;
    }
    
    if (typeof content === 'object') {
      if (content.files && Array.isArray(content.files) && content.files.length > 0) {
        return content.files[0];
      }
    }
    
    return null;
  }

  public getReasoning(content: any): string {
    if (typeof content === 'object' && content && content.reasoning) {
      return content.reasoning;
    }
    return '';
  }

  public hasFileDetails(content: any): boolean {
    const details = this.getFileDetails(content);
    return details !== null && details !== undefined;
  }
}
