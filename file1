export class ToolParserService {
  private processingQueue: ToolCommand[] = [];
  private isProcessing = false;
  private waitingForApproval = false;
  private currentWriteModifyTool: ToolCommand | null = null;

  public isWaitingForUserApproval = false;

  // Add these properties for cancellation
  private abortController: AbortController | null = null;
  private isCancelled = false;

  // ... existing callbacks ...

  // Add cancel method
  cancelStreaming(): void {
    console.log('Cancelling streaming...');
    this.isCancelled = true;
    
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
    
    this.cleanup();
  }

  // Modify startStreaming to use AbortController
  async startStreaming(apiUrl: string, options?: RequestInit): Promise<void> {
    try {
      // Reset cancellation flag
      this.isCancelled = false;
      
      // Create new AbortController
      this.abortController = new AbortController();
      
      // Merge abort signal with options
      const fetchOptions: RequestInit = {
        ...options,
        signal: this.abortController.signal
      };

      const response = await fetch(apiUrl, fetchOptions);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('No reader available');
      }

      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        // Check if cancelled
        if (this.isCancelled) {
          console.log('Streaming cancelled by user');
          reader.cancel();
          break;
        }

        const { done, value } = await reader.read();

        if (done) {
          if (buffer.trim() && !this.isCancelled) {
            this.addToolFromStream(buffer);
          }
          break;
        }

        const chunk = decoder.decode(value, { stream: true });
        buffer += chunk;

        const processedBuffer = this.processBuffer(buffer);
        buffer = processedBuffer.remaining;

        processedBuffer.completeObjects.forEach(obj => {
          if (!this.isCancelled) {
            this.addToolFromStream(obj);
          }
        });
      }
    } catch (error: any) {
      if (error.name === 'AbortError') {
        console.log('Streaming aborted');
      } else {
        console.error('Streaming error:', error);
        throw error;
      }
    } finally {
      this.abortController = null;
    }
  }

  // Modify cleanup to reset cancellation flag
  cleanup(): void {
    this.processingQueue = [];
    this.currentWriteModifyTool = null;
    this.isProcessing = false;
    this.waitingForApproval = false;
    this.isWaitingForUserApproval = false;
    this.onUpdateCallback = undefined;
    this.onLogCallback = undefined;
    this.abortController = null;
    this.isCancelled = false;
  }

  // ... rest of the existing code remains the same ...
}












 this.toolParser.cancelStreaming();

