approveAndContinue(): void {
  if (!this.waitingForApproval || !this.currentWriteModifyTool) return;

  // Execute the WRITE/MODIFY
  if (this.onLogCallback) {
    this.onLogCallback(this.currentWriteModifyTool);
  }

  this.currentWriteModifyTool = null;
  // DON'T reset waitingForApproval here - let processQueue handle it
  // this.waitingForApproval = false;  // REMOVE THIS LINE
  this.isWaitingForUserApproval = false;

  this.triggerUpdate();
  
  // Process only the next item, which might set waitingForApproval again
  this.processNextItem();

  // Check completion after processing
  if (!this.isStreamingActive && this.processingQueue.length === 0 && !this.waitingForApproval && this.onCompletionCallback) {
    this.onCompletionCallback();
  }
}

// Add new method to process one item at a time
private processNextItem(): void {
  // Reset waiting flag before processing next item
  this.waitingForApproval = false;
  
  if (this.processingQueue.length === 0) {
    return;
  }

  const tool = this.processingQueue.shift();
  
  if (!tool) return;

  this.processSingleTool(tool);
  
  // If the item didn't trigger waiting (i.e., it was a READ), continue processing
  if (!this.waitingForApproval && this.processingQueue.length > 0) {
    this.processNextItem();
  }
  
  // Check completion
  if (!this.isStreamingActive && this.processingQueue.length === 0 && !this.waitingForApproval && this.onCompletionCallback) {
    this.onCompletionCallback();
  }
}

// Keep processQueue for initial processing only
private processQueue(): void {
  if (this.waitingForApproval) return;

  this.isProcessing = true;

  while (this.processingQueue.length > 0 && !this.waitingForApproval) {
    const tool = this.processingQueue.shift();
    
    if (!tool) continue;

    this.processSingleTool(tool);
  }

  this.isProcessing = false;

  // Check completion
  if (!this.isStreamingActive && this.processingQueue.length === 0 && !this.waitingForApproval && this.onCompletionCallback) {
    this.onCompletionCallback();
  }
}
