// Add these properties
currentCommentIndex: number = -1;
visibleComments: { fileIndex: number; commentIndex: number; line: number }[] = [];

// Update ngOnInit to initialize visible comments
ngOnInit(): void {
  this.initializeCommentStates();
  this.updateSummaryStats();
  this.updateVisibleComments();
}

// Add method to update visible comments for current file
updateVisibleComments(): void {
  this.visibleComments = [];
  const file = this.responseData.files[this.selectedFileIndex];
  if (file) {
    file.ai_comments.forEach((comment, commentIndex) => {
      this.visibleComments.push({
        fileIndex: this.selectedFileIndex,
        commentIndex: commentIndex,
        line: comment.line
      });
    });
    // Sort by line number
    this.visibleComments.sort((a, b) => a.line - b.line);
  }
}

// Update selectFile to refresh visible comments
selectFile(index: number): void {
  this.selectedFileIndex = index;
  this.currentCommentIndex = -1;
  this.updateVisibleComments();
  
  // Re-render the selected file
  setTimeout(() => {
    this.renderDiff(this.responseData.files[index], index);
    setTimeout(() => {
      this.highlightCommentedLines(this.responseData.files[index], index);
      this.insertCommentsAtLines(this.responseData.files[index], index);
    }, 200);
  }, 50);
}

// Navigate to specific comment
goToComment(fileIndex: number, commentIndex: number): void {
  const commentId = this.getCommentId(fileIndex, commentIndex);
  const commentElement = document.getElementById(commentId);
  
  if (commentElement) {
    // Find the index in visible comments
    this.currentCommentIndex = this.visibleComments.findIndex(
      c => c.fileIndex === fileIndex && c.commentIndex === commentIndex
    );
    
    // Scroll to comment with smooth behavior
    commentElement.scrollIntoView({ 
      behavior: 'smooth', 
      block: 'center',
      inline: 'nearest'
    });
    
    // Add highlight effect
    commentElement.classList.add('comment-highlight');
    setTimeout(() => {
      commentElement.classList.remove('comment-highlight');
    }, 2000);
  }
}

// Navigate to first comment
goToFirstComment(): void {
  if (this.visibleComments.length > 0) {
    const first = this.visibleComments[0];
    this.goToComment(first.fileIndex, first.commentIndex);
  }
}

// Navigate to previous comment
goToPreviousComment(): void {
  if (this.currentCommentIndex > 0) {
    const prev = this.visibleComments[this.currentCommentIndex - 1];
    this.goToComment(prev.fileIndex, prev.commentIndex);
  }
}

// Navigate to next comment
goToNextComment(): void {
  if (this.currentCommentIndex < this.visibleComments.length - 1) {
    const next = this.visibleComments[this.currentCommentIndex + 1];
    this.goToComment(next.fileIndex, next.commentIndex);
  }
}

// Check if there's a previous comment
hasPreviousComment(): boolean {
  return this.currentCommentIndex > 0;
}

// Check if there's a next comment
hasNextComment(): boolean {
  return this.currentCommentIndex < this.visibleComments.length - 1;
}

// Get current comment position
getCurrentCommentPosition(): string {
  if (this.currentCommentIndex === -1 || this.visibleComments.length === 0) {
    return '';
  }
  return `${this.currentCommentIndex + 1} of ${this.visibleComments.length}`;
}













<!-- File Header -->
<div class="file-header">
    <span class="file-icon">ðŸ“„</span>
    <span>{{ responseData.files[selectedFileIndex].file_path }}</span>
    <button 
        class="ai-comment-count clickable" 
        *ngIf="responseData.files[selectedFileIndex].ai_comments.length > 0"
        (click)="goToFirstComment()"
        title="Jump to first comment">
        {{ responseData.files[selectedFileIndex].ai_comments.length }} AI 
        {{ responseData.files[selectedFileIndex].ai_comments.length === 1 ? 'comment' : 'comments' }}
    </button>
    <div class="file-stats">
        <span class="stat-additions">+{{ getFileStats(responseData.files[selectedFileIndex]).additions }}</span>
        <span class="stat-deletions">-{{ getFileStats(responseData.files[selectedFileIndex]).deletions }}</span>
    </div>
</div>













<!-- Comment Header -->
<div class="comment-header">
    <span class="ai-badge">AI Review</span>
    <span class="severity-badge" [ngClass]="'severity-' + comment.severity">
        {{ comment.severity }}
    </span>

    <span *ngIf="getCommentState(selectedFileIndex, commentIndex).status !== 'pending'"
        class="status-badge"
        [ngClass]="'status-' + getCommentState(selectedFileIndex, commentIndex).status">
        {{ getCommentState(selectedFileIndex, commentIndex).status }}
    </span>

    <span class="comment-time">Line {{ comment.line }}</span>
    
    <!-- Comment Navigation -->
    <div class="comment-navigation">
        <span class="comment-position" *ngIf="getCurrentCommentPosition()">
            {{ getCurrentCommentPosition() }}
        </span>
        <button 
            class="nav-btn nav-prev" 
            (click)="goToPreviousComment()"
            [disabled]="!hasPreviousComment()"
            title="Previous comment">
            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
        </button>
        <button 
            class="nav-btn nav-next" 
            (click)="goToNextComment()"
            [disabled]="!hasNextComment()"
            title="Next comment">
            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
        </button>
    </div>
</div>










/* Clickable AI Comment Count */
.ai-comment-count.clickable {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    background: linear-gradient(135deg, var(--bitbucket-file-comparator-purple-bg) 0%, var(--bitbucket-file-comparator-purple-text) 100%);
    color: white;
    padding: 6px 14px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
    margin-left: 12px;
    box-shadow: 0 2px 6px rgba(124, 58, 237, 0.3);
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    border: 2px solid transparent;
}

.ai-comment-count.clickable:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(124, 58, 237, 0.4);
    border-color: rgba(255, 255, 255, 0.3);
}

.ai-comment-count.clickable:active {
    transform: translateY(0);
}

/* Comment Navigation */
.comment-navigation {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    margin-left: auto;
}

.comment-position {
    font-size: 11px;
    color: var(--bitbucket-file-comparator-text-secondary);
    font-weight: 500;
    padding: 2px 8px;
    background: var(--bitbucket-file-comparator-bg-tertiary);
    border-radius: 4px;
}

.nav-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    padding: 0;
    background: var(--bitbucket-file-comparator-bg-tertiary);
    border: 1px solid var(--bitbucket-file-comparator-border-primary);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    color: var(--bitbucket-file-comparator-text-primary);
}

.nav-btn:hover:not(:disabled) {
    background: var(--bitbucket-file-comparator-accent-primary);
    border-color: var(--bitbucket-file-comparator-accent-primary);
    color: white;
    transform: translateY(-1px);
    box-shadow: 0 2px 6px rgba(0, 82, 204, 0.3);
}

.nav-btn:active:not(:disabled) {
    transform: translateY(0);
}

.nav-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

.nav-btn svg {
    display: block;
}

/* Comment Highlight Effect */
@keyframes commentHighlight {
    0%, 100% {
        background-color: transparent;
    }
    50% {
        background-color: rgba(0, 82, 204, 0.15);
    }
}

.ai-comment.comment-highlight {
    animation: commentHighlight 1s ease-in-out 2;
    border-color: var(--bitbucket-file-comparator-accent-primary) !important;
    box-shadow: 0 0 0 3px rgba(0, 82, 204, 0.2) !important;
}

/* Update comment header to accommodate navigation */
.comment-header {
    display: flex;
    align-items: center;
    margin-bottom: 12px;
    gap: 8px;
    flex-wrap: wrap;
}

.comment-time {
    color: var(--bitbucket-file-comparator-text-secondary);
    font-size: 12px;
}










bindCommentEvents(commentElement: HTMLElement, fileIndex: number, commentIndex: number): void {
  const commentId = this.getCommentId(fileIndex, commentIndex);
  
  // Find buttons within the cloned element
  const acceptBtn = commentElement.querySelector('.btn-accept');
  const rejectBtn = commentElement.querySelector('.btn-reject');
  const modifyBtn = commentElement.querySelector('.btn-modify');
  const saveBtn = commentElement.querySelector('.btn-save');
  const cancelBtn = commentElement.querySelector('.btn-cancel');
  const prevBtn = commentElement.querySelector('.nav-prev');
  const nextBtn = commentElement.querySelector('.nav-next');
  
  // Find textarea for two-way binding
  const textarea = commentElement.querySelector('.comment-body-editable') as HTMLTextAreaElement;
  if (textarea) {
    textarea.value = this.editingCommentText[commentId] || '';
    textarea.addEventListener('input', (e) => {
      const target = e.target as HTMLTextAreaElement;
      this.editingCommentText[commentId] = target.value;
    });
  }

  // Bind action events
  if (acceptBtn) {
    acceptBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!this.loadingComments[commentId]) {
        this.acceptComment(fileIndex, commentIndex);
      }
    });
  }

  if (rejectBtn) {
    rejectBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!this.loadingComments[commentId]) {
        this.rejectComment(fileIndex, commentIndex);
      }
    });
  }

  if (modifyBtn) {
    modifyBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!this.loadingComments[commentId]) {
        this.modifyComment(fileIndex, commentIndex);
      }
    });
  }

  if (saveBtn) {
    saveBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!this.loadingComments[commentId]) {
        this.saveModifiedComment(fileIndex, commentIndex);
      }
    });
  }

  if (cancelBtn) {
    cancelBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!this.loadingComments[commentId]) {
        this.cancelModification(fileIndex, commentIndex);
      }
    });
  }

  // Bind navigation events
  if (prevBtn) {
    prevBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.goToPreviousComment();
    });
  }

  if (nextBtn) {
    nextBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.goToNextComment();
    });
  }
}
