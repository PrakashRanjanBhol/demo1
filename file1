<!-- ONLY SHOWING THE MODIFIED PART - Result Item Content Section -->

<div class="result-item-content">
    <!-- KEYWORDS - Show as chips -->
    <div *ngIf="item.type === 'keywords'" class="keywords-chips-container">
        <div class="keyword-chip" 
             *ngFor="let keyword of getKeywordsArray(item); let i = index"
             [style.background]="getChipBackground(i)"
             [style.border-color]="getChipBorderColor(i)">
            <span class="chip-text">{{ keyword }}</span>
            <button class="chip-remove-btn" 
                    (click)="removeKeyword(item.id, keyword)"
                    title="Remove keyword">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2"
                    stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
        
        <p class="no-keywords-message" *ngIf="getKeywordsArray(item).length === 0">
            No keywords available
        </p>
    </div>

    <!-- SUMMARY & QUESTIONS - Show with markdown rendering AND ellipsis -->
    <div *ngIf="item.type !== 'keywords'">
        <!-- MODIFIED - Render as markdown HTML instead of plain text -->
        <div class="result-text-markdown" 
             [class.text-ellipsis]="shouldShowEllipsis(item) && !isExpanded(item.id)"
             [class.text-expanded]="isExpanded(item.id)"
             [innerHTML]="getMarkdownContent(item)">
        </div>
        
        <button class="read-more-btn" 
                *ngIf="shouldShowEllipsis(item) && isContentLong(item.content)"
                (click)="toggleExpand(item.id)">
            {{ isExpanded(item.id) ? 'Read less' : 'Read more' }}
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" 
                 stroke="currentColor"
                 [class.rotate-180]="isExpanded(item.id)">
                <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
            </svg>
        </button>
    </div>
</div>












// ONLY SHOWING THE MODIFIED/NEW PARTS

import { Component, Input } from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import { marked } from 'marked';

// ... interfaces remain same ...

@Component({
  selector: 'app-workspace',
  templateUrl: './workspace.component.html',
  styleUrls: ['./workspace.component.css']
})
export class WorkspaceComponent {
  @Input() selectedHistoryItem: HistoryItem | null = null;
  @Input() resultItems: ResultItem[] = [];
  @Input() isLoadingResults: boolean = false;

  isDetailOpen = false;
  selectedItemName = '';
  selectedItemDate = '';
  selectedItemContent: SafeHtml = '';
  selectedResultItemId: string = '';

  isDetailKeywords: boolean = false;
  detailKeywords: string[] = [];
  detailItemId: string = '';

  expandedItems: Set<string> = new Set();
  private readonly CHAR_LIMIT = 200;

  // NEW - Cache for markdown converted content
  private markdownCache: Map<string, SafeHtml> = new Map();

  constructor(private sanitizer: DomSanitizer) { }

  // NEW METHOD - Convert markdown content for preview
  getMarkdownContent(item: ResultItem): SafeHtml {
    // Check cache first
    if (this.markdownCache.has(item.id)) {
      return this.markdownCache.get(item.id)!;
    }

    // Convert markdown to HTML
    const htmlContent: any = marked(item.content);
    const safeHtml = this.sanitizer.bypassSecurityTrustHtml(htmlContent);
    
    // Cache the result
    this.markdownCache.set(item.id, safeHtml);
    
    return safeHtml;
  }

  // MODIFIED - Clear cache when needed
  removeKeyword(itemId: string, keyword: string): void {
    const item = this.resultItems.find(i => i.id === itemId);
    if (!item) return;

    if (item.keywords && Array.isArray(item.keywords)) {
      item.keywords = item.keywords.filter(k => k !== keyword);
      item.content = item.keywords.map(k => `• ${k}`).join(' ');
    } else {
      const keywords = this.getKeywordsArray(item);
      const updatedKeywords = keywords.filter(k => k !== keyword);
      item.content = updatedKeywords.map(k => `• ${k}`).join(' ');
      item.keywords = updatedKeywords;
    }
    
    // NEW - Clear cache when content changes
    this.markdownCache.delete(itemId);
  }

  // ... rest of existing methods remain the same ...
}












/* ADD THESE STYLES TO workspace.component.css */

/* Markdown Content Container in Result Items */
.result-text-markdown {
    font-size: 13px;
    line-height: 1.6;
    color: var(--text-color);
    transition: max-height 0.3s ease;
}

/* Collapsed state with ellipsis for markdown */
.result-text-markdown.text-ellipsis {
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
    position: relative;
}

/* Expanded state - show full markdown content */
.result-text-markdown.text-ellipsis.text-expanded {
    display: block;
    -webkit-line-clamp: unset;
    overflow: visible;
}

/* Markdown elements styling in preview */
.result-text-markdown h1,
.result-text-markdown h2,
.result-text-markdown h3 {
    font-size: 14px;
    font-weight: 700;
    margin: 8px 0 4px 0;
    color: var(--text-color);
}

.result-text-markdown p {
    margin: 6px 0;
    line-height: 1.6;
}

.result-text-markdown strong {
    font-weight: 700;
    color: var(--primary-color);
}

.result-text-markdown em {
    font-style: italic;
}

.result-text-markdown hr {
    border: none;
    border-top: 1px solid var(--border-color);
    margin: 12px 0;
}

.result-text-markdown ul,
.result-text-markdown ol {
    margin: 8px 0;
    padding-left: 20px;
}

.result-text-markdown li {
    margin: 4px 0;
}

.result-text-markdown blockquote {
    border-left: 3px solid var(--primary-color);
    padding-left: 12px;
    margin: 8px 0;
    font-style: italic;
    opacity: 0.9;
}

.result-text-markdown code {
    background-color: rgba(139, 92, 246, 0.1);
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.9em;
    font-family: 'Courier New', monospace;
    color: var(--primary-color);
}

.result-text-markdown pre {
    background-color: rgba(139, 92, 246, 0.05);
    padding: 10px;
    border-radius: 6px;
    overflow-x: auto;
    margin: 10px 0;
}

.result-text-markdown pre code {
    background-color: transparent;
    padding: 0;
}

/* Fade effect for truncated markdown content */
.result-text-markdown.text-ellipsis:not(.text-expanded)::after {
    content: '';
    position: absolute;
    bottom: 0;
    right: 0;
    width: 100%;
    height: 1.5em;
    background: linear-gradient(to bottom, transparent, var(--bg-color));
    pointer-events: none;
}

/* Ensure relative positioning for fade effect */
.result-item-content {
    position: relative;
}

/* Animation for markdown expand */
@keyframes expandMarkdown {
    from {
        max-height: 80px;
    }
    to {
        max-height: 2000px;
    }
}

.result-text-markdown.text-expanded {
    animation: expandMarkdown 0.3s ease-out forwards;
}
