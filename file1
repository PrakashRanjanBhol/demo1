updatePreview() {
  if (!this.artifactVersion) return;

  if (this.artifactVersion.type === 'html') {
    // Render HTML in iframe
    this.renderHtmlInIframe();
  } else if (this.artifactVersion.type === 'image') {
    // Render base64 image as img tag
    this.renderImage();
  } else {
    // Handle null or unknown type
    this.clearPreview();
  }
}

private renderHtmlInIframe() {
  if (!this.previewFrame?.nativeElement) return;
  
  const iframe = this.previewFrame.nativeElement;
  
  // Show iframe, hide image container
  iframe.style.display = 'block';
  const imgContainer = document.getElementById('image-preview-container');
  if (imgContainer) {
    imgContainer.style.display = 'none';
  }
  
  // Show loader
  this.showLoader(iframe);

  const doc = iframe.contentDocument || iframe.contentWindow?.document;
  if (doc) {
    doc.open();
    doc.write(this.wrapHtmlWithLoadingDetection(this.artifactVersion!.content));
    doc.close();

    // Listen for messages from iframe
    this.setupIframeMessageListener(iframe);
  }
}

private renderImage() {
  if (!this.previewFrame?.nativeElement) return;
  
  const iframe = this.previewFrame.nativeElement;
  
  // Hide iframe
  iframe.style.display = 'none';
  
  // Get or create image container
  let imgContainer = document.getElementById('image-preview-container');
  if (!imgContainer) {
    imgContainer = document.createElement('div');
    imgContainer.id = 'image-preview-container';
    imgContainer.className = 'image-preview-container';
    iframe.parentElement?.appendChild(imgContainer);
  }
  
  // Show container
  imgContainer.style.display = 'flex';
  
  // Show loader
  imgContainer.innerHTML = `
    <div class="loading-overlay">
      <div class="spinner"></div>
      <p style="margin-top: 20px; color: #666;">Loading image...</p>
    </div>
  `;
  
  try {
    // Convert URL-safe base64 to standard base64
    const base64Content = this.convertUrlSafeBase64ToStandard(this.artifactVersion!.content);
    
    // Detect image format and create data URL
    const dataUrl = this.createDataUrl(base64Content);
    
    // Create image element
    const img = document.createElement('img');
    img.className = 'preview-image';
    img.alt = 'Artifact Image';
    
    // Handle image load
    img.onload = () => {
      // Remove loader
      const loader = imgContainer!.querySelector('.loading-overlay');
      if (loader) {
        loader.remove();
      }
      console.log('Image loaded successfully');
    };
    
    // Handle image error
    img.onerror = () => {
      imgContainer!.innerHTML = `
        <div class="error-message">
          <h3>⚠️ Image Loading Failed</h3>
          <p>Failed to load the image.</p>
          <p style="font-size: 12px; color: #999;">The image data may be corrupted or in an invalid format.</p>
        </div>
      `;
      console.error('Image failed to load');
    };
    
    // Set timeout for loading
    const timeout = setTimeout(() => {
      if (imgContainer!.querySelector('.loading-overlay')) {
        imgContainer!.innerHTML = `
          <div class="error-message">
            <h3>⚠️ Image Loading Timeout</h3>
            <p>Image took too long to load.</p>
            <p style="font-size: 12px; color: #999;">The image may be too large or corrupted.</p>
          </div>
        `;
      }
    }, 10000);
    
    // Clear timeout on successful load
    img.addEventListener('load', () => clearTimeout(timeout));
    
    // Set image source
    img.src = dataUrl;
    
    // Append image to container
    imgContainer.appendChild(img);
    
  } catch (error) {
    console.error('Error processing base64 image:', error);
    imgContainer.innerHTML = `
      <div class="error-message">
        <h3>⚠️ Image Processing Failed</h3>
        <p>Failed to process the base64 image data.</p>
        <p style="font-size: 12px; color: #999;">The image data may be in an invalid format.</p>
      </div>
    `;
  }
}

private convertUrlSafeBase64ToStandard(urlSafeBase64: string): string {
  // Remove data URL prefix if present
  let base64 = urlSafeBase64;
  if (base64.startsWith('data:')) {
    return base64; // Already a complete data URL
  }
  
  // Convert URL-safe base64 to standard base64
  // Replace '-' with '+' and '_' with '/'
  base64 = base64.replace(/-/g, '+').replace(/_/g, '/');
  
  // Add padding if needed
  const padding = base64.length % 4;
  if (padding > 0) {
    base64 += '='.repeat(4 - padding);
  }
  
  return base64;
}

private createDataUrl(base64Content: string): string {
  // If already a data URL, return as is
  if (base64Content.startsWith('data:')) {
    return base64Content;
  }
  
  // Detect image format from base64 content
  const imageType = this.detectImageType(base64Content);
  
  // Create data URL
  return `data:${imageType};base64,${base64Content}`;
}

private detectImageType(base64: string): string {
  // Decode first few bytes to detect image signature
  try {
    const binaryString = atob(base64.substring(0, 20));
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    
    // Check magic numbers for different image formats
    if (bytes[0] === 0xFF && bytes[1] === 0xD8 && bytes[2] === 0xFF) {
      return 'image/jpeg';
    } else if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47) {
      return 'image/png';
    } else if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46) {
      return 'image/gif';
    } else if (bytes[0] === 0x52 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x46) {
      return 'image/webp';
    } else if (bytes[0] === 0x42 && bytes[1] === 0x4D) {
      return 'image/bmp';
    } else if (bytes[0] === 0x3C && bytes[1] === 0x73 && bytes[2] === 0x76 && bytes[3] === 0x67) {
      return 'image/svg+xml';
    }
  } catch (e) {
    console.warn('Could not detect image type, defaulting to png', e);
  }
  
  // Default to PNG if detection fails
  return 'image/png';
}

private clearPreview() {
  if (this.previewFrame?.nativeElement) {
    const iframe = this.previewFrame.nativeElement;
    iframe.style.display = 'none';
  }
  
  const imgContainer = document.getElementById('image-preview-container');
  if (imgContainer) {
    imgContainer.style.display = 'flex';
    imgContainer.innerHTML = '<p style="text-align: center; color: #999;">No content available</p>';
  }
}

private wrapHtmlWithLoadingDetection(html: string): string {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        .loading-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(255, 255, 255, 0.9);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 9999;
          flex-direction: column;
        }
        .spinner {
          border: 4px solid #f3f3f3;
          border-top: 4px solid #3498db;
          border-radius: 50%;
          width: 40px;
          height: 40px;
          animation: spin 1s linear infinite;
        }
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        .error-message {
          color: #d32f2f;
          font-family: Arial, sans-serif;
          text-align: center;
          padding: 20px;
        }
      </style>
    </head>
    <body>
      <div id="loading-overlay" class="loading-overlay">
        <div class="spinner"></div>
        <p style="margin-top: 20px; color: #666;">Loading dependencies...</p>
      </div>
      
      ${html}
      
      <script>
        (function() {
          let scriptsToLoad = [];
          let linksToLoad = [];
          let loadedCount = 0;
          let totalResources = 0;
          let hasError = false;

          function findExternalResources() {
            const scripts = document.querySelectorAll('script[src]');
            const links = document.querySelectorAll('link[rel="stylesheet"][href]');
            
            scripts.forEach(script => {
              const src = script.getAttribute('src');
              if (src && (src.startsWith('http://') || src.startsWith('https://') || src.startsWith('//'))) {
                scriptsToLoad.push(script);
              }
            });
            
            links.forEach(link => {
              const href = link.getAttribute('href');
              if (href && (href.startsWith('http://') || href.startsWith('https://') || href.startsWith('//'))) {
                linksToLoad.push(link);
              }
            });
            
            totalResources = scriptsToLoad.length + linksToLoad.length;
          }

          function hideLoader() {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) {
              overlay.style.display = 'none';
            }
          }

          function showError() {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) {
              overlay.innerHTML = \`
                <div class="error-message">
                  <h3>⚠️ Dependency Loading Failed</h3>
                  <p>Failed to load one or more external resources.</p>
                  <p style="font-size: 12px; color: #999;">Please check your internet connection or CDN availability.</p>
                </div>
              \`;
            }
            window.parent.postMessage({ type: 'cdn-load-error' }, '*');
          }

          function checkComplete() {
            loadedCount++;
            if (loadedCount >= totalResources) {
              if (hasError) {
                showError();
              } else {
                hideLoader();
                window.parent.postMessage({ type: 'cdn-load-complete' }, '*');
              }
            }
          }

          function attachLoadListeners() {
            scriptsToLoad.forEach(script => {
              script.addEventListener('load', checkComplete);
              script.addEventListener('error', function() {
                hasError = true;
                checkComplete();
              });
            });

            linksToLoad.forEach(link => {
              link.addEventListener('load', checkComplete);
              link.addEventListener('error', function() {
                hasError = true;
                checkComplete();
              });
            });
          }

          findExternalResources();
          
          if (totalResources === 0) {
            hideLoader();
            window.parent.postMessage({ type: 'cdn-load-complete' }, '*');
          } else {
            attachLoadListeners();
            
            setTimeout(function() {
              if (loadedCount < totalResources) {
                hasError = true;
                showError();
              }
            }, 10000);
          }
        })();
      </script>
    </body>
    </html>
  `;
}

private setupIframeMessageListener(iframe: HTMLIFrameElement) {
  const messageHandler = (event: MessageEvent) => {
    if (event.source !== iframe.contentWindow) return;

    switch(event.data.type) {
      case 'cdn-load-complete':
        console.log('All CDN resources loaded successfully');
        break;
      case 'cdn-load-error':
        console.error('CDN resources failed to load');
        break;
    }
  };

  window.addEventListener('message', messageHandler);
}

private showLoader(iframe: HTMLIFrameElement) {
  const doc = iframe.contentDocument || iframe.contentWindow?.document;
  if (doc) {
    doc.open();
    doc.write(`
      <html>
      <head>
        <style>
          body {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background: #f5f5f5;
          }
          .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
          }
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        </style>
      </head>
      <body>
        <div class="spinner"></div>
      </body>
      </html>
    `);
    doc.close();
  }
}
