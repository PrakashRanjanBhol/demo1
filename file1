// MODIFIED rejectChanges - Remove executedItems.push to prevent re-render
public rejectChanges(): void {
  if (this.currentApprovalRequest) {
    console.log('❌ REJECTED:', this.currentApprovalRequest.data);
    console.log('Continuing with next operation...\n');
    
    // Just mark as rejected, don't push to executedItems
    this.currentApprovalRequest.data.rejected = true;
    
    // MODIFIED: State changes immediately
    this.showApprovalCard = false;
    this.isWaitingForApproval = false;
    const rejectedData = this.currentApprovalRequest;
    this.currentApprovalRequest = null;
    this.showStreamingContainer = true;
    this.cdr.detectChanges();
    
    // MODIFIED: Use requestAnimationFrame for better performance
    requestAnimationFrame(() => {
      this.parserService.approveAndContinue();
      // Only update queued items, not executed
      this.queuedItems = this.parserService.getPendingTools();
      this.scrollToBottom();
    });
  }
}

// MODIFIED approveAndContinue - Also optimize
public async approveAndContinue(): Promise<void> {
  if (this.currentApprovalRequest && !this.isApprovingChanges) {
    console.log('✅ APPROVED:', this.currentApprovalRequest.data);
    console.log('Saving code changes via API...\n');
    
    this.isApprovingChanges = true;
    this.cdr.detectChanges();
    
    try {
      const fileDetails = this.getFileDetails(this.currentApprovalRequest.data.content);
      
      if (fileDetails) {
        const payload = {
          tool: this.currentApprovalRequest.data.tool,
          file_path: fileDetails.file_path,
          file_name: fileDetails.file_name,
          original_code: fileDetails.original_code || '',
          modified_code: fileDetails.modified_code || '',
          reasoning: this.getReasoning(this.currentApprovalRequest.data.content),
          timestamp: new Date().toISOString()
        };
        
        await this.saveCodeChanges(payload);
        console.log('✅ Code changes saved successfully');
      }
      
      // State changes immediately
      this.showApprovalCard = false;
      this.isWaitingForApproval = false;
      this.currentApprovalRequest = null;
      this.showStreamingContainer = true;
      this.cdr.detectChanges();
      
      // MODIFIED: Use requestAnimationFrame for better performance
      requestAnimationFrame(() => {
        this.parserService.approveAndContinue();
        // Only update queued items, not executed
        this.queuedItems = this.parserService.getPendingTools();
        this.scrollToBottom();
      });
      
    } catch (error) {
      console.error('❌ Failed to save code changes:', error);
      alert('Failed to save code changes. Please try again.');
      this.isApprovingChanges = false;
      this.cdr.detectChanges();
      return;
    }
    
    setTimeout(() => {
      this.isApprovingChanges = false;
      this.cdr.detectChanges();
    }, 300);
  }
}

// MODIFIED updateLists - Only update queued, not executed (since we don't render them)
private updateLists(): void {
  // Only update queued items to avoid heavy re-renders
  this.queuedItems = this.parserService.getPendingTools();
  
  // Only get executed items for the finished state file list
  if (this.isCompleted) {
    this.executedItems = this.parserService.getCompletedTools();
  }
}
