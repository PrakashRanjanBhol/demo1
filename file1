processBuffer(isFinal = false) {
    // Try to extract complete code blocks from buffer
    const completeCodeBlockRegex = /```(\w+)?\s*\n([\s\S]*?)\n```/g;
    // Detect incomplete/ongoing code blocks
    const incompleteCodeBlockRegex = /```(\w+)?\s*\n([\s\S]*)$/;
    
    let lastProcessedIndex = 0;
    let match;
    let hasIncompleteBlock = false;
    let incompleteBlockStart = -1;
    
    // Clear content except cursor
    const cursor = this.contentElement.querySelector('.streaming-cursor');
    this.contentElement.innerHTML = '';
    
    // Process complete code blocks
    while ((match = completeCodeBlockRegex.exec(this.buffer)) !== null) {
        const matchStart = match.index;
        const matchEnd = completeCodeBlockRegex.lastIndex;
        
        // Render markdown before this code block
        const beforeMarkdown = this.buffer.slice(lastProcessedIndex, matchStart);
        if (beforeMarkdown.trim().length > 0) {
            const markdownElement = this.renderMarkdown(beforeMarkdown);
            // Append the wrapper div with regular-text class
            this.contentElement.appendChild(markdownElement);
        }
        
        // Render the complete code block with highlighting
        const language = match[1] || 'plaintext';
        const codeContent = match[2];
        const codeBlock = this.createCodeBlock(language, codeContent);
        this.contentElement.appendChild(codeBlock);
        
        lastProcessedIndex = matchEnd;
    }
    
    // Check for incomplete code block in the remaining buffer
    const remaining = this.buffer.slice(lastProcessedIndex);
    const incompleteMatch = incompleteCodeBlockRegex.exec(remaining);
    
    if (incompleteMatch && !isFinal) {
        // We have an incomplete code block that's still streaming
        hasIncompleteBlock = true;
        incompleteBlockStart = lastProcessedIndex + incompleteMatch.index;
        
        // Render markdown before the incomplete code block
        const beforeIncomplete = this.buffer.slice(lastProcessedIndex, incompleteBlockStart);
        if (beforeIncomplete.trim().length > 0) {
            const markdownElement = this.renderMarkdown(beforeIncomplete);
            // Append the wrapper div with regular-text class
            this.contentElement.appendChild(markdownElement);
        }
        
        // Render the incomplete code block with live highlighting
        const language = incompleteMatch[1] || 'plaintext';
        const codeContent = incompleteMatch[2];
        const incompleteCodeBlock = this.createLiveCodeBlock(language, codeContent);
        this.contentElement.appendChild(incompleteCodeBlock);
        
    } else {
        // No incomplete code block, just render remaining markdown
        if (remaining.trim().length > 0 || isFinal) {
            const markdownElement = this.renderMarkdown(remaining);
            // Append the wrapper div with regular-text class
            this.contentElement.appendChild(markdownElement);
        }
    }
    
    // Re-add cursor if it existed
    if (cursor) {
        this.contentElement.appendChild(cursor);
    }
}
