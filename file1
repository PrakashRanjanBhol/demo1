import { Injectable } from '@angular/core';

export interface ToolCommand {
  tool: string;
  content: any;
}

export interface WriteModifyContent {
  reasoning: string;
  files: Array<{
    file_path: string;
    file_name: string;
    original_code: string;
    modified_code: string;
  }>;
}

export interface ProcessedTool {
  tool: ToolCommand;
  status: 'processing' | 'waiting_approval' | 'completed';
  timestamp: Date;
}

@Injectable({
  providedIn: 'root'
})
export class ToolParserService {
  private processingQueue: ToolCommand[] = [];
  private isProcessing = false;
  private waitingForApproval = false;
  private currentBatch: ToolCommand[] = [];

  public allProcessedTools: ProcessedTool[] = [];
  public isWaitingForUserApproval = false;
  public pendingBatch: ToolCommand[] = [];

  // Callback for UI updates
  private onUpdateCallback?: () => void;

  // Callback for READ operations with DOM updates
  private onReadCallback?: (content: string) => void;

  // Callback for WRITE/MODIFY operations
  private onWriteModifyCallback?: (tools: ToolCommand[]) => void;

  setUpdateCallback(callback: () => void): void {
    this.onUpdateCallback = callback;
  }

  setReadCallback(callback: (content: string) => void): void {
    this.onReadCallback = callback;
  }

  setWriteModifyCallback(callback: (tools: ToolCommand[]) => void): void {
    this.onWriteModifyCallback = callback;
  }

  private triggerUpdate(): void {
    if (this.onUpdateCallback) {
      this.onUpdateCallback();
    }
  }

  /**
   * Main method to handle streaming API call
   */
  async startStreaming(apiUrl: string, options?: RequestInit): Promise<void> {
    try {
      const response = await fetch(apiUrl, options);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('No reader available');
      }

      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();

        if (done) {
          console.log('Stream complete');
          if (buffer.trim()) {
            this.addToolFromStream(buffer);
          }
          break;
        }

        const chunk = decoder.decode(value, { stream: true });
        console.log('Received chunk:', chunk);

        buffer += chunk;

        const processedBuffer = this.processBuffer(buffer);
        buffer = processedBuffer.remaining;

        processedBuffer.completeObjects.forEach(obj => {
          this.addToolFromStream(obj);
        });
      }
    } catch (error) {
      console.error('Streaming error:', error);
      throw error;
    }
  }

  private processBuffer(buffer: string): { completeObjects: string[], remaining: string } {
    const completeObjects: string[] = [];
    let remaining = buffer;
    let depth = 0;
    let start = 0;
    let inString = false;
    let stringDelimiter = '';
    let escaped = false;

    for (let i = 0; i < buffer.length; i++) {
      const char = buffer[i];

      if (escaped) {
        escaped = false;
        continue;
      }

      if (char === '\\') {
        escaped = true;
        continue;
      }

      if (!inString && (char === '"' || char === "'")) {
        inString = true;
        stringDelimiter = char;
      } else if (inString && char === stringDelimiter) {
        inString = false;
        stringDelimiter = '';
      }

      if (!inString) {
        if (char === '{') {
          if (depth === 0) {
            start = i;
          }
          depth++;
        } else if (char === '}') {
          depth--;
          if (depth === 0) {
            completeObjects.push(buffer.substring(start, i + 1));
            start = i + 1;
          }
        }
      }
    }

    remaining = buffer.substring(start).trim();
    return { completeObjects, remaining };
  }

  addToolFromStream(input: string): void {
    const tools = this.parseToolString(input);
    
    if (tools.length === 0) return;

    this.processingQueue.push(...tools);
    
    if (!this.isProcessing && !this.waitingForApproval) {
      this.processQueue();
    }
  }

  approveAndContinue(): void {
    if (!this.waitingForApproval) return;

    this.executeBatch(this.currentBatch);
    this.currentBatch = [];
    this.waitingForApproval = false;
    this.isWaitingForUserApproval = false;
    this.pendingBatch = [];

    this.triggerUpdate();
    this.processQueue();
  }

  private processQueue(): void {
    if (this.waitingForApproval) return;

    this.isProcessing = true;

    while (this.processingQueue.length > 0 && !this.waitingForApproval) {
      const tool = this.processingQueue.shift();
      
      if (!tool) continue;

      this.processSingleTool(tool);
    }

    this.isProcessing = false;
  }

  private processSingleTool(tool: ToolCommand): void {
    try {
      if (!tool.tool) {
        console.warn('Invalid tool object:', tool);
        return;
      }

      switch (tool.tool) {
        case 'READ':
          this.handleRead(tool.content);
          this.addToProcessedTools(tool, 'completed');
          
          // Trigger READ callback for DOM updates
          if (this.onReadCallback) {
            this.onReadCallback(tool.content);
          }
          
          this.triggerUpdate();
          break;

        case 'WRITE':
        case 'MODIFY':
          this.currentBatch.push(tool);
          this.addToProcessedTools(tool, 'waiting_approval');
          this.collectBatch();
          
          this.waitingForApproval = true;
          this.isWaitingForUserApproval = true;
          this.pendingBatch = [...this.currentBatch];
          
          // Trigger WRITE/MODIFY callback for DOM updates
          if (this.onWriteModifyCallback) {
            this.onWriteModifyCallback(this.pendingBatch);
          }
          
          this.triggerUpdate();
          break;

        default:
          console.warn('Unknown tool type:', tool.tool);
      }
    } catch (error) {
      console.error('Error processing tool:', tool, error);
    }
  }

  private collectBatch(): void {
    while (this.processingQueue.length > 0) {
      const nextTool = this.processingQueue[0];
      
      if (nextTool.tool === 'WRITE' || nextTool.tool === 'MODIFY') {
        const tool = this.processingQueue.shift()!;
        this.currentBatch.push(tool);
        this.addToProcessedTools(tool, 'waiting_approval');
      } else {
        break;
      }
    }
  }

  private executeBatch(batch: ToolCommand[]): void {
    batch.forEach(tool => {
      if (tool.tool === 'WRITE') {
        this.handleWrite(tool.content);
      } else if (tool.tool === 'MODIFY') {
        this.handleModify(tool.content);
      }
      
      this.updateToolStatus(tool, 'completed');
    });
    
    this.triggerUpdate();
  }

  private addToProcessedTools(tool: ToolCommand, status: 'processing' | 'waiting_approval' | 'completed'): void {
    this.allProcessedTools.push({
      tool,
      status,
      timestamp: new Date()
    });
  }

  private updateToolStatus(tool: ToolCommand, status: 'processing' | 'waiting_approval' | 'completed'): void {
    const item = this.allProcessedTools.find(pt => pt.tool === tool);
    if (item) {
      item.status = status;
    }
  }

  private handleRead(content: string): void {
    console.log('READ (executing immediately):', content);
    // Your read logic here
  }

  private handleWrite(content: WriteModifyContent): void {
    console.log('WRITE (executing after approval):', content.reasoning);
    if (content.files) {
      content.files.forEach(file => {
        console.log(`  Writing file: ${file.file_name} at ${file.file_path}`);
        // Your actual write logic here
      });
    }
  }

  private handleModify(content: WriteModifyContent): void {
    console.log('MODIFY (executing after approval):', content.reasoning);
    if (content.files) {
      content.files.forEach(file => {
        console.log(`  Modifying file: ${file.file_name} at ${file.file_path}`);
        // Your actual modify logic here
      });
    }
  }

  getQueueLength(): number {
    return this.processingQueue.length;
  }

  reset(): void {
    this.processingQueue = [];
    this.currentBatch = [];
    this.allProcessedTools = [];
    this.isProcessing = false;
    this.waitingForApproval = false;
    this.isWaitingForUserApproval = false;
    this.pendingBatch = [];
    this.triggerUpdate();
  }

  parseToolString(input: string): ToolCommand[] {
    const results: ToolCommand[] = [];
    
    try {
      const str = input.trim();
      
      if (!str) {
        return [];
      }

      const objects = this.extractJsonObjects(str);
      
      for (const obj of objects) {
        try {
          const parsed = this.parseObject(obj);
          if (parsed && parsed.tool) {
            results.push(parsed);
          }
        } catch (err) {
          console.warn('Skipping invalid object:', obj, err);
        }
      }

      return results;

    } catch (error) {
      console.error('Parse error:', error);
      console.error('Input was:', input);
      return results;
    }
  }

  private extractJsonObjects(str: string): string[] {
    const objects: string[] = [];
    let depth = 0;
    let start = 0;
    let inString = false;
    let stringDelimiter = '';
    let escaped = false;

    for (let i = 0; i < str.length; i++) {
      const char = str[i];
      const prevChar = i > 0 ? str[i - 1] : '';

      if (escaped) {
        escaped = false;
        continue;
      }

      if (char === '\\') {
        escaped = true;
        continue;
      }

      if (!inString && (char === '"' || char === "'")) {
        inString = true;
        stringDelimiter = char;
      } else if (inString && char === stringDelimiter && prevChar !== '\\') {
        inString = false;
        stringDelimiter = '';
      }

      if (!inString) {
        if (char === '{') {
          if (depth === 0) {
            start = i;
          }
          depth++;
        } else if (char === '}') {
          depth--;
          if (depth === 0 && start < i) {
            objects.push(str.substring(start, i + 1));
          }
        }
      }
    }

    return objects;
  }

  private parseObject(obj: string): ToolCommand | null {
    try {
      let jsonStr = obj.trim();
      jsonStr = this.quotePropertyNames(jsonStr);
      jsonStr = this.normalizeQuotes(jsonStr);
      const parsed = JSON.parse(jsonStr);

      if (typeof parsed !== 'object' || !parsed.tool) {
        console.warn('Invalid tool command structure:', parsed);
        return null;
      }

      return parsed as ToolCommand;

    } catch (error) {
      console.error('Parse object error:', error);
      throw error;
    }
  }

  private quotePropertyNames(str: string): string {
    return str.replace(/([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)(\s*):/g, '$1"$2"$3:');
  }

  private normalizeQuotes(str: string): string {
    let result = '';
    let inString = false;
    let currentQuote = '';
    let escaped = false;

    for (let i = 0; i < str.length; i++) {
      const char = str[i];

      if (escaped) {
        result += char;
        escaped = false;
        continue;
      }

      if (char === '\\' && inString) {
        result += char;
        escaped = true;
        continue;
      }

      if ((char === '"' || char === "'") && !inString) {
        inString = true;
        currentQuote = char;
        result += '"';
      } else if (char === currentQuote && inString) {
        inString = false;
        currentQuote = '';
        result += '"';
      } else {
        if (char === '"' && inString && currentQuote === "'") {
          result += '\\"';
        } else {
          result += char;
        }
      }
    }

    return result;
  }
}























import { Component, ChangeDetectorRef } from '@angular/core';
import { ToolParserService, ToolCommand } from './services/tool-parser.service';

@Component({
  selector: 'app-tool-processor',
  templateUrl: './tool-processor.component.html',
  styleUrls: ['./tool-processor.component.css']
})
export class ToolProcessorComponent {
  isLoading = false;
  errorMessage = '';

  constructor(
    public toolParser: ToolParserService,
    private cdr: ChangeDetectorRef
  ) {}

  onApprove(): void {
    this.toolParser.approveAndContinue();
  }

  onReset(): void {
    this.toolParser.reset();
    this.errorMessage = '';
    
    // Clear DOM elements
    const readContainer = document.getElementById('read-content-container');
    const writeContainer = document.getElementById('write-modify-container');
    
    if (readContainer) {
      readContainer.innerHTML = '';
    }
    if (writeContainer) {
      writeContainer.innerHTML = '';
    }
  }

  async handleStreamingResponse(): Promise<void> {
    // Setup callbacks
    this.toolParser.setUpdateCallback(() => {
      this.cdr.detectChanges();
    });

    // Setup READ callback for DOM updates
    this.toolParser.setReadCallback((content: string) => {
      this.updateReadDOM(content);
    });

    // Setup WRITE/MODIFY callback for DOM updates
    this.toolParser.setWriteModifyCallback((tools: ToolCommand[]) => {
      this.updateWriteModifyDOM(tools);
    });

    this.isLoading = true;
    this.errorMessage = '';

    try {
      const apiUrl = 'https://your-api.com/stream';
      
      const options: RequestInit = {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer your-token-here'
        },
        body: JSON.stringify({
          query: 'your query here'
        })
      };

      await this.toolParser.startStreaming(apiUrl, options);
      
      console.log('Streaming completed successfully');
    } catch (error: any) {
      console.error('Error in streaming:', error);
      this.errorMessage = error.message || 'An error occurred during streaming';
    } finally {
      this.isLoading = false;
      this.cdr.detectChanges();
    }
  }

  // Update DOM for READ operations
  private updateReadDOM(content: string): void {
    const container = document.getElementById('read-content-container');
    if (!container) return;

    const readElement = document.createElement('div');
    readElement.className = 'read-item';
    readElement.innerHTML = `
      <div class="read-header">
        <span class="read-icon">ðŸ“–</span>
        <span class="read-time">${new Date().toLocaleTimeString()}</span>
      </div>
      <div class="read-content">${this.escapeHtml(content)}</div>
    `;

    container.appendChild(readElement);
    
    // Auto-scroll to bottom
    container.scrollTop = container.scrollHeight;
  }

  // Update DOM for WRITE/MODIFY operations
  private updateWriteModifyDOM(tools: ToolCommand[]): void {
    const container = document.getElementById('write-modify-container');
    if (!container) return;

    // Clear previous content
    container.innerHTML = '';

    tools.forEach((tool, index) => {
      const toolElement = document.createElement('div');
      toolElement.className = 'write-modify-item';
      
      let filesHTML = '';
      if (tool.content.files && Array.isArray(tool.content.files)) {
        filesHTML = tool.content.files.map((file: any) => `
          <div class="file-detail">
            <p><strong>File:</strong> ${this.escapeHtml(file.file_name)}</p>
            <p><strong>Path:</strong> ${this.escapeHtml(file.file_path)}</p>
            ${tool.tool === 'MODIFY' ? `
              <div class="code-block">
                <strong>Original:</strong>
                <pre>${this.escapeHtml(file.original_code)}</pre>
              </div>
            ` : ''}
            <div class="code-block">
              <strong>${tool.tool === 'WRITE' ? 'Content' : 'Modified'}:</strong>
              <pre>${this.escapeHtml(file.modified_code)}</pre>
            </div>
          </div>
        `).join('');
      }

      toolElement.innerHTML = `
        <div class="tool-header">
          <span class="tool-badge ${tool.tool.toLowerCase()}">${tool.tool}</span>
          <span class="tool-number">#${index + 1}</span>
        </div>
        <div class="tool-reasoning">
          <strong>Reasoning:</strong> ${this.escapeHtml(tool.content.reasoning)}
        </div>
        ${filesHTML}
      `;

      container.appendChild(toolElement);
    });
  }

  // Escape HTML to prevent XSS
  private escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Simulate streaming for testing
  simulateStreaming(): void {
    this.toolParser.setUpdateCallback(() => {
      this.cdr.detectChanges();
    });

    this.toolParser.setReadCallback((content: string) => {
      this.updateReadDOM(content);
    });

    this.toolParser.setWriteModifyCallback((tools: ToolCommand[]) => {
      this.updateWriteModifyDOM(tools);
    });

    const data = [
      '{tool: "READ", content: "First read - showing immediately"}',
      '{tool: "READ", content: "Second read - showing immediately"}',
      '{tool: "WRITE", content: {reasoning: "Writing new file", files: [{file_path: "/src", file_name:"app.js", original_code:"", modified_code:"console.log(\'hello\');"}]}}',
      '{tool: "MODIFY", content: {reasoning: "Modifying existing file", files: [{file_path: "/src", file_name:"app.js", original_code:"old code", modified_code:"new code"}]}}',
      '{tool: "READ", content: "Third read - will show after approval"}',
      '{tool: "WRITE", content: {reasoning: "Another write operation", files: [{file_path: "/test", file_name:"test.js", original_code:"", modified_code:"test code"}]}}',
      '{tool: "READ", content: "Final read - will show after second approval"}'
    ];

    let index = 0;
    const interval = setInterval(() => {
      if (index < data.length) {
        console.log('Streaming chunk:', data[index]);
        this.toolParser.addToolFromStream(data[index]);
        index++;
      } else {
        clearInterval(interval);
        console.log('Streaming complete');
      }
    }, 1000);
  }
}
