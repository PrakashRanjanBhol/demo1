/* Add this new class for search highlighting */
.tree-node.search-highlight {
  background: var(--sdlc-tree-highlight-bg) !important;
  border-color: var(--sdlc-tree-highlight-border) !important;
  animation: highlightPulse 1.5s ease-in-out infinite;
}

/* Make sure highlight animation works */
@keyframes highlightPulse {
  0%,
  100% {
    border-color: var(--sdlc-tree-highlight-border);
  }
  50% {
    border-color: #8b9cff;
  }
}











export class JiraHierarchyComponent implements OnInit {
  searchQuery: string = '';
  searchResults: string = '';
  hierarchyData: TreeNode[] = [];
  legendItems: Array<{ color: string; label: string }> = [];
  isDarkMode: boolean = true;
  isLoading: boolean = false;
  highlightedNodes: Set<string> = new Set(); // Add this property

  // ... existing code ...

  onSearch(): void {
    // Clear previous highlights
    this.highlightedNodes.clear();

    if (!this.searchQuery.trim()) {
      this.searchResults = '';
      return;
    }

    const lowerQuery = this.searchQuery.toLowerCase();
    const matches = this.searchInData(this.hierarchyData, lowerQuery);

    if (matches.length > 0) {
      this.searchResults = `Found ${matches.length} match${matches.length > 1 ? 'es' : ''}`;
      
      // Add matched nodes to highlighted set
      matches.forEach(node => {
        this.highlightedNodes.add(node.id);
      });
    } else {
      this.searchResults = 'No matches found';
    }
  }

  // Update this method
  private searchInData(data: TreeNode[], query: string): TreeNode[] {
    const matches: TreeNode[] = [];

    const search = (nodes: TreeNode[]) => {
      nodes.forEach(node => {
        if (
          node.id.toLowerCase().includes(query) ||
          node.title.toLowerCase().includes(query) ||
          (node.jira_ticket && node.jira_ticket.toLowerCase().includes(query))
        ) {
          matches.push(node);
          this.expandParents(node, this.hierarchyData);
        }
        if (node.children) {
          search(node.children);
        }
      });
    };

    search(data);
    return matches;
  }

  // Add this method to check if node is highlighted
  isHighlighted(node: TreeNode): boolean {
    return this.highlightedNodes.has(node.id);
  }

  // ... rest of the existing code ...
}











<!-- Update the tree-node div in the template -->
<ng-template #treeNode let-node>
  <li class="tree-item">
    <div
      class="tree-node"
      [class]="node.type + (isDraft(node) ? ' draft' : '') + (isHighlighted(node) ? ' search-highlight' : '')"
      (click)="hasChildren(node) ? toggleNode(node) : null"
    >
      <!-- Rest of the node content remains the same -->
      <span
        class="toggle-icon"
        [class.expanded]="node.expanded"
        [class.empty]="!hasChildren(node)"
      >
        {{ hasChildren(node) ? '‚ñ∂' : '‚óè' }}
      </span>

      <span class="ticket-badge" [class]="node.type">
        {{ getTypeBadge(node.type) }}
      </span>

      <div class="ticket-info">
        <span class="ticket-id" [class.draft-text]="isDraft(node)">
          <span class="jira-ticket-id" *ngIf="node.jira_ticket">
            {{ node.jira_ticket }}
          </span>
          <ng-container *ngIf="!node.jira_ticket">
            Untitled
            <span class="draft-badge">DRAFT</span>
          </ng-container>
        </span>
        <span class="ticket-title">{{ node.title }}</span>
      </div>

      <span class="count-badge" *ngIf="hasChildren(node)">
        {{ countChildren(node) }}
      </span>

      <span class="view-icon" (click)="handleViewClick($event, node)" title="View Details">
        üëÅ
      </span>
    </div>

    <ul class="children" *ngIf="hasChildren(node) && node.expanded" [class.expanded]="node.expanded">
      <ng-container *ngFor="let child of node.children">
        <ng-container *ngTemplateOutlet="treeNode; context: { $implicit: child }"></ng-container>
      </ng-container>
    </ul>
  </li>
</ng-template>

