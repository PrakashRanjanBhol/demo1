insertCommentsAtLines(file: FileData, fileIndex: number): void {
  file.ai_comments.forEach((comment, commentIndex) => {
    const commentId = this.getCommentId(fileIndex, commentIndex);
    let commentElement = document.getElementById(`comment-${commentId}`);

    if (!commentElement) {
      console.warn(`Comment element not found in DOM: comment-${commentId}`);
      return;
    }

    // Clone the comment element to preserve it
    const commentClone = commentElement.cloneNode(true) as HTMLElement;

    // Re-bind event listeners on the cloned element
    this.bindCommentEvents(commentClone, fileIndex, commentIndex);

    // Find the diff container
    const diffContainer = document.querySelector(`#diff-output-${fileIndex}`);
    if (!diffContainer) {
      console.warn(`Diff container not found for file index: ${fileIndex}`);
      return;
    }

    // Get all rows from the diff
    const rows = diffContainer.querySelectorAll('.d2h-diff-tbody tr');
    let commentInserted = false;

    rows.forEach((row) => {
      if (commentInserted) return;

      if (this.viewMode === 'side-by-side') {
        // In side-by-side mode, we need to find the correct side
        const allCells = Array.from(row.querySelectorAll('td'));
        
        allCells.forEach((cell, cellIndex) => {
          if (commentInserted) return;
          
          // Check if this cell IS a line number cell (not contains, but IS)
          const isLineNumberCell = cell.classList.contains('d2h-code-side-linenumber');
          
          if (!isLineNumberCell) return;
          
          const lineText = cell.textContent?.trim() || '';
          const lineNum = parseInt(lineText);

          // Check if this matches our comment line
          if (!isNaN(lineNum) && lineNum === comment.line) {
            // Determine side based on cell position in the row
            // In side-by-side: Line numbers alternate: [old-linenum][old-code][new-linenum][new-code]
            // OR sometimes: [old-linenum][old-code][new-linenum][new-code]
            // Count how many line number cells come before this one
            
            let lineNumCellsBefore = 0;
            for (let i = 0; i < cellIndex; i++) {
              if (allCells[i].classList.contains('d2h-code-side-linenumber')) {
                lineNumCellsBefore++;
              }
            }
            
            // If this is the first line number cell (index 0), it's the left side (FROM/old)
            // If this is the second line number cell (index 1), it's the right side (TO/new)
            const isLeftSide = lineNumCellsBefore === 0;
            const isRightSide = lineNumCellsBefore === 1;
            
            console.log(`Line ${lineNum}: cellIndex=${cellIndex}, lineNumCellsBefore=${lineNumCellsBefore}, isLeftSide=${isLeftSide}, isRightSide=${isRightSide}, commentSide=${comment.side}`);
            
            // Match the comment side with the diff side
            const shouldShowComment = 
              (comment.side === 'FROM' && isLeftSide) || 
              (comment.side === 'TO' && isRightSide);
            
            if (!shouldShowComment) {
              console.log(`Skipping comment - side mismatch`);
              return; // Skip this line number, it's on the wrong side
            }
            
            const nextRow = row.nextElementSibling;
            if (nextRow && nextRow.classList.contains('comment-row')) {
              commentInserted = true;
              return;
            }

            const commentRow = document.createElement('tr');
            commentRow.className = 'comment-row';

            const commentCell = document.createElement('td');
            commentCell.className = 'comment-cell';
            commentCell.setAttribute('colspan', String(allCells.length));
            commentCell.style.padding = '0';
            commentCell.style.border = 'none';
            commentCell.style.backgroundColor = 'var(--bitbucket-file-comparator-bg-overlay)';

            const wrapperDiv = document.createElement('div');
            wrapperDiv.className = 'comment-wrapper';
            wrapperDiv.style.width = '100%';
            wrapperDiv.style.display = 'block';

            commentClone.style.display = 'block';
            commentClone.style.visibility = 'visible';
            commentClone.style.opacity = '1';

            wrapperDiv.appendChild(commentClone);
            commentCell.appendChild(wrapperDiv);
            commentRow.appendChild(commentCell);

            row.parentNode?.insertBefore(commentRow, row.nextSibling);

            commentInserted = true;
          }
        });
      } else {
        // Line-by-line mode (unified view)
        const lineNumberCells = row.querySelectorAll('.d2h-code-linenumber');
        
        lineNumberCells.forEach((lineNumCell) => {
          if (commentInserted) return;

          const lineText = lineNumCell.textContent?.trim() || '';
          const lineNum = parseInt(lineText);

          if (!isNaN(lineNum) && lineNum === comment.line) {
            // In unified view, there are typically 2 line number cells: [old-line][new-line]
            // Check which one this is
            const allLineNumCells = Array.from(lineNumberCells);
            const lineNumIndex = allLineNumCells.indexOf(lineNumCell);
            
            // First cell (index 0) is old line number (FROM)
            // Second cell (index 1) is new line number (TO)
            const isOldLineNum = lineNumIndex === 0;
            const isNewLineNum = lineNumIndex === 1;
            
            // Also check the row's code line type
            const codeLine = row.querySelector('.d2h-code-line');
            const isAddition = codeLine?.classList.contains('d2h-ins');
            const isDeletion = codeLine?.classList.contains('d2h-del');
            const isContext = !isAddition && !isDeletion;
            
            // Match comment side with line type and line number position
            let shouldShowComment = false;
            
            if (comment.side === 'TO') {
              // TO comments: show on new line number in additions, or either line in context
              shouldShowComment = (isNewLineNum && isAddition) || 
                                 (isContext && isNewLineNum);
            } else if (comment.side === 'FROM') {
              // FROM comments: show on old line number in deletions, or either line in context
              shouldShowComment = (isOldLineNum && isDeletion) || 
                                 (isContext && isOldLineNum);
            }
            
            if (!shouldShowComment) {
              return; // Skip this line, wrong side
            }
            
            const nextRow = row.nextElementSibling;
            if (nextRow && nextRow.classList.contains('comment-row')) {
              return;
            }

            const commentRow = document.createElement('tr');
            commentRow.className = 'comment-row';

            const commentCell = document.createElement('td');
            commentCell.className = 'comment-cell';
            const allCells = row.querySelectorAll('td');
            commentCell.setAttribute('colspan', String(allCells.length));
            commentCell.style.padding = '0';
            commentCell.style.border = 'none';
            commentCell.style.backgroundColor = 'var(--bitbucket-file-comparator-bg-overlay)';

            const wrapperDiv = document.createElement('div');
            wrapperDiv.className = 'comment-wrapper';
            wrapperDiv.style.width = '100%';
            wrapperDiv.style.display = 'block';

            commentClone.style.display = 'block';
            commentClone.style.visibility = 'visible';
            commentClone.style.opacity = '1';

            wrapperDiv.appendChild(commentClone);
            commentCell.appendChild(wrapperDiv);
            commentRow.appendChild(commentCell);

            row.parentNode?.insertBefore(commentRow, row.nextSibling);

            commentInserted = true;
          }
        });
      }
    });

    if (!commentInserted) {
      console.warn(`Could not insert comment for line ${comment.line} (${comment.side}) in file ${file.file_path}`);
    }
  });
}
