import { Component, OnInit, ChangeDetectorRef, ChangeDetectionStrategy, ViewChild, ElementRef } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { ChunkedJsonParserService, ToolData, ApprovalRequest } from './chunked-json-parser.service';

// Optimized interfaces
interface ProcessedFileItem {
  id: string;
  type: 'READ' | 'FILE_OP';
  tool: string;
  fileName: string;
  filePath: string;
  fileExtension: string;
  executedAt?: Date;
  rejected?: boolean;
  position?: number;
  isPendingApproval?: boolean;
}

interface DiffLine {
  lineNum1: number | null;
  lineNum2: number | null;
  prefix: string;
  content: string;
  type: 'added' | 'removed' | 'unchanged';
}

interface ApprovalData {
  tool: string;
  fileName: string;
  filePath: string;
  fileExtension: string;
  reasoning: string;
  diffLines: DiffLine[];
  toolData: ToolData;
}

interface CompletedFileInfo {
  fileName: string;
  tool: string;
  rejected: boolean;
}

@Component({
  selector: 'vibe-coding-chunked-json-parser',
  templateUrl: './chunked-json-parser.component.html',
  styleUrls: ['./chunked-json-parser.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ChunkedJsonParserComponent implements OnInit {
  @ViewChild('executedFileList', { read: ElementRef }) executedFileListRef!: ElementRef;

  // State management
  public isProcessing = false;
  public isCompleted = false;
  public hasReceivedFirstChunk = false;
  public isWaitingForApproval = false;
  public isApprovingChanges = false;

  // Processed data - ready for template
  public executedFiles: ProcessedFileItem[] = [];
  public queuedFiles: ProcessedFileItem[] = [];
  public approvalData: ApprovalData | null = null;
  public completedFiles: CompletedFileInfo[] = [];

  // Counts
  public executedCount = 0;
  public queuedCount = 0;

  constructor(
    private parserService: ChunkedJsonParserService,
    private cdr: ChangeDetectorRef,
    private http: HttpClient
  ) {}

  ngOnInit(): void {
    // Callbacks will be set up when user clicks RUN
  }

  // ============================================================================
  // PUBLIC METHODS - Called from template
  // ============================================================================

  public async runDemo(): Promise<void> {
    console.clear();
    console.log('üöÄ Starting streaming process...\n');

    // Reset all state
    this.resetState();
    this.setupCallbacks();
    this.isProcessing = true;
    this.cdr.markForCheck();

    try {
      await this.parserService.startStreaming();
    } catch (error) {
      if (error instanceof Error && error.name !== 'AbortError') {
        console.error('Failed to start streaming:', error);
      }
      this.isProcessing = false;
      this.cdr.markForCheck();
    }
  }

  public stopStreaming(): void {
    console.log('üõë Stopping streaming process...\n');
    this.parserService.stopStreaming();
    this.isProcessing = false;
    this.isWaitingForApproval = false;
    this.approvalData = null;
    this.cdr.markForCheck();
  }

  public async approveAndContinue(): Promise<void> {
    if (!this.approvalData || this.isApprovingChanges) return;

    console.log('‚úÖ APPROVED:', this.approvalData.toolData);

    // Set loading state
    this.isApprovingChanges = true;
    this.cdr.markForCheck();

    try {
      // Make API call to save code changes
      const payload = {
        tool: this.approvalData.tool,
        file_path: this.approvalData.filePath,
        file_name: this.approvalData.fileName,
        original_code: this.getOriginalCode(this.approvalData.toolData),
        modified_code: this.getModifiedCode(this.approvalData.toolData),
        reasoning: this.approvalData.reasoning,
        timestamp: new Date().toISOString()
      };

      await this.saveCodeChanges(payload);
      console.log('‚úÖ Code changes saved successfully');

      // Reset approval state
      this.isWaitingForApproval = false;
      this.approvalData = null;

      // Continue with next operation
      this.parserService.approveAndContinue();
      this.processCurrentData();

    } catch (error) {
      console.error('‚ùå Failed to save code changes:', error);
      alert('Failed to save code changes. Please try again.');
      this.isApprovingChanges = false;
      this.cdr.markForCheck();
      return;
    }

    // Keep spinner for minimum duration
    setTimeout(() => {
      this.isApprovingChanges = false;
      this.cdr.markForCheck();
    }, 500);
  }

  public rejectChanges(): void {
    if (!this.approvalData) return;

    console.log('‚ùå REJECTED:', this.approvalData.toolData);

    // Mark as rejected
    this.approvalData.toolData.rejected = true;

    // Reset approval state
    this.isWaitingForApproval = false;
    this.approvalData = null;

    // Continue to next operation
    this.parserService.approveAndContinue();
    this.processCurrentData();
    this.cdr.markForCheck();
  }

  public formatTime(date: Date): string {
    return date.toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  }

  // ============================================================================
  // PRIVATE METHODS - Internal logic
  // ============================================================================

  private resetState(): void {
    this.executedFiles = [];
    this.queuedFiles = [];
    this.approvalData = null;
    this.completedFiles = [];
    this.isProcessing = false;
    this.isCompleted = false;
    this.hasReceivedFirstChunk = false;
    this.isWaitingForApproval = false;
    this.isApprovingChanges = false;
    this.executedCount = 0;
    this.queuedCount = 0;
  }

  private setupCallbacks(): void {
    this.parserService.setCallbacks({
      onToolDetected: (toolData: ToolData) => {
        this.logToolDetected(toolData);
        this.processCurrentData();
        this.scrollToBottom();
        this.cdr.markForCheck();
      },
      onApprovalRequest: (approvalRequest: ApprovalRequest) => {
        this.isWaitingForApproval = true;
        this.approvalData = this.processApprovalRequest(approvalRequest);
        this.logWaitingForApproval(approvalRequest.data);
        this.processCurrentData();
        this.scrollToBottom();
        this.cdr.markForCheck();
      },
      onCompletion: () => {
        this.isProcessing = false;
        this.isApprovingChanges = false;
        this.hasReceivedFirstChunk = false;
        this.isCompleted = true;
        this.processCompletedFiles();
        this.logCompleted();
        this.processCurrentData();
        this.cdr.markForCheck();
      },
      onError: (error: string) => {
        this.isProcessing = false;
        this.isApprovingChanges = false;
        this.hasReceivedFirstChunk = false;
        this.logError(error);
        this.cdr.markForCheck();
      },
      onFirstChunk: () => {
        this.hasReceivedFirstChunk = true;
        this.logFirstChunkReceived();
        this.cdr.markForCheck();
      }
    });
  }

  private processCurrentData(): void {
    const executedTools = this.parserService.getCompletedTools();
    const queuedTools = this.parserService.getPendingTools();

    // Process executed files
    this.executedFiles = executedTools
      .filter(tool => tool.tool !== 'READ')
      .map((tool, index) => this.processToolData(tool, index, 'executed'));

    // Process queued files
    this.queuedFiles = queuedTools.map((tool, index) => {
      const processed = this.processToolData(tool, index, 'queued');
      if (tool.tool === 'WRITE' || tool.tool === 'MODIFY') {
        processed.isPendingApproval = true;
      }
      return processed;
    });

    // Update counts
    this.executedCount = executedTools.length;
    this.queuedCount = queuedTools.length;
  }

  private processToolData(tool: ToolData, index: number, context: 'executed' | 'queued'): ProcessedFileItem {
    const fileDetails = this.getFileDetails(tool.content);
    const fileName = fileDetails?.file_name || (typeof tool.content === 'string' ? tool.content : 'Unknown');
    const filePath = fileDetails?.file_path || '';

    return {
      id: `${context}-${tool.tool}-${index}`,
      type: tool.tool === 'READ' ? 'READ' : 'FILE_OP',
      tool: tool.tool,
      fileName: fileName,
      filePath: filePath,
      fileExtension: this.getFileExtension(fileName),
      executedAt: tool.executedAt,
      rejected: tool.rejected || false,
      position: index + 1
    };
  }

  private processApprovalRequest(approvalRequest: ApprovalRequest): ApprovalData {
    const fileDetails = this.getFileDetails(approvalRequest.data.content);
    const fileName = fileDetails?.file_name || 'Unknown';
    const reasoning = this.getReasoning(approvalRequest.data.content);
    
    // Generate diff lines
    const originalCode = fileDetails?.original_code || '';
    const modifiedCode = fileDetails?.modified_code || '';
    const diffLines = this.generateDiffLines(originalCode, modifiedCode);

    return {
      tool: approvalRequest.data.tool,
      fileName: fileName,
      filePath: fileDetails?.file_path || '',
      fileExtension: this.getFileExtension(fileName),
      reasoning: reasoning,
      diffLines: diffLines,
      toolData: approvalRequest.data
    };
  }

  private generateDiffLines(originalCode: string, modifiedCode: string): DiffLine[] {
    const original = (originalCode || '').split('\n');
    const modified = (modifiedCode || '').split('\n');
    
    // Limit for performance
    const maxLines = 500;
    if (original.length > maxLines || modified.length > maxLines) {
      return [{
        lineNum1: null,
        lineNum2: null,
        prefix: '',
        content: `File too large to display diff (max ${maxLines} lines)`,
        type: 'unchanged'
      }];
    }

    const lines: DiffLine[] = [];
    let originalLineNum = 1;
    let modifiedLineNum = 1;
    const maxLen = Math.max(original.length, modified.length);

    for (let i = 0; i < maxLen; i++) {
      const origLine = i < original.length ? original[i] : null;
      const modLine = i < modified.length ? modified[i] : null;

      if (origLine === modLine && origLine !== null) {
        // Unchanged line
        lines.push({
          lineNum1: originalLineNum,
          lineNum2: modifiedLineNum,
          prefix: '  ',
          content: origLine,
          type: 'unchanged'
        });
        originalLineNum++;
        modifiedLineNum++;
      } else {
        // Changed lines
        if (origLine !== null) {
          lines.push({
            lineNum1: originalLineNum,
            lineNum2: null,
            prefix: '- ',
            content: origLine,
            type: 'removed'
          });
          originalLineNum++;
        }
        if (modLine !== null) {
          lines.push({
            lineNum1: null,
            lineNum2: modifiedLineNum,
            prefix: '+ ',
            content: modLine,
            type: 'added'
          });
          modifiedLineNum++;
        }
      }
    }

    return lines;
  }

  private processCompletedFiles(): void {
    const executedTools = this.parserService.getCompletedTools();
    
    this.completedFiles = executedTools
      .filter(tool => tool.tool === 'WRITE' || tool.tool === 'MODIFY')
      .map(tool => {
        const fileDetails = this.getFileDetails(tool.content);
        return {
          fileName: fileDetails?.file_name || 'Unknown',
          tool: tool.tool,
          rejected: tool.rejected || false
        };
      });
  }

  private getFileDetails(content: any): any {
    if (!content || typeof content !== 'object') return null;
    if (content.files && Array.isArray(content.files) && content.files.length > 0) {
      return content.files[0];
    }
    return null;
  }

  private getReasoning(content: any): string {
    if (typeof content === 'object' && content && content.reasoning) {
      return content.reasoning;
    }
    return '';
  }

  private getOriginalCode(toolData: ToolData): string {
    const fileDetails = this.getFileDetails(toolData.content);
    return fileDetails?.original_code || '';
  }

  private getModifiedCode(toolData: ToolData): string {
    const fileDetails = this.getFileDetails(toolData.content);
    return fileDetails?.modified_code || '';
  }

  private getFileExtension(filename: string): string {
    if (!filename) return 'FILE';
    const ext = filename.split('.').pop()?.toUpperCase();
    return ext || 'FILE';
  }

  private async saveCodeChanges(payload: any): Promise<void> {
    const apiUrl = 'https://your-api-endpoint.com/api/save-code';
    
    const headers = new HttpHeaders({
      'Content-Type': 'application/json'
    });

    return new Promise((resolve, reject) => {
      this.http.post(apiUrl, payload, { headers }).subscribe({
        next: (response) => {
          console.log('API Response:', response);
          resolve();
        },
        error: (error) => {
          console.error('API Error:', error);
          reject(error);
        }
      });
    });
  }

  private scrollToBottom(): void {
    setTimeout(() => {
      if (this.executedFileListRef?.nativeElement) {
        const element = this.executedFileListRef.nativeElement;
        element.scrollTop = element.scrollHeight;
      }
    }, 100);
  }

  // Logging methods
  private logToolDetected(toolData: ToolData): void {
    const tool = toolData.tool;
    if (tool === 'READ') {
      console.log('üìñ READ Tool detected:', toolData);
    } else if (tool === 'WRITE') {
      console.log('‚úèÔ∏è WRITE Tool detected:', toolData);
    } else if (tool === 'MODIFY') {
      console.log('üîß MODIFY Tool detected:', toolData);
    }
  }

  private logFirstChunkReceived(): void {
    console.log('üì¶ First chunk received from stream');
  }

  private logWaitingForApproval(toolData: ToolData): void {
    console.log(`‚ö†Ô∏è WAITING FOR APPROVAL - ${toolData.tool} Tool:`, toolData);
  }

  private logCompleted(): void {
    console.log('üéâ COMPLETED - All operations finished successfully');
  }

  private logError(error: string): void {
    console.error('‚ùå Error:', error);
  }
}














<div class="vibe-coding-container">
  <!-- Header -->
  <div class="vibe-coding-header">
    <div class="vibe-coding-header-content">
      <div class="vibe-coding-header-left">
        <h1>Execution Flow Tracker</h1>
        <p>Monitor your tool execution pipeline</p>
      </div>
      
      <div class="vibe-coding-header-right">
        <button 
          class="vibe-coding-btn vibe-coding-btn-primary" 
          (click)="runDemo()" 
          [disabled]="isProcessing">
          RUN
        </button>

        <!-- Processing Badge -->
        <span *ngIf="isProcessing && !isCompleted" class="vibe-coding-processing-badge">
          <span class="vibe-coding-processing-dot"></span>
          Processing
        </span>

        <!-- Completed Badge -->
        <span *ngIf="isCompleted" class="vibe-coding-completed-badge">
          <span class="vibe-coding-completed-icon">‚úì</span>
          Completed
        </span>

        <!-- Stop Button -->
        <button 
          *ngIf="isProcessing && !isCompleted"
          class="vibe-coding-stop-btn" 
          (click)="stopStreaming()"
          title="Stop Streaming">
          <svg class="vibe-coding-stop-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="6" y="6" width="12" height="12" fill="currentColor" rx="2"/>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <!-- Main Content -->
  <div class="vibe-coding-content">
    <!-- Executed Files Section -->
    <div class="vibe-coding-section vibe-coding-executed">
      <div class="vibe-coding-section-header">
        <div class="vibe-coding-section-icon">‚úì</div>
        <div class="vibe-coding-section-title">
          <h2>Executed</h2>
          <div class="vibe-coding-count"><span>{{ executedCount }}</span> completed</div>
        </div>
      </div>
      
      <div class="vibe-coding-file-list" #executedFileList>
        <!-- Empty State -->
        <div *ngIf="!isProcessing && executedCount === 0 && !approvalData" class="vibe-coding-empty-state">
          <div class="vibe-coding-empty-state-icon">‚Äî</div>
          <p>No items executed yet</p>
        </div>

        <!-- Executed File Items -->
        <div *ngFor="let file of executedFiles; trackBy: trackByFileId" class="vibe-coding-file-item">
          <div class="vibe-coding-file-icon">{{ file.fileExtension }}</div>
          <div class="vibe-coding-file-info">
            <div class="vibe-coding-file-name">{{ file.fileName }}</div>
            <div class="vibe-coding-file-path" *ngIf="file.filePath">{{ file.filePath }}</div>
          </div>
          <div class="vibe-coding-file-time" *ngIf="file.executedAt">{{ formatTime(file.executedAt) }}</div>
          <div class="vibe-coding-status-badge">{{ file.tool }}</div>
          <div 
            class="vibe-coding-approval-status-badge" 
            [ngClass]="{'vibe-coding-status-rejected': file.rejected, 'vibe-coding-status-accepted': !file.rejected}">
            {{ file.rejected ? 'REJECTED' : 'ACCEPTED' }}
          </div>
        </div>

        <!-- Approval Request Card -->
        <div *ngIf="approvalData" class="vibe-coding-file-item vibe-coding-awaiting-approval">
          <div class="vibe-coding-approval-header">
            <div class="vibe-coding-file-icon">{{ approvalData.fileExtension }}</div>
            <div class="vibe-coding-file-info">
              <div class="vibe-coding-file-name">{{ approvalData.fileName }}</div>
              <div class="vibe-coding-file-path" *ngIf="approvalData.filePath">{{ approvalData.filePath }}</div>
            </div>
            <div class="vibe-coding-approval-badge">{{ approvalData.tool }}</div>
          </div>
          
          <!-- Reasoning Box -->
          <div class="vibe-coding-reasoning-box" *ngIf="approvalData.reasoning">
            <h3>Reasoning</h3>
            <p>{{ approvalData.reasoning }}</p>
          </div>
          
          <!-- Code Changes Diff -->
          <div class="vibe-coding-diff-container">
            <div class="vibe-coding-diff-header">
              <span>Changes in {{ approvalData.fileName }}</span>
            </div>
            <div class="vibe-coding-code-block">
              <pre><code>
                <div *ngFor="let line of approvalData.diffLines; trackBy: trackByLineIndex" 
                     class="vibe-coding-diff-line"
                     [ngClass]="{
                       'vibe-coding-added': line.type === 'added',
                       'vibe-coding-removed': line.type === 'removed',
                       'vibe-coding-unchanged': line.type === 'unchanged'
                     }">
                  <span class="vibe-coding-line-number">{{ line.lineNum1 || '' }}</span>
                  <span class="vibe-coding-line-number">{{ line.lineNum2 || '' }}</span>
                  <span class="vibe-coding-line-prefix">{{ line.prefix }}</span>
                  <span class="vibe-coding-line-content">{{ line.content }}</span>
                </div>
              </code></pre>
            </div>
          </div>
          
          <!-- Approval Actions -->
          <div class="vibe-coding-approval-actions">
            <button 
              class="vibe-coding-approval-btn vibe-coding-reject" 
              (click)="rejectChanges()"
              [disabled]="isApprovingChanges">
              ‚úï Reject
            </button>
            <button 
              class="vibe-coding-approval-btn vibe-coding-accept" 
              (click)="approveAndContinue()"
              [disabled]="isApprovingChanges">
              <span *ngIf="!isApprovingChanges">‚úì Accept & Continue</span>
              <span *ngIf="isApprovingChanges" class="vibe-coding-accepting-wrapper">
                <span class="vibe-coding-inline-spinner"></span>
                Accepting Changes
              </span>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Queued Files Section -->
    <div class="vibe-coding-section vibe-coding-queued">
      <div class="vibe-coding-section-header">
        <div class="vibe-coding-section-icon">‚ãØ</div>
        <div class="vibe-coding-section-title">
          <h2>Queued</h2>
          <div class="vibe-coding-count"><span>{{ queuedCount }}</span> pending</div>
        </div>
      </div>
      
      <div class="vibe-coding-file-list">
        <!-- Empty State -->
        <div *ngIf="queuedCount === 0 && !isProcessing && !isCompleted" class="vibe-coding-empty-state">
          <div class="vibe-coding-empty-state-icon">‚Äî</div>
          <p>No items in queue</p>
        </div>

        <!-- Finished All Tasks State -->
        <div *ngIf="isCompleted && queuedCount === 0" class="vibe-coding-finished-state">
          <div class="vibe-coding-finished-icon">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
              <path d="M8 12L11 15L16 9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <h3>All Tasks Completed</h3>
          <p>Successfully executed all operations</p>

          <!-- Files Modified Section -->
          <div class="vibe-coding-files-modified" *ngIf="completedFiles.length > 0">
            <div class="vibe-coding-files-header">
              <h4>Files Modified</h4>
              <span class="vibe-coding-files-count">{{ completedFiles.length }} file(s)</span>
            </div>
            
            <div class="vibe-coding-files-list">
              <div *ngFor="let file of completedFiles; trackBy: trackByFileName" class="vibe-coding-modified-file">
                <div class="vibe-coding-modified-file-name-row">
                  <span class="vibe-coding-modified-filename">{{ file.fileName }}</span>
                </div>
                
                <div class="vibe-coding-modified-file-badges">
                  <span class="vibe-coding-modified-badge" 
                        [ngClass]="{
                          'vibe-coding-badge-write': file.tool === 'WRITE', 
                          'vibe-coding-badge-modify': file.tool === 'MODIFY'
                        }">
                    {{ file.tool }}
                  </span>
                  <span 
                    class="vibe-coding-status-indicator" 
                    [ngClass]="{
                      'vibe-coding-indicator-rejected': file.rejected, 
                      'vibe-coding-indicator-accepted': !file.rejected
                    }">
                    {{ file.rejected ? 'REJECTED' : 'ACCEPTED' }}
                  </span>
                </div>
              </div>
            </div>

            <!-- Refresh Instruction -->
            <div class="vibe-coding-refresh-instruction">
              <svg class="vibe-coding-refresh-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M21 10C21 10 18.995 7.26822 17.3662 5.63824C15.7373 4.00827 13.4864 3 11 3C6.02944 3 2 7.02944 2 12C2 16.9706 6.02944 21 11 21C15.1031 21 18.5649 18.2543 19.6482 14.5M21 10V4M21 10H15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
              <p>
                <strong>Refresh your folder</strong> to view the created or modified files in your workspace.
              </p>
            </div>
          </div>
        </div>

        <!-- Waiting for First Chunk State -->
        <div *ngIf="isProcessing && !hasReceivedFirstChunk && executedCount === 0" class="vibe-coding-waiting-state">
          <div class="vibe-coding-waiting-spinner"></div>
          <h3>Connecting to AI Agent<span class="vibe-coding-waiting-dots"><span>.</span><span>.</span><span>.</span></span></h3>
          <p>Analyzing your request and preparing execution plan</p>
          <div class="vibe-coding-waiting-steps">
            <div class="vibe-coding-step">
              <span class="vibe-coding-step-icon">‚ö°</span>
              <span class="vibe-coding-step-text">Processing request</span>
            </div>
            <div class="vibe-coding-step">
              <span class="vibe-coding-step-icon">üîç</span>
              <span class="vibe-coding-step-text">Analyzing codebase</span>
            </div>
            <div class="vibe-coding-step">
              <span class="vibe-coding-step-icon">üìã</span>
              <span class="vibe-coding-step-text">Generating tasks</span>
            </div>
          </div>
        </div>

        <!-- Loading State (Generating Next Task) -->
        <div *ngIf="queuedCount === 0 && isProcessing && executedCount > 0 && hasReceivedFirstChunk" class="vibe-coding-loading-state">
          <div class="vibe-coding-loading-spinner"></div>
          <h3>Generating Next Task<span class="vibe-coding-loading-dots"><span>.</span><span>.</span><span>.</span></span></h3>
          <p>Analyzing execution results</p>
        </div>

        <!-- Queued File Items -->
        <div *ngFor="let file of queuedFiles; trackBy: trackByFileId" 
             class="vibe-coding-file-item"
             [ngClass]="{'vibe-coding-pending-approval': file.isPendingApproval}">
          <div class="vibe-coding-file-icon">{{ file.fileExtension }}</div>
          <div class="vibe-coding-file-info">
            <div class="vibe-coding-file-name">{{ file.fileName }}</div>
            <div class="vibe-coding-file-path" *ngIf="file.filePath">{{ file.filePath }}</div>
          </div>
          <div class="vibe-coding-status-badge">{{ file.tool }}</div>
        </div>
      </div>
    </div>
  </div>
</div>
