import { Component, OnInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Subscription } from 'rxjs';

// ... existing interfaces ...

@Component({
  selector: 'app-workflow-sidebar',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './workflow-sidebar.component.html',
  styleUrls: ['./workflow-sidebar.component.css']
})
export class WorkflowSidebarComponent implements OnInit, OnDestroy {
  // ... existing properties ...

  private pollingInterval: any;
  private readonly POLLING_INTERVAL_MS = 120000; // 2 minutes in milliseconds
  
  // Add subscriptions for tracking pending requests
  private myWorkflowsSubscription?: Subscription;
  private activeWorkflowsSubscription?: Subscription;
  private sharedWorkflowsSubscription?: Subscription;
  private isPollingInProgress = false; // Add flag to track if polling is in progress

  ngOnInit(): void {
    this.loadWorkflows();
    this.startPolling();
  }

  ngOnDestroy(): void {
    this.stopPolling();
    this.cancelAllPendingRequests(); // Cancel any pending requests on destroy
  }

  startPolling(): void {
    this.pollingInterval = setInterval(() => {
      console.log('Polling workflows...', new Date().toISOString());
      this.pollWorkflows();
    }, this.POLLING_INTERVAL_MS);
  }

  stopPolling(): void {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
      console.log('Polling stopped');
    }
  }

  pollWorkflows(): void {
    // Don't poll if there's an error, refresh in progress, or previous poll still running
    if (this.hasError || this.isRefreshing || this.isPollingInProgress) {
      console.log('Skipping poll - error, refresh, or previous poll in progress');
      return;
    }

    // Cancel any pending requests before starting new poll
    this.cancelAllPendingRequests();
    
    // Set polling in progress flag
    this.isPollingInProgress = true;

    // Fetch all workflows
    console.log('Fetching My Workflows...');
    this.fetchMyWorkflows();

    console.log('Fetching Active Workflows...');
    this.fetchActiveWorkflows();

    console.log('Fetching Shared Workflows...');
    this.fetchSharedWorkflows();
  }

  // Add method to cancel all pending requests
  cancelAllPendingRequests(): void {
    if (this.myWorkflowsSubscription && !this.myWorkflowsSubscription.closed) {
      console.log('Cancelling pending My Workflows request');
      this.myWorkflowsSubscription.unsubscribe();
    }
    
    if (this.activeWorkflowsSubscription && !this.activeWorkflowsSubscription.closed) {
      console.log('Cancelling pending Active Workflows request');
      this.activeWorkflowsSubscription.unsubscribe();
    }
    
    if (this.sharedWorkflowsSubscription && !this.sharedWorkflowsSubscription.closed) {
      console.log('Cancelling pending Shared Workflows request');
      this.sharedWorkflowsSubscription.unsubscribe();
    }
  }

  fetchMyWorkflows(): void {
    // Cancel previous request if still pending
    if (this.myWorkflowsSubscription && !this.myWorkflowsSubscription.closed) {
      this.myWorkflowsSubscription.unsubscribe();
    }

    // In production: make API call
    // this.myWorkflowsSubscription = this.http.get<Workflow[]>('your-api/my-workflows').subscribe({
    //   next: (data) => {
    //     this.myWorkflows = data;
    //     console.log('My Workflows updated:', data.length);
    //     this.checkPollingComplete();
    //   },
    //   error: (error) => {
    //     console.error('Error fetching My Workflows:', error);
    //     this.checkPollingComplete();
    //   }
    // });

    // For demo: simulate with setTimeout
    const timeoutId = setTimeout(() => {
      console.log('My Workflows fetched successfully');
      this.checkPollingComplete();
    }, 1000);

    // Store as subscription (for demo, we'd clear the timeout on unsubscribe)
    this.myWorkflowsSubscription = new Subscription(() => clearTimeout(timeoutId));
  }

  fetchActiveWorkflows(): void {
    // Cancel previous request if still pending
    if (this.activeWorkflowsSubscription && !this.activeWorkflowsSubscription.closed) {
      this.activeWorkflowsSubscription.unsubscribe();
    }

    // In production: make API call
    // this.activeWorkflowsSubscription = this.http.get<Workflow[]>('your-api/active-workflows').subscribe({
    //   next: (data) => {
    //     this.activeWorkflows = data;
    //     console.log('Active Workflows updated:', data.length);
    //     this.checkPollingComplete();
    //   },
    //   error: (error) => {
    //     console.error('Error fetching Active Workflows:', error);
    //     this.checkPollingComplete();
    //   }
    // });

    // For demo: simulate with setTimeout
    const timeoutId = setTimeout(() => {
      console.log('Active Workflows fetched successfully');
      this.checkPollingComplete();
    }, 1000);

    this.activeWorkflowsSubscription = new Subscription(() => clearTimeout(timeoutId));
  }

  fetchSharedWorkflows(): void {
    // Cancel previous request if still pending
    if (this.sharedWorkflowsSubscription && !this.sharedWorkflowsSubscription.closed) {
      this.sharedWorkflowsSubscription.unsubscribe();
    }

    // In production: make API call
    // this.sharedWorkflowsSubscription = this.http.get<SharedWorkflow[]>('your-api/shared-workflows').subscribe({
    //   next: (data) => {
    //     this.sharedWorkflows = data;
    //     console.log('Shared Workflows updated:', data.length);
    //     this.checkPollingComplete();
    //   },
    //   error: (error) => {
    //     console.error('Error fetching Shared Workflows:', error);
    //     this.checkPollingComplete();
    //   }
    // });

    // For demo: simulate with setTimeout
    const timeoutId = setTimeout(() => {
      console.log('Shared Workflows fetched successfully');
      this.checkPollingComplete();
    }, 1000);

    this.sharedWorkflowsSubscription = new Subscription(() => clearTimeout(timeoutId));
  }

  // Add method to check if all polling requests are complete
  checkPollingComplete(): void {
    const allComplete = 
      (!this.myWorkflowsSubscription || this.myWorkflowsSubscription.closed) &&
      (!this.activeWorkflowsSubscription || this.activeWorkflowsSubscription.closed) &&
      (!this.sharedWorkflowsSubscription || this.sharedWorkflowsSubscription.closed);

    if (allComplete) {
      this.isPollingInProgress = false;
      console.log('Polling cycle complete');
    }
  }

  // ... rest of existing methods ...
}
