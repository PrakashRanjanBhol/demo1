// ONLY SHOWING THE MODIFIED PARTS

import { Injectable } from '@angular/core';
import { HttpClient, HttpEventType, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

// MODIFIED INTERFACE - Updated to match new API response
export interface UploadResponse {
  status: string;  // Changed from success to status
  data?: {
    id: number;
    original_name: string;
    created_at: string;
  };
  message?: string;  // Keep for backward compatibility
}

// ... rest of the interfaces remain the same ...

@Injectable({
  providedIn: 'root'
})
export class UploadService {
  private apiUrl = 'http://localhost:3000/api';

  constructor(private http: HttpClient) { }

  // ... other methods remain the same ...
}









// ONLY SHOWING THE MODIFIED PARTS

// MODIFIED INTERFACE - Add more properties from API response
interface FileWithStatus {
  file: File;
  status: 'pending' | 'uploading' | 'uploaded' | 'error';
  progress?: number;
  uploadedFileId?: number;  // Changed from string to number
  uploadedFileName?: string;  // NEW - Store original_name from API
  uploadedDate?: string;  // NEW - Store created_at from API
}

// ... rest of the component code ...

// MODIFIED METHOD - Update upload handling to store API response data
private uploadFileViaService(fileWithStatus: FileWithStatus): Promise<void> {
  return new Promise((resolve, reject) => {
    const sub = this.uploadService.uploadFile(fileWithStatus.file).subscribe({
      next: (event: any) => {
        if (event.type === HttpEventType.UploadProgress) {
          if (event.total) {
            fileWithStatus.progress = Math.round((100 * event.loaded) / event.total);
          }
        } else if (event.type === HttpEventType.Response) {
          const response = event.body as UploadResponse;
          
          // MODIFIED - Store data from new API response structure
          if (response.status === 'Success' && response.data) {
            fileWithStatus.uploadedFileId = response.data.id;
            fileWithStatus.uploadedFileName = response.data.original_name;
            fileWithStatus.uploadedDate = response.data.created_at;
            console.log('Upload successful:', response);
            resolve();
          } else {
            reject(new Error('Upload failed'));
          }
        }
      },
      error: (error) => {
        console.error('Upload error:', error);
        reject(error);
      }
    });
    this.subscriptions.push(sub);
  });
}

// MODIFIED METHOD - Use uploaded file data when generating
handleGenerate(): void {
  if (this.uploadMode === 'new' && this.selectedUploadFile) {
    const fileWithStatus = this.uploadedFilesWithStatus.find(f => f.file === this.selectedUploadFile);

    if (!fileWithStatus?.uploadedFileId) {
      alert('Please upload the file first before generating.');
      return;
    }

    // MODIFIED - Use data from API response
    this.onGenerate.emit({
      file: {
        fileID: fileWithStatus.uploadedFileId,  // Now using number ID from API
        fileName: fileWithStatus.uploadedFileName || fileWithStatus.file.name,  // Use API name or fallback
        createdAt: fileWithStatus.uploadedDate  // NEW - Include creation date
      },
      prompts: this.optionalPrompts,
      mode: this.uploadMode
    });

    this.startProcessing(fileWithStatus.uploadedFileName || fileWithStatus.file.name);

    const request: GenerateRequest = {
      fileID: fileWithStatus.uploadedFileId,
      optional_prompt: this.optionalPrompts,
      model_name: this.selectedModel
    };

    this.generateAnalysis(request);

  } else if (this.uploadMode === 'previous' && this.selectedPreviousFile) {
    // Previous file mode remains the same
    this.onGenerate.emit({
      file: {
        fileID: this.selectedPreviousFile.id,
        fileName: this.selectedPreviousFile.name
      },
      prompts: this.optionalPrompts,
      mode: this.uploadMode
    });

    this.startProcessing(this.selectedPreviousFile.name);

    const request: GenerateRequest = {
      fileID: this.selectedPreviousFile.id,
      optional_prompt: this.optionalPrompts,
      model_name: this.selectedModel
    };

    this.generateAnalysis(request);
  }
}

// MODIFIED METHOD - Update completion handling to use correct file ID
private onProgressComplete(): void {
  this.stopPolling();

  // MODIFIED - Get file data from the correct source
  const fileData = this.uploadMode === 'new'
    ? this.uploadedFilesWithStatus.find(f => f.file.name === this.selectedUploadFile?.name)
    : null;

  const fileId = this.uploadMode === 'new'
    ? fileData?.uploadedFileId
    : this.selectedPreviousFile?.id;

  const fileName = this.uploadMode === 'new'
    ? (fileData?.uploadedFileName || this.selectedUploadFile?.name)
    : this.selectedPreviousFile?.name;

  // Emit completion event to update status and load results
  this.onGenerate.emit({
    file: {
      fileID: fileId,
      fileName: fileName,
      isComplete: true  // Flag to indicate completion
    },
    prompts: this.optionalPrompts,
    mode: this.uploadMode
  });

  setTimeout(() => {
    this.completeProcessing();
  }, 500);
}












// ONLY SHOWING THE MODIFIED PARTS

// MODIFIED METHOD - Handle new file data structure from upload response
onGenerateComplete(data: { file: any, prompts: string, mode: string }): void {
  const fileId = data.file.fileID.toString();
  const isComplete = data.file.isComplete || false;

  const existingItem = this.historyComponent?.historyItems.find((i: any) => i.id === fileId);

  if (isComplete) {
    if (existingItem) {
      this.historyComponent.updateItemStatus(fileId, 'completed');
      this.selectedHistoryItem = existingItem;
      this.loadResultsForItem(fileId);
    }
    return;
  }

  if (existingItem) {
    this.historyComponent.updateItemStatus(fileId, 'in-progress');
    this.selectedHistoryItem = existingItem;
    this.resultItems = [];
    return;
  }

  // MODIFIED - Use data from new upload response structure
  const displayDate = data.file.createdAt 
    ? 'Created on ' + new Date(data.file.createdAt).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      })
    : 'Created on ' + new Date().toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });

  const newItem = {
    id: fileId,  // Using the ID from API response
    name: data.file.fileName,
    displayDate: displayDate,  // Using created_at from API or current date
    date: data.file.createdAt ? new Date(data.file.createdAt) : new Date(),
    progress: 'in progress',
    status: 'in-progress' as 'not-generated' | 'in-progress' | 'completed',
    isClickable: false
  };

  if (this.historyComponent) {
    this.historyComponent.addHistoryItem(newItem);
  }

  this.selectedHistoryItem = newItem;
  this.resultItems = [];
}
