import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

export interface FAQ {
  question: string;
  answer: string;
}

export interface MCQOption {
  A: string;
  B: string;
  C: string;
  D: string;
}

export interface AssessmentQuestion {
  question: string;
  options: MCQOption;
  correct_answer: string;
  explaination: string;
}

export interface FileAnalysisData {
  summary: string;
  keywords: string[];
  faq: string; // This will be a JSON string
}

export interface FileAnalysisResponse {
  status: string;
  data: FileAnalysisData;
}

@Injectable({
  providedIn: 'root'
})
export class WorkspaceResultService {
  private apiBaseUrl = '/content_analytics/files';

  constructor(private http: HttpClient) { }

  /**
   * Fetch file analysis data by file ID
   */
  getFileAnalysis(fileId: string): Observable<FileAnalysisResponse> {
    return this.http.get<FileAnalysisResponse>(`${this.apiBaseUrl}/${fileId}`);
  }
}










import { Component, Input, OnChanges, SimpleChanges, OnDestroy } from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import { marked } from 'marked';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { WorkspaceResultService, AssessmentQuestion, MCQOption } from './workspace-result.service';

interface ResultItem {
  id: string;
  title: string;
  icon: string;
  content: string;
  type: 'summary' | 'keywords' | 'questions' | 'custom';
  keywords?: string[];
  assessmentQuestions?: AssessmentQuestion[];
  htmlContent?: SafeHtml;
}

interface HistoryItem {
  id: string;
  name: string;
  displayDate: string;
  date: Date;
}

@Component({
  selector: 'app-workspace',
  templateUrl: './workspace.component.html',
  styleUrls: ['./workspace.component.css']
})
export class WorkspaceComponent implements OnChanges, OnDestroy {
  @Input() selectedHistoryItem: HistoryItem | null = null;
  resultItems: ResultItem[] = [];

  isDetailOpen = false;
  selectedItemName = '';
  selectedItemDate = '';
  selectedItemContent: SafeHtml = '';
  selectedResultItemId: string = '';

  expandedItems: Set<string> = new Set();
  private readonly CHAR_LIMIT = 200;

  // Loading and error states
  isLoading = false;
  errorMessage = '';

  // MCQ Assessment state
  currentQuestionIndex = 0;
  selectedAnswers: Map<number, string> = new Map();
  showExplanation: Map<number, boolean> = new Map();
  assessmentComplete = false;

  // Unsubscribe subject
  private destroy$ = new Subject<void>();

  // Chip color schemes
  private chipColors = [
    { bg: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', border: '#667eea' },
    { bg: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)', border: '#f093fb' },
    { bg: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)', border: '#4facfe' },
    { bg: 'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)', border: '#43e97b' },
    { bg: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)', border: '#fa709a' },
    { bg: 'linear-gradient(135deg, #30cfd0 0%, #330867 100%)', border: '#30cfd0' },
    { bg: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)', border: '#a8edea' },
    { bg: 'linear-gradient(135deg, #ff9a56 0%, #ff6a88 100%)', border: '#ff9a56' },
    { bg: 'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)', border: '#ffecd2' },
    { bg: 'linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%)', border: '#a1c4fd' },
  ];

  sampleContent = `...`; // Keep your existing sampleContent

  constructor(
    private sanitizer: DomSanitizer,
    private workspaceResultService: WorkspaceResultService
  ) { }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['selectedHistoryItem'] && this.selectedHistoryItem) {
      this.expandedItems.clear();
      this.resetAssessment();
      this.loadFileAnalysis(this.selectedHistoryItem.id);
    }
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  /**
   * Load file analysis data from API
   */
  loadFileAnalysis(fileId: string): void {
    this.expandedItems.clear();
    
    this.isLoading = true;
    this.errorMessage = '';
    this.resultItems = [];

    this.workspaceResultService.getFileAnalysis(fileId)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (response) => {
          if (response.status === 'success' && response.data) {
            this.mapResponseToResultItems(response.data);
          }
          this.isLoading = false;
        },
        error: (error) => {
          console.error('Error loading file analysis:', error);
          this.errorMessage = 'Failed to load analysis data. Please try again.';
          this.isLoading = false;
        }
      });
  }

  /**
   * Map API response to result items
   */
  private mapResponseToResultItems(data: any): void {
    this.resultItems = [];

    // Add Summary with markdown rendering
    if (data.summary) {
      const htmlContent: any = marked(data.summary);
      this.resultItems.push({
        id: 'summary-1',
        title: 'Summary',
        icon: 'document',
        content: data.summary,
        type: 'summary',
        htmlContent: this.sanitizer.bypassSecurityTrustHtml(htmlContent)
      });
    }

    // Add Keywords
    if (data.keywords && Array.isArray(data.keywords) && data.keywords.length > 0) {
      this.resultItems.push({
        id: 'keywords-1',
        title: 'Key Topics',
        icon: 'tag',
        content: data.keywords.map(k => `• ${k}`).join(' '),
        type: 'keywords',
        keywords: data.keywords
      });
    }

    // Add Assessment Questions (FAQ as MCQ)
    if (data.faq) {
      try {
        // Parse the JSON string
        const parsedFaq = typeof data.faq === 'string' ? JSON.parse(data.faq) : data.faq;
        
        if (Array.isArray(parsedFaq) && parsedFaq.length > 0) {
          this.resultItems.push({
            id: 'assessment-1',
            title: 'Assessment Questions',
            icon: 'question',
            content: `${parsedFaq.length} questions`,
            type: 'questions',
            assessmentQuestions: parsedFaq
          });
        }
      } catch (error) {
        console.error('Error parsing FAQ JSON:', error);
      }
    }
  }

  /**
   * Reset assessment state
   */
  resetAssessment(): void {
    this.currentQuestionIndex = 0;
    this.selectedAnswers.clear();
    this.showExplanation.clear();
    this.assessmentComplete = false;
  }

  /**
   * Get current assessment questions
   */
  getCurrentAssessment(): AssessmentQuestion[] {
    const assessmentItem = this.resultItems.find(item => item.type === 'questions');
    return assessmentItem?.assessmentQuestions || [];
  }

  /**
   * Get current question
   */
  getCurrentQuestion(): AssessmentQuestion | null {
    const questions = this.getCurrentAssessment();
    return questions[this.currentQuestionIndex] || null;
  }

  /**
   * Select an answer for current question
   */
  selectAnswer(optionKey: string): void {
    const currentQuestion = this.getCurrentQuestion();
    if (!currentQuestion || this.showExplanation.get(this.currentQuestionIndex)) {
      return; // Don't allow changing answer after showing explanation
    }

    this.selectedAnswers.set(this.currentQuestionIndex, optionKey);
    this.showExplanation.set(this.currentQuestionIndex, true);
  }

  /**
   * Check if option is selected
   */
  isOptionSelected(optionKey: string): boolean {
    return this.selectedAnswers.get(this.currentQuestionIndex) === optionKey;
  }

  /**
   * Check if answer is correct
   */
  isAnswerCorrect(optionKey: string): boolean {
    const currentQuestion = this.getCurrentQuestion();
    return currentQuestion?.correct_answer === optionKey;
  }

  /**
   * Get option class for styling
   */
  getOptionClass(optionKey: string): string {
    if (!this.showExplanation.get(this.currentQuestionIndex)) {
      return this.isOptionSelected(optionKey) ? 'selected' : '';
    }

    const isSelected = this.isOptionSelected(optionKey);
    const isCorrect = this.isAnswerCorrect(optionKey);

    if (isSelected && isCorrect) {
      return 'correct';
    } else if (isSelected && !isCorrect) {
      return 'incorrect';
    } else if (isCorrect) {
      return 'correct-answer';
    }

    return '';
  }

  /**
   * Should show explanation
   */
  shouldShowExplanation(): boolean {
    return this.showExplanation.get(this.currentQuestionIndex) || false;
  }

  /**
   * Go to next question
   */
  nextQuestion(): void {
    const questions = this.getCurrentAssessment();
    
    if (this.currentQuestionIndex < questions.length - 1) {
      this.currentQuestionIndex++;
    } else {
      this.assessmentComplete = true;
    }
  }

  /**
   * Check if it's the last question
   */
  isLastQuestion(): boolean {
    const questions = this.getCurrentAssessment();
    return this.currentQuestionIndex === questions.length - 1;
  }

  /**
   * Restart assessment
   */
  restartAssessment(): void {
    this.resetAssessment();
  }

  /**
   * Get option keys as array
   */
  getOptionKeys(options: MCQOption): string[] {
    return Object.keys(options);
  }

  openDetail(item: ResultItem): void {
    this.selectedItemName = item.title;
    this.selectedItemDate = this.selectedHistoryItem?.displayDate || '';
    this.selectedResultItemId = item.id;

    const htmlContent: any = marked(this.sampleContent);
    this.selectedItemContent = this.sanitizer.bypassSecurityTrustHtml(htmlContent);

    this.isDetailOpen = true;
  }

  closeDetail(): void {
    this.isDetailOpen = false;
    this.selectedResultItemId = '';
  }

  getIconPath(iconType: string): string {
    const icons: { [key: string]: string } = {
      'document': 'M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m2.25 0H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z',
      'tag': 'M9.568 3H5.25A2.25 2.25 0 003 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 005.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 009.568 3z M6 6h.008v.008H6V6z',
      'question': 'M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9 5.25h.008v.008H12v-.008z',
      'lightbulb': 'M12 18v-5.25m0 0a6.01 6.01 0 001.5-.189m-1.5.189a6.01 6.01 0 01-1.5-.189m3.75 7.478a12.06 12.06 0 01-4.5 0m3.75 2.383a14.406 14.406 0 01-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 10-7.517 0c.85.493 1.509 1.333 1.509 2.316V18'
    };
    return icons[iconType] || icons['document'];
  }

  getKeywordsArray(item: ResultItem): string[] {
    if (item.keywords && Array.isArray(item.keywords)) {
      return item.keywords;
    }

    if (item.content && typeof item.content === 'string') {
      return item.content
        .split('•')
        .map(k => k.trim())
        .filter(k => k.length > 0);
    }

    return [];
  }

  getChipBackground(index: number): string {
    const colorIndex = index % this.chipColors.length;
    return this.chipColors[colorIndex].bg;
  }

  getChipBorderColor(index: number): string {
    const colorIndex = index % this.chipColors.length;
    return this.chipColors[colorIndex].border;
  }

  removeKeyword(itemId: string, keyword: string): void {
    const item = this.resultItems.find(i => i.id === itemId);
    if (!item) return;

    if (item.keywords && Array.isArray(item.keywords)) {
      item.keywords = item.keywords.filter(k => k !== keyword);
      item.content = item.keywords.map(k => `• ${k}`).join(' ');
    } else {
      const keywords = this.getKeywordsArray(item);
      const updatedKeywords = keywords.filter(k => k !== keyword);
      item.content = updatedKeywords.map(k => `• ${k}`).join(' ');
      item.keywords = updatedKeywords;
    }
  }

  toggleExpand(itemId: string): void {
    if (this.expandedItems.has(itemId)) {
      this.expandedItems.delete(itemId);
    } else {
      this.expandedItems.add(itemId);
    }
  }

  isExpanded(itemId: string): boolean {
    return this.expandedItems.has(itemId);
  }

  shouldShowEllipsis(item: ResultItem): boolean {
    return item.type !== 'keywords';
  }

  isContentLong(content: string): boolean {
    return content.length > this.CHAR_LIMIT;
  }

  isSummaryContentLong(item: ResultItem): boolean {
    if (item.type === 'summary' && item.content) {
      return item.content.length > this.CHAR_LIMIT;
    }
    return false;
  }

  copyToClipboard(content: string): void {
    navigator.clipboard.writeText(content).then(() => {
      console.log('Content copied to clipboard');
    });
  }

  downloadContent(item: ResultItem): void {
    const blob = new Blob([item.content], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${item.title.replace(/\s+/g, '_')}.txt`;
    link.click();
    window.URL.revokeObjectURL(url);
  }
}

















<!-- ASSESSMENT QUESTIONS - Show as MCQ -->
<div *ngIf="item.type === 'questions' && item.assessmentQuestions && item.assessmentQuestions.length > 0" class="assessment-container">
    <div class="assessment-header">
        <div class="question-progress">
            <span class="current-question">Question {{ currentQuestionIndex + 1 }}</span>
            <span class="total-questions">of {{ item.assessmentQuestions.length }}</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" [style.width.%]="((currentQuestionIndex + 1) / item.assessmentQuestions.length) * 100"></div>
        </div>
    </div>

    <div class="mcq-question-container" *ngIf="getCurrentQuestion() as question">
        <h4 class="mcq-question">{{ question.question }}</h4>

        <div class="mcq-options">
            <div class="mcq-option" 
                 *ngFor="let optionKey of getOptionKeys(question.options)"
                 [class]="getOptionClass(optionKey)"
                 (click)="selectAnswer(optionKey)">
                <div class="option-indicator">
                    <span class="option-letter">{{ optionKey }}</span>
                    <!-- Check icon for correct -->
                    <svg *ngIf="getOptionClass(optionKey) === 'correct' || getOptionClass(optionKey) === 'correct-answer'" 
                         class="option-icon check-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" />
                    </svg>
                    <!-- X icon for incorrect -->
                    <svg *ngIf="getOptionClass(optionKey) === 'incorrect'" 
                         class="option-icon x-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </div>
                <span class="option-text">{{ question.options[optionKey] }}</span>
            </div>
        </div>

        <!-- Explanation Section -->
        <div class="explanation-section" *ngIf="shouldShowExplanation()">
            <div class="explanation-header">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 001.5-.189m-1.5.189a6.01 6.01 0 01-1.5-.189m3.75 7.478a12.06 12.06 0 01-4.5 0m3.75 2.383a14.406 14.406 0 01-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 10-7.517 0c.85.493 1.509 1.333 1.509 2.316V18" />
                </svg>
                <span>Explanation</span>
            </div>
            <p class="explanation-text">{{ question.explaination }}</p>
        </div>

        <!-- Navigation Buttons -->
        <div class="mcq-navigation" *ngIf="shouldShowExplanation()">
            <button class="next-question-btn" (click)="nextQuestion()" *ngIf="!isLastQuestion()">
                Next Question
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5L21 12m0 0l-7.5 7.5M21 12H3" />
                </svg>
            </button>
            <button class="done-btn" (click)="nextQuestion()" *ngIf="isLastQuestion()">
                Done
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" />
                </svg>
            </button>
        </div>
    </div>

    <!-- Assessment Complete Screen -->
    <div class="assessment-complete" *ngIf="assessmentComplete">
        <div class="complete-icon">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        </div>
        <h3 class="complete-title">Assessment Complete!</h3>
        <p class="complete-message">You've completed all {{ item.assessmentQuestions.length }} questions.</p>
        <button class="restart-btn" (click)="restartAssessment()">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99" />
            </svg>
            Restart Assessment
        </button>
    </div>
</div>


















/* Assessment MCQ Styles */
.assessment-container {
    width: 100%;
    padding: 8px 0;
}

.assessment-header {
    margin-bottom: 20px;
}

.question-progress {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 8px;
}

.current-question {
    font-size: 14px;
    font-weight: 700;
    color: var(--primary-color);
}

.total-questions {
    font-size: 13px;
    color: var(--text-color);
    opacity: 0.6;
}

.progress-bar {
    width: 100%;
    height: 6px;
    background: rgba(139, 92, 246, 0.1);
    border-radius: 10px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--primary-color), #a78bfa);
    transition: width 0.3s ease;
    border-radius: 10px;
}

.mcq-question-container {
    animation: questionFadeIn 0.4s ease-out;
}

@keyframes questionFadeIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.mcq-question {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-color);
    margin: 0 0 16px 0;
    line-height: 1.6;
}

.mcq-options {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 16px;
}

.mcq-option {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 14px;
    background: var(--bg-color);
    border: 2px solid var(--border-color);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.mcq-option:hover {
    border-color: var(--primary-color);
    background: linear-gradient(135deg, rgba(139, 92, 246, 0.05), rgba(167, 139, 250, 0.03));
    transform: translateX(4px);
}

.mcq-option.selected {
    border-color: var(--primary-color);
    background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(167, 139, 250, 0.05));
}

.mcq-option.correct {
    border-color: #10b981;
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.08));
    cursor: default;
}

.mcq-option.correct:hover {
    transform: none;
}

.mcq-option.incorrect {
    border-color: #ef4444;
    background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(239, 68, 68, 0.08));
    cursor: default;
}

.mcq-option.incorrect:hover {
    transform: none;
}

.mcq-option.correct-answer {
    border-color: #10b981;
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.05));
    cursor: default;
}

.mcq-option.correct-answer:hover {
    transform: none;
}

.option-indicator {
    width: 32px;
    height: 32px;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(167, 139, 250, 0.1));
    border: 2px solid rgba(139, 92, 246, 0.3);
    position: relative;
    transition: all 0.3s ease;
}

.mcq-option.selected .option-indicator {
    background: linear-gradient(135deg, var(--primary-color), #a78bfa);
    border-color: var(--primary-color);
}

.mcq-option.correct .option-indicator,
.mcq-option.correct-answer .option-indicator {
    background: linear-gradient(135deg, #10b981, #34d399);
    border-color: #10b981;
}

.mcq-option.incorrect .option-indicator {
    background: linear-gradient(135deg, #ef4444, #f87171);
    border-color: #ef4444;
}

.option-letter {
    font-size: 13px;
    font-weight: 700;
    color: var(--primary-color);
    transition: color 0.3s ease;
}

.mcq-option.selected .option-letter {
    color: white;
}

.mcq-option.correct .option-letter,
.mcq-option.correct-answer .option-letter,
.mcq-option.incorrect .option-letter {
    display: none;
}

.option-icon {
    width: 18px;
    height: 18px;
    stroke: white;
    animation: iconPop 0.3s ease-out;
}

@keyframes iconPop {
    0% {
        transform: scale(0);
        opacity: 0;
    }
    50% {
        transform: scale(1.2);
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}

.option-text {
    flex: 1;
    font-size: 13px;
    color: var(--text-color);
    line-height: 1.5;
}

.mcq-option.correct .option-text,
.mcq-option.correct-answer .option-text {
    color: #10b981;
    font-weight: 600;
}

.mcq-option.incorrect .option-text {
    color: #ef4444;
    font-weight: 600;
}

/* Explanation Section */
.explanation-section {
    margin-top: 16px;
    padding: 14px;
    background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(167, 139, 250, 0.05));
    border-left: 4px solid var(--primary-color);
    border-radius: 0 8px 8px 0;
    animation: explanationSlideIn 0.4s ease-out;
}

@keyframes explanationSlideIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.explanation-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.explanation-header svg {
    width: 16px;
    height: 16px;
    stroke: var(--primary-color);
}

.explanation-header span {
    font-size: 12px;
    font-weight: 700;
    color: var(--primary-color);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.explanation-text {
    font-size: 13px;
    color: var(--text-color);
    line-height: 1.6;
    margin: 0;
}

/* MCQ Navigation */
.mcq-navigation {
    display: flex;
    justify-content: flex-end;
    margin-top: 16px;
}

.next-question-btn,
.done-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    background: linear-gradient(135deg, var(--primary-color), #a78bfa);
    border: none;
    border-radius: 8px;
    color: white;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
}

.next-question-btn:hover,
.done-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
}

.next-question-btn svg,
.done-btn svg {
    width: 16px;
    height: 16px;
    stroke: white;
}

.done-btn {
    background: linear-gradient(135deg, #10b981, #34d399);
    box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
}

.done-btn:hover {
    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
}

/* Assessment Complete */
.assessment-complete {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 40px 20px;
    text-align: center;
    animation: completeFadeIn 0.5s ease-out;
}

@keyframes completeFadeIn {
    from {
        opacity: 0;
        transform: scale(0.95);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

.complete-icon {
    width: 64px;
    height: 64px;
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.1));
    border: 2px solid #10b981;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 16px;
    animation: iconBounce 0.6s ease-out;
}

@keyframes iconBounce {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.1);
    }
}

.complete-icon svg {
    width: 36px;
    height: 36px;
    stroke: #10b981;
}

.complete-title {
    font-size: 16px;
    font-weight: 700;
    color: var(--text-color);
    margin: 0 0 8px 0;
}

.complete-message {
    font-size: 13px;
    color: var(--text-color);
    opacity: 0.7;
    margin: 0 0 20px 0;
}

.restart-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    background: linear-gradient(135deg, var(--primary-color), #a78bfa);
    border: none;
    border-radius: 8px;
    color: white;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
}

.restart-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
}

.restart-btn svg {
    width: 16px;
    height: 16px;
    stroke: white;
}
