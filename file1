export interface GenerateRequest {
  fileID: number;
  model_name: string;
  optional_prompt?: string;
}

export interface ProgressRequest {
  file_id: number;
}

// ... rest of the interfaces remain the same

@Injectable({
  providedIn: 'root'
})
export class UploadGenerateService {
  private apiUrl = 'http://localhost:3000/api';  // Replace with your API base URL

  constructor(private http: HttpClient) { }

  // ... uploadFile method remains the same

  /**
   * Generate analysis from uploaded file
   */
  generateAnalysis(request: GenerateRequest): Observable<GenerateResponse> {
    return this.http.post<GenerateResponse>('/content_analytics/files/generate/', request);
  }

  /**
   * Get generation progress
   */
  getGenerationProgress(fileId: number): Observable<ProgressResponse> {
    const request: ProgressRequest = { file_id: fileId };
    return this.http.post<ProgressResponse>('/content_analytics/files/progress/', request);
  }

  // ... rest of the methods remain the same
}





// Update the startGeneration method:
private startGeneration(): void {
  if (!this.selectedGenerateFile) return;

  this.isProcessing = true;
  this.processingProgress = 0;
  this.processingFileName = this.selectedGenerateFile.name;
  this.processingFileId = String(this.selectedGenerateFile.id);
  this.generationStatus = 'generating';
  this.generationErrorMessage = '';

  const request: GenerateRequest = {
    fileID: Number(this.selectedGenerateFile.id),
    model_name: 'a', // You can make this configurable if needed
    optional_prompt: this.optionalPrompts || ''
  };

  const sub = this.uploadGenerateService.generateAnalysis(request).subscribe({
    next: (response: GenerateResponse) => {
      console.log('Generation API response:', response);
      
      if (response.status === 'Success') {
        // Start progress polling
        this.startProgressPolling(Number(this.selectedGenerateFile!.id));
      } else {
        // Generation failed to start
        this.handleGenerationError('Failed to start generation');
      }
    },
    error: (error) => {
      console.error('Generation error:', error);
      this.handleGenerationError('Failed to initiate generation: ' + (error.message || 'Unknown error'));
    }
  });
  this.subscriptions.push(sub);
}

// Update the startProgressPolling method:
private startProgressPolling(fileId: number): void {
  // Stop any existing polling
  this.stopProgressPolling();

  // Create a polling observable that checks every 10 seconds
  this.progressPollingSubscription = interval(10000)
    .pipe(
      switchMap(() => this.uploadGenerateService.getGenerationProgress(fileId)),
      takeWhile((response: ProgressResponse) => {
        // Continue polling while progress is between 0 and 99
        return response.status === 'Success' && response.progress >= 0 && response.progress < 100;
      }, true) // inclusive: true means it will emit the value that fails the condition
    )
    .subscribe({
      next: (response: ProgressResponse) => {
        console.log('Progress update:', response);

        if (response.status === 'Success') {
          const progress = response.progress;

          if (progress === -1) {
            // Generation failed
            this.handleGenerationError('Content generation failed');
            this.stopProgressPolling();
          } else if (progress === 100) {
            // Generation completed successfully
            this.handleGenerationSuccess();
            this.stopProgressPolling();
          } else if (progress >= 0 && progress < 100) {
            // Update progress
            this.processingProgress = progress;
          }
        } else {
          // Unexpected status
          this.handleGenerationError('Unexpected response status');
          this.stopProgressPolling();
        }
      },
      error: (error) => {
        console.error('Progress polling error:', error);
        this.handleGenerationError('Failed to fetch progress: ' + (error.message || 'Unknown error'));
        this.stopProgressPolling();
      }
    });
}
