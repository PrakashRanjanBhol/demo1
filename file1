import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface HistoryFileResponse {
  id: number;
  original_name: string;
  inserted_at: string;
  progress: number | null;
}

export interface HistoryApiResponse {
  status: string;
  data: {
    files: HistoryFileResponse[];
  };
}

@Injectable({
  providedIn: 'root'
})
export class HistoryService {
  private apiUrl = 'your-api-endpoint-here'; // Replace with your actual API endpoint

  constructor(private http: HttpClient) {}

  getHistoryFiles(fromDate: string, toDate: string): Observable<HistoryApiResponse> {
    const params = {
      from_date: fromDate,
      to_date: toDate
    };
    return this.http.get<HistoryApiResponse>(this.apiUrl, { params });
  }
}














import { Component, EventEmitter, Output, OnInit, OnDestroy } from '@angular/core';
import { HistoryService, HistoryFileResponse } from './history.service';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

interface HistoryItem {
  id: string;
  name: string;
  displayDate: string;
  date: Date;
  progress: number | null;
  status: 'not-generated' | 'in-progress' | 'completed';
  isClickable: boolean;
}

@Component({
  selector: 'app-history',
  templateUrl: './history.component.html',
  styleUrls: ['./history.component.css']
})
export class HistoryComponent implements OnInit, OnDestroy {
  @Output() onItemSelect = new EventEmitter<string>();

  showSearchFilter: boolean = false;
  showDateFilter: boolean = false;
  searchQuery: string = '';
  dateFrom: string = '';
  dateTo: string = '';
  selectedHistoryItem: HistoryItem | null = null;
  isLoading: boolean = false;
  error: string | null = null;

  historyItems: HistoryItem[] = [];
  filteredHistory: HistoryItem[] = [];

  private destroy$ = new Subject<void>();

  constructor(private historyService: HistoryService) {}

  ngOnInit(): void {
    this.initializeDateRange();
    this.loadHistoryData();
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  initializeDateRange(): void {
    const today = new Date();
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(today.getDate() - 30);

    this.dateFrom = this.formatDateForInput(thirtyDaysAgo);
    this.dateTo = this.formatDateForInput(today);
  }

  formatDateForInput(date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  loadHistoryData(): void {
    this.isLoading = true;
    this.error = null;

    this.historyService.getHistoryFiles(this.dateFrom, this.dateTo)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (response) => {
          if (response.status === 'success') {
            this.historyItems = this.mapResponseToHistoryItems(response.data.files);
            this.filteredHistory = [...this.historyItems];
          }
          this.isLoading = false;
        },
        error: (err) => {
          console.error('Error loading history:', err);
          this.error = 'Failed to load history items';
          this.isLoading = false;
        }
      });
  }

  mapResponseToHistoryItems(files: HistoryFileResponse[]): HistoryItem[] {
    return files.map(file => {
      const status = this.getFileStatus(file.progress);
      return {
        id: file.id.toString(),
        name: file.original_name,
        displayDate: `Created on ${file.inserted_at}`,
        date: new Date(file.inserted_at),
        progress: file.progress,
        status: status,
        isClickable: status === 'completed'
      };
    });
  }

  getFileStatus(progress: number | null): 'not-generated' | 'in-progress' | 'completed' {
    if (progress === null) {
      return 'not-generated';
    } else if (progress === 100) {
      return 'completed';
    } else {
      return 'in-progress';
    }
  }

  onHistoryItemClick(item: HistoryItem): void {
    if (!item.isClickable) {
      return;
    }
    this.selectedHistoryItem = item;
    this.onItemSelect.emit(item.id);
  }

  filterHistory(): void {
    this.filteredHistory = this.historyItems.filter(item => {
      const matchesSearch = !this.searchQuery ||
        item.name.toLowerCase().includes(this.searchQuery.toLowerCase());

      let matchesDate = true;
      if (this.dateFrom) {
        const fromDate = new Date(this.dateFrom);
        matchesDate = matchesDate && item.date >= fromDate;
      }
      if (this.dateTo) {
        const toDate = new Date(this.dateTo);
        toDate.setHours(23, 59, 59, 999);
        matchesDate = matchesDate && item.date <= toDate;
      }

      return matchesSearch && matchesDate;
    });
  }

  // ... rest of your existing methods remain the same
}













<!-- Add loading indicator after filter panels -->
<div class="loading-container" *ngIf="isLoading">
    <div class="spinner"></div>
    <p>Loading history...</p>
</div>

<!-- Add error message -->
<div class="error-container" *ngIf="error">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
        stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round"
            d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" />
    </svg>
    <p>{{ error }}</p>
</div>

<!-- Modified history item with cursor and badge -->
<div class="history-item" *ngFor="let item of filteredHistory"
    [class.selected]="selectedHistoryItem?.id === item.id"
    [class.not-clickable]="!item.isClickable"
    (click)="onHistoryItemClick(item)">
    <div class="history-item-icon">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
            stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round"
                d="M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5.25 5.25 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z" />
        </svg>
    </div>
    <div class="history-item-details">
        <div class="history-item-header">
            <h4 class="history-item-name">{{ item.name }}</h4>
            <span class="status-badge" [class]="'badge-' + item.status">
                {{ item.status === 'not-generated' ? 'Not Generated' : 
                   item.status === 'in-progress' ? 'In Progress' : 'Completed' }}
            </span>
        </div>
        <p class="history-item-date">{{ item.displayDate }}</p>
    </div>
    <div class="history-item-checkmark" *ngIf="selectedHistoryItem?.id === item.id && item.isClickable">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5"
            stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" />
        </svg>
    </div>
    <button class="history-item-action" *ngIf="selectedHistoryItem?.id !== item.id && item.isClickable"
        (click)="$event.stopPropagation()">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
            stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
        </svg>
    </button>
</div>













/* Loading Container */
.loading-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 48px 24px;
    text-align: center;
}

.spinner {
    width: 40px;
    height: 40px;
    border: 3px solid rgba(139, 92, 246, 0.2);
    border-top-color: var(--primary-color);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin-bottom: 16px;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.loading-container p {
    font-size: 14px;
    color: var(--text-color);
    opacity: 0.7;
    margin: 0;
}

/* Error Container */
.error-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 48px 24px;
    text-align: center;
    background-color: rgba(239, 68, 68, 0.1);
    border: 1px solid rgba(239, 68, 68, 0.3);
    border-radius: 8px;
    margin-bottom: 16px;
}

.error-container svg {
    width: 48px;
    height: 48px;
    stroke: #ef4444;
    margin-bottom: 16px;
}

.error-container p {
    font-size: 14px;
    color: #ef4444;
    margin: 0;
}

/* Not Clickable State */
.history-item.not-clickable {
    cursor: not-allowed;
    opacity: 0.6;
}

.history-item.not-clickable:hover {
    border-color: var(--border-color);
    box-shadow: none;
    transform: none;
}

/* History Item Header with Badge */
.history-item-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 4px;
}

.history-item-name {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-color);
    margin: 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    transition: color 0.2s ease, font-weight 0.2s ease;
    flex: 1;
    min-width: 0;
}

/* Status Badge */
.status-badge {
    font-size: 10px;
    font-weight: 600;
    padding: 3px 8px;
    border-radius: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    flex-shrink: 0;
    white-space: nowrap;
}

.badge-not-generated {
    background-color: rgba(239, 68, 68, 0.1);
    color: #ef4444;
    border: 1px solid rgba(239, 68, 68, 0.3);
}

.badge-in-progress {
    background-color: rgba(251, 191, 36, 0.1);
    color: #f59e0b;
    border: 1px solid rgba(251, 191, 36, 0.3);
}

.badge-completed {
    background-color: rgba(34, 197, 94, 0.1);
    color: #22c55e;
    border: 1px solid rgba(34, 197, 94, 0.3);
}

/* Update history-item-details to remove margin from name */
.history-item-details {
    flex: 1;
    min-width: 0;
}
