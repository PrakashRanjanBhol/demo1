.image-preview-container {
  height: 100%;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--adk-artifact-view-image-container-bg);
  position: absolute;
  top: 0;
  left: 0;
  overflow: auto;
  padding: 20px;
  box-sizing: border-box;
}

.image-wrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: min-content;
  min-height: min-content;
}

.preview-image {
  display: block;
  max-width: none;
  max-height: none;
  object-fit: contain;
  transform-origin: center center;
  transition: transform 0.2s ease;
}

.preview-image.zoomed {
  max-width: none;
  max-height: none;
}








private applyZoom() {
  const imgContainer = document.getElementById('image-preview-container');
  if (imgContainer) {
    const img = imgContainer.querySelector('.preview-image') as HTMLImageElement;
    if (img) {
      // Store scroll position relative to center
      const scrollLeft = imgContainer.scrollLeft;
      const scrollTop = imgContainer.scrollTop;
      const containerWidth = imgContainer.clientWidth;
      const containerHeight = imgContainer.clientHeight;
      const scrollWidth = imgContainer.scrollWidth;
      const scrollHeight = imgContainer.scrollHeight;
      
      // Calculate center position before zoom
      const centerX = (scrollLeft + containerWidth / 2) / scrollWidth;
      const centerY = (scrollTop + containerHeight / 2) / scrollHeight;
      
      // Apply zoom
      img.style.transform = `scale(${this.zoomLevel})`;
      
      // Add/remove zoomed class
      if (this.zoomLevel > 1) {
        img.classList.add('zoomed');
      } else {
        img.classList.remove('zoomed');
      }
      
      // Wait for transform to complete
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          // Calculate new scroll position to maintain center
          const newScrollWidth = imgContainer.scrollWidth;
          const newScrollHeight = imgContainer.scrollHeight;
          const newScrollLeft = centerX * newScrollWidth - containerWidth / 2;
          const newScrollTop = centerY * newScrollHeight - containerHeight / 2;
          
          // Apply new scroll position
          imgContainer.scrollLeft = newScrollLeft;
          imgContainer.scrollTop = newScrollTop;
        });
      });
    }
  }
}

private renderImage() {
  if (!this.previewFrame?.nativeElement) return;
  
  const iframe = this.previewFrame.nativeElement;
  
  // Hide iframe
  iframe.style.display = 'none';
  
  // Reset zoom level when rendering new image
  this.zoomLevel = 1;
  
  // Get or create image container
  let imgContainer = document.getElementById('image-preview-container');
  if (!imgContainer) {
    imgContainer = document.createElement('div');
    imgContainer.id = 'image-preview-container';
    imgContainer.className = 'image-preview-container';
    iframe.parentElement?.appendChild(imgContainer);
  }
  
  // Show container
  imgContainer.style.display = 'flex';
  
  // Show loader
  imgContainer.innerHTML = `
    <div class="loading-overlay">
      <div class="spinner"></div>
      <p style="margin-top: 20px; color: #666;">Loading image...</p>
    </div>
  `;
  
  try {
    const base64Content = this.convertUrlSafeBase64ToStandard(this.artifactVersion!.content);
    const dataUrl = this.createDataUrl(base64Content);
    
    // Create wrapper for the image
    const imgWrapper = document.createElement('div');
    imgWrapper.className = 'image-wrapper';
    
    const img = document.createElement('img');
    img.className = 'preview-image';
    img.alt = 'Artifact Image';
    
    img.onload = () => {
      const loader = imgContainer!.querySelector('.loading-overlay');
      if (loader) {
        loader.remove();
      }
      
      // Set initial size based on container
      const containerWidth = imgContainer!.clientWidth - 40; // Account for padding
      const containerHeight = imgContainer!.clientHeight - 40;
      const imgWidth = img.naturalWidth;
      const imgHeight = img.naturalHeight;
      
      // Calculate scale to fit image in container
      const scaleX = containerWidth / imgWidth;
      const scaleY = containerHeight / imgHeight;
      const initialScale = Math.min(scaleX, scaleY, 1); // Don't scale up initially
      
      // Set initial dimensions
      img.style.width = `${imgWidth * initialScale}px`;
      img.style.height = `${imgHeight * initialScale}px`;
      
      console.log('Image loaded successfully');
    };
    
    img.onerror = () => {
      imgContainer!.innerHTML = `
        <div class="error-message">
          <h3>⚠️ Image Loading Failed</h3>
          <p>Failed to load the image.</p>
          <p style="font-size: 12px; color: #999;">The image data may be corrupted or in an invalid format.</p>
        </div>
      `;
      console.error('Image failed to load');
    };
    
    const timeout = setTimeout(() => {
      if (imgContainer!.querySelector('.loading-overlay')) {
        imgContainer!.innerHTML = `
          <div class="error-message">
            <h3>⚠️ Image Loading Timeout</h3>
            <p>Image took too long to load.</p>
            <p style="font-size: 12px; color: #999;">The image may be too large or corrupted.</p>
          </div>
        `;
      }
    }, 10000);
    
    img.addEventListener('load', () => clearTimeout(timeout));
    
    img.src = dataUrl;
    imgWrapper.appendChild(img);
    imgContainer.appendChild(imgWrapper);
    
  } catch (error) {
    console.error('Error processing base64 image:', error);
    imgContainer.innerHTML = `
      <div class="error-message">
        <h3>⚠️ Image Processing Failed</h3>
        <p>Failed to process the base64 image data.</p>
        <p style="font-size: 12px; color: #999;">The image data may be in an invalid format.</p>
      </div>
    `;
  }
}
