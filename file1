import { Component, Input, OnInit, OnDestroy } from '@angular/core';

@Component({
  selector: 'app-ai-typing-animation',
  template: `
    <div class="typing-container" [class.minimal]="isMinimal">
      <div class="typing-indicator" *ngIf="showTypingDots">
        <div class="typing-dot" *ngFor="let dot of typingDots; let i = index"
             [style.animation-delay.s]="dot.delay"
             [style.background]="dot.color">
        </div>
      </div>

      <div class="generation-status" *ngIf="showStatus">
        <div class="pulse-icon">
          <div class="pulse-ring"></div>
          <div class="pulse-core"></div>
        </div>
        <span class="status-text">{{ statusText }}</span>
      </div>

      <div class="word-stream" *ngIf="showWordStream">
        <div class="stream-word" *ngFor="let word of streamWords; let i = index"
             [style.animation-delay.s]="word.delay">
          {{ word.text }}
        </div>
      </div>

      <div class="cursor-blink" *ngIf="showCursor">
        <span class="blinking-cursor">{{ cursorChar }}</span>
      </div>

      <div class="neural-activity" *ngIf="showNeuralActivity">
        <div class="activity-bar" *ngFor="let bar of activityBars; let i = index"
             [style.height.%]="bar.height"
             [style.animation-delay.s]="bar.delay"
             [style.background]="bar.color">
        </div>
      </div>
    </div>
  `,
  styles: [`
    .typing-container {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 0;
      min-height: 32px;
    }

    .typing-container.minimal {
      gap: 8px;
      min-height: 20px;
    }

    /* Typing Dots Animation */
    .typing-indicator {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .typing-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #8b5cf6;
      animation: typingBounce 1.4s infinite ease-in-out;
    }

    /* Generation Status with Pulse */
    .generation-status {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #999;
      font-size: 12px;
    }

    .pulse-icon {
      position: relative;
      width: 12px;
      height: 12px;
    }

    .pulse-core {
      position: absolute;
      width: 6px;
      height: 6px;
      background: #8b5cf6;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .pulse-ring {
      position: absolute;
      width: 12px;
      height: 12px;
      border: 1px solid #8b5cf6;
      border-radius: 50%;
      top: 0;
      left: 0;
      animation: pulseRing 2s infinite ease-out;
    }

    .status-text {
      font-weight: 500;
    }

    /* Word Stream Animation */
    .word-stream {
      display: flex;
      gap: 6px;
      overflow: hidden;
    }

    .stream-word {
      color: #666;
      font-size: 11px;
      opacity: 0;
      transform: translateX(-10px);
      animation: wordFlow 2s infinite ease-out;
      white-space: nowrap;
    }

    /* Blinking Cursor */
    .cursor-blink {
      display: flex;
      align-items: center;
    }

    .blinking-cursor {
      color: #8b5cf6;
      font-size: 16px;
      font-weight: bold;
      animation: cursorBlink 1s infinite;
    }

    /* Neural Activity Bars */
    .neural-activity {
      display: flex;
      gap: 2px;
      align-items: end;
      height: 20px;
    }

    .activity-bar {
      width: 3px;
      background: #8b5cf6;
      border-radius: 1px;
      animation: activityPulse 1.2s infinite ease-in-out;
    }

    /* Animations */
    @keyframes typingBounce {
      0%, 80%, 100% {
        transform: scale(0.8);
        opacity: 0.5;
      }
      40% {
        transform: scale(1.2);
        opacity: 1;
      }
    }

    @keyframes pulseRing {
      0% {
        transform: scale(0.8);
        opacity: 1;
      }
      100% {
        transform: scale(2);
        opacity: 0;
      }
    }

    @keyframes wordFlow {
      0% {
        opacity: 0;
        transform: translateX(-10px);
      }
      20%, 80% {
        opacity: 0.7;
        transform: translateX(0);
      }
      100% {
        opacity: 0;
        transform: translateX(10px);
      }
    }

    @keyframes cursorBlink {
      0%, 50% {
        opacity: 1;
      }
      51%, 100% {
        opacity: 0;
      }
    }

    @keyframes activityPulse {
      0%, 100% {
        height: 20%;
      }
      50% {
        height: 100%;
      }
    }

    /* Responsive adjustments */
    .typing-container.minimal .typing-dot {
      width: 4px;
      height: 4px;
    }

    .typing-container.minimal .status-text {
      font-size: 11px;
    }

    .typing-container.minimal .pulse-icon {
      width: 10px;
      height: 10px;
    }

    .typing-container.minimal .pulse-core {
      width: 4px;
      height: 4px;
    }

    .typing-container.minimal .pulse-ring {
      width: 10px;
      height: 10px;
    }
  `]
})
export class AiTypingAnimationComponent implements OnInit, OnDestroy {
  @Input() animationType: 'dots' | 'pulse' | 'words' | 'cursor' | 'neural' | 'all' = 'all';
  @Input() statusText: string = 'Generating response...';
  @Input() cursorChar: string = '|';
  @Input() isMinimal: boolean = false;
  @Input() customColors: string[] = [];
  @Input() customWords: string[] = [];

  // Animation visibility flags
  showTypingDots: boolean = true;
  showStatus: boolean = true;
  showWordStream: boolean = true;
  showCursor: boolean = true;
  showNeuralActivity: boolean = true;

  typingDots: Array<{delay: number, color: string}> = [];
  streamWords: Array<{text: string, delay: number}> = [];
  activityBars: Array<{height: number, delay: number, color: string}> = [];

  private defaultColors = ['#8b5cf6', '#06b6d4', '#00ff88', '#ff6b6b', '#ffd93d'];
  private defaultWords = ['crafting', 'words', 'flowing', 'ideas', 'forming'];

  ngOnInit() {
    this.setupAnimationType();
    this.initializeElements();
  }

  ngOnDestroy() {
    // Cleanup if needed
  }

  private setupAnimationType() {
    // Reset all visibility
    this.showTypingDots = false;
    this.showStatus = false;
    this.showWordStream = false;
    this.showCursor = false;
    this.showNeuralActivity = false;

    // Enable based on animation type
    switch (this.animationType) {
      case 'dots':
        this.showTypingDots = true;
        break;
      case 'pulse':
        this.showStatus = true;
        break;
      case 'words':
        this.showWordStream = true;
        break;
      case 'cursor':
        this.showCursor = true;
        break;
      case 'neural':
        this.showNeuralActivity = true;
        break;
      case 'all':
      default:
        this.showTypingDots = true;
        this.showStatus = true;
        break;
    }
  }

  private initializeElements() {
    const colors = this.customColors.length > 0 ? this.customColors : this.defaultColors;
    const words = this.customWords.length > 0 ? this.customWords : this.defaultWords;

    // Initialize typing dots
    this.typingDots = Array(3).fill(0).map((_, i) => ({
      delay: i * 0.2,
      color: colors[i % colors.length]
    }));

    // Initialize stream words
    this.streamWords = words.map((word, i) => ({
      text: word,
      delay: i * 0.4
    }));

    // Initialize activity bars
    this.activityBars = Array(8).fill(0).map((_, i) => ({
      height: Math.random() * 60 + 20,
      delay: i * 0.1,
      color: colors[i % colors.length]
    }));
  }

  // Public methods for dynamic control
  setAnimationType(type: 'dots' | 'pulse' | 'words' | 'cursor' | 'neural' | 'all') {
    this.animationType = type;
    this.setupAnimationType();
  }

  updateStatus(newStatus: string) {
    this.statusText = newStatus;
  }

  updateColors(newColors: string[]) {
    this.customColors = newColors;
    this.initializeElements();
  }

  updateWords(newWords: string[]) {
    this.customWords = newWords;
    this.initializeElements();
  }

  // Method to show/hide the entire component
  setVisible(visible: boolean) {
    // This could be used to show/hide the component
    // Implementation depends on parent component needs
  }

  // Restart animations
  restartAnimations() {
    this.initializeElements();
  }
}
