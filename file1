<!-- Updated Date Range Picker Section - Replace only the .date-range-section div -->

<div class="date-range-section">
  <label class="filter-label">
    <svg class="label-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
    </svg>
    Date Range
  </label>
  <div class="date-range-inputs">
    <div class="date-input-wrapper">
      <input 
        type="date" 
        class="date-input" 
        [(ngModel)]="startDate"
        [max]="endDate || undefined"
        readonly
        (click)="openDatePicker($event)">
    </div>
    <span class="date-separator">to</span>
    <div class="date-input-wrapper">
      <input 
        type="date" 
        class="date-input" 
        [(ngModel)]="endDate"
        [min]="startDate || undefined"
        readonly
        (click)="openDatePicker($event)">
    </div>
  </div>
  <div class="date-actions">
    <button 
      class="apply-dates-btn" 
      [disabled]="!startDate && !endDate"
      (click)="applyDateFilter()">
      <svg class="apply-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
      </svg>
      Apply
    </button>
    <button 
      class="clear-dates-btn" 
      *ngIf="startDate || endDate"
      (click)="clearDateRange()">
      <svg class="clear-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
      </svg>
      Clear
    </button>
  </div>
</div>















/* Updated CSS for Date Input - Add/Replace these styles */

.date-range-section {
  margin-bottom: 12px;
}

.filter-label {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  font-weight: 600;
  color: var(--bitbucket-prs-text-secondary);
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.label-icon {
  width: 14px;
  height: 14px;
  color: var(--bitbucket-prs-accent-primary);
}

.date-range-inputs {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.date-input-wrapper {
  position: relative;
  flex: 1;
}

.date-input {
  width: 100%;
  padding: 10px 12px;
  background: var(--bitbucket-prs-bg-secondary);
  border: 1px solid var(--bitbucket-prs-border-primary);
  border-radius: 6px;
  color: var(--bitbucket-prs-text-secondary);
  font-size: 12px;
  outline: none;
  transition: all 0.2s;
  cursor: pointer; /* Show pointer cursor */
}

/* Remove text cursor when readonly */
.date-input[readonly] {
  cursor: pointer;
  user-select: none; /* Prevent text selection */
}

.date-input::-webkit-calendar-picker-indicator {
  cursor: pointer;
  filter: invert(0.7);
  opacity: 0.8;
}

.date-input::-webkit-calendar-picker-indicator:hover {
  opacity: 1;
}

/* Light mode calendar icon */
[data-theme="light"] .date-input::-webkit-calendar-picker-indicator {
  filter: invert(0.5);
}

.date-input::placeholder {
  color: var(--bitbucket-prs-text-muted);
}

.date-input:focus {
  background: var(--bitbucket-prs-bg-hover);
  border-color: var(--bitbucket-prs-accent-primary);
  box-shadow: var(--bitbucket-prs-shadow-focus);
}

/* Hover effect for readonly inputs */
.date-input[readonly]:hover {
  background: var(--bitbucket-prs-bg-hover);
  border-color: var(--bitbucket-prs-border-secondary);
}

.date-separator {
  font-size: 11px;
  color: var(--bitbucket-prs-text-tertiary);
  font-weight: 500;
  padding: 0 2px;
}

.date-actions {
  display: flex;
  gap: 6px;
}

.apply-dates-btn {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 8px 12px;
  background: var(--bitbucket-prs-accent-gradient);
  border: none;
  border-radius: 6px;
  color: #fff;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.apply-dates-btn:hover:not(:disabled) {
  opacity: 0.9;
  transform: translateY(-1px);
}

.apply-dates-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

.apply-icon {
  width: 16px;
  height: 16px;
}

.clear-dates-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 8px 12px;
  background: transparent;
  border: 1px solid var(--bitbucket-prs-border-primary);
  border-radius: 6px;
  color: var(--bitbucket-prs-text-tertiary);
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.clear-dates-btn:hover {
  background: var(--bitbucket-prs-bg-hover);
  border-color: var(--bitbucket-prs-border-secondary);
  color: var(--bitbucket-prs-text-secondary);
}

.clear-icon {
  width: 14px;
  height: 14px;
}
















// Add this method to your component class

export class PrSidebarComponent implements OnInit {
  // ... existing properties and methods ...

  // Method to open date picker when clicking on readonly input
  openDatePicker(event: Event): void {
    const input = event.target as HTMLInputElement;
    
    // For browsers that support showPicker() method (Chrome 99+, Edge 99+, etc.)
    if ('showPicker' in HTMLInputElement.prototype) {
      try {
        input.showPicker();
      } catch (error) {
        // If showPicker fails (e.g., user gesture required), fall back to click
        console.warn('showPicker failed, using fallback');
        this.fallbackDatePicker(input);
      }
    } else {
      // Fallback for older browsers
      this.fallbackDatePicker(input);
    }
  }

  // Fallback method for browsers that don't support showPicker()
  private fallbackDatePicker(input: HTMLInputElement): void {
    // Remove readonly temporarily to allow picker to open
    input.removeAttribute('readonly');
    
    // Trigger focus to open the picker
    input.focus();
    
    // Re-add readonly after a short delay
    setTimeout(() => {
      input.setAttribute('readonly', 'true');
    }, 100);
  }

  // ... rest of your existing methods ...
}
