import { Component, OnInit, ChangeDetectorRef, ViewChild, ElementRef, SecurityContext } from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { ChunkedJsonParserService, ToolData, ApprovalRequest } from './chunked-json-parser.service';
import { marked } from 'marked';

declare var hljs: any;

interface ExecutionFlowItem {
  tool: string;
  fileName?: string;
  status: 'executing' | 'completed' | 'rejected' | 'pending';
  timestamp: Date;
}

@Component({
  selector: 'vibe-coding-chunked-json-parser',
  templateUrl: './chunked-json-parser.component.html',
  styleUrls: ['./chunked-json-parser.component.css'],
  animations: [
    trigger('fadeIn', [
      state('void', style({ opacity: 0 })),
      state('*', style({ opacity: 1 })),
      transition('void => *', animate('300ms ease-out')),
      transition('* => void', animate('300ms ease-in'))
    ])
  ]
})
export class ChunkedJsonParserComponent implements OnInit {
  @ViewChild('readContentContainer', { read: ElementRef }) readContentRef!: ElementRef;

  // State management
  public isProcessing = false;
  public isCompleted = false;
  public hasReceivedFirstChunk = false;
  
  // Current view state
  public currentView: 'read' | 'approval' = 'read';
  public readContents: SafeHtml[] = [];
  
  // Approval state
  public currentApprovalRequest: ApprovalRequest | null = null;
  public isApprovingChanges = false;
  
  // Execution flow
  public executionFlow: ExecutionFlowItem[] = [];
  public queuedItems: ToolData[] = [];

  constructor(
    private parserService: ChunkedJsonParserService,
    private cdr: ChangeDetectorRef,
    private http: HttpClient,
    private sanitizer: DomSanitizer
  ) {
    this.configureMarked();
  }

  ngOnInit(): void {
    // Setup will happen on RUN click
  }

  private configureMarked(): void {
    marked.setOptions({
      highlight: (code: string, lang: string) => {
        if (lang && typeof hljs !== 'undefined' && hljs.getLanguage(lang)) {
          try {
            return hljs.highlight(code, { language: lang }).value;
          } catch (e) {
            console.warn('Highlight error:', e);
          }
        }
        return code;
      },
      breaks: true,
      gfm: true
    });
  }

  private setupCallbacks(): void {
    this.parserService.setCallbacks({
      onToolDetected: (toolData: ToolData) => {
        console.log('üîπ Tool detected:', toolData);
        
        if (toolData.tool === 'READ') {
          this.handleReadTool(toolData);
        } else {
          this.addToExecutionFlow(toolData, 'executing');
        }
        
        this.updateQueuedItems();
      },
      
      onApprovalRequest: (approvalRequest: ApprovalRequest) => {
        console.log('‚ö†Ô∏è APPROVAL REQUESTED:', approvalRequest.data);
        this.currentApprovalRequest = approvalRequest;
        this.currentView = 'approval';
        this.cdr.detectChanges();
      },
      
      onCompletion: () => {
        console.log('üéâ COMPLETED');
        this.isProcessing = false;
        this.isCompleted = true;
        this.currentView = 'read';
        this.cdr.detectChanges();
      },
      
      onError: (error: string) => {
        console.error('‚ùå Error:', error);
        this.isProcessing = false;
        this.cdr.detectChanges();
      },
      
      onFirstChunk: () => {
        console.log('üì¶ First chunk received');
        this.hasReceivedFirstChunk = true;
        this.cdr.detectChanges();
      }
    });
  }

  private handleReadTool(toolData: ToolData): void {
    const content = typeof toolData.content === 'string' ? toolData.content : '';
    
    if (content) {
      try {
        // Parse markdown and sanitize
        const htmlContent = marked.parse(content) as string;
        const safeHtml = this.sanitizer.sanitize(SecurityContext.HTML, htmlContent);
        
        if (safeHtml) {
          this.readContents.push(this.sanitizer.bypassSecurityTrustHtml(safeHtml));
          this.addToExecutionFlow(toolData, 'completed');
          this.scrollReadToBottom();
        }
      } catch (e) {
        console.error('Markdown parse error:', e);
      }
    }
  }

  private addToExecutionFlow(toolData: ToolData, status: ExecutionFlowItem['status']): void {
    const fileName = this.getFileName(toolData);
    
    this.executionFlow.push({
      tool: toolData.tool,
      fileName,
      status,
      timestamp: new Date()
    });
  }

  private updateExecutionFlowStatus(tool: string, fileName: string | undefined, status: ExecutionFlowItem['status']): void {
    const item = this.executionFlow.find(f => f.tool === tool && f.fileName === fileName && f.status === 'executing');
    if (item) {
      item.status = status;
    }
  }

  private getFileName(toolData: ToolData): string | undefined {
    if (toolData.content && typeof toolData.content === 'object') {
      const fileDetails = this.getFileDetails(toolData.content);
      return fileDetails?.file_name;
    }
    return undefined;
  }

  private updateQueuedItems(): void {
    this.queuedItems = this.parserService.getPendingTools();
  }

  private scrollReadToBottom(): void {
    setTimeout(() => {
      if (this.readContentRef?.nativeElement) {
        this.readContentRef.nativeElement.scrollTop = this.readContentRef.nativeElement.scrollHeight;
      }
    }, 100);
  }

  public async runDemo(): Promise<void> {
    console.clear();
    console.log('üöÄ Starting streaming process...\n');
    
    // Reset state
    this.readContents = [];
    this.executionFlow = [];
    this.queuedItems = [];
    this.currentApprovalRequest = null;
    this.currentView = 'read';
    this.isProcessing = true;
    this.isCompleted = false;
    this.hasReceivedFirstChunk = false;
    this.isApprovingChanges = false;
    
    this.setupCallbacks();
    
    try {
      await this.parserService.startStreaming();
    } catch (error) {
      if (error instanceof Error && error.name !== 'AbortError') {
        console.error('Failed to start streaming:', error);
      }
      this.isProcessing = false;
    }
  }

  public stopStreaming(): void {
    console.log('üõë Stopping streaming...');
    this.parserService.stopStreaming();
    this.isProcessing = false;
    this.cdr.detectChanges();
  }

  public async approveAndContinue(): Promise<void> {
    if (!this.currentApprovalRequest || this.isApprovingChanges) return;
    
    console.log('‚úÖ APPROVED:', this.currentApprovalRequest.data);
    this.isApprovingChanges = true;
    this.cdr.detectChanges();
    
    try {
      const fileDetails = this.getFileDetails(this.currentApprovalRequest.data.content);
      
      if (fileDetails) {
        const payload = {
          tool: this.currentApprovalRequest.data.tool,
          file_path: fileDetails.file_path,
          file_name: fileDetails.file_name,
          original_code: fileDetails.original_code || '',
          modified_code: fileDetails.modified_code || '',
          reasoning: this.getReasoning(this.currentApprovalRequest.data.content),
          timestamp: new Date().toISOString()
        };
        
        await this.saveCodeChanges(payload);
      }
      
      // Update execution flow
      this.updateExecutionFlowStatus(
        this.currentApprovalRequest.data.tool,
        fileDetails?.file_name,
        'completed'
      );
      
      // Reset and continue
      this.currentApprovalRequest = null;
      this.currentView = 'read';
      this.cdr.detectChanges();
      
      requestAnimationFrame(() => {
        this.parserService.approveAndContinue();
        this.updateQueuedItems();
      });
      
    } catch (error) {
      console.error('‚ùå Failed to save:', error);
      alert('Failed to save code changes. Please try again.');
    } finally {
      setTimeout(() => {
        this.isApprovingChanges = false;
        this.cdr.detectChanges();
      }, 300);
    }
  }

  public rejectChanges(): void {
    if (!this.currentApprovalRequest) return;
    
    console.log('‚ùå REJECTED:', this.currentApprovalRequest.data);
    
    const fileDetails = this.getFileDetails(this.currentApprovalRequest.data.content);
    
    // Update execution flow
    this.updateExecutionFlowStatus(
      this.currentApprovalRequest.data.tool,
      fileDetails?.file_name,
      'rejected'
    );
    
    // Reset and continue
    this.currentApprovalRequest = null;
    this.currentView = 'read';
    this.cdr.detectChanges();
    
    requestAnimationFrame(() => {
      this.parserService.approveAndContinue();
      this.updateQueuedItems();
    });
  }

  private async saveCodeChanges(payload: any): Promise<void> {
    const apiUrl = 'https://your-api-endpoint.com/api/save-code';
    
    const headers = new HttpHeaders({
      'Content-Type': 'application/json'
    });
    
    return new Promise((resolve, reject) => {
      this.http.post(apiUrl, payload, { headers }).subscribe({
        next: (response) => {
          console.log('API Response:', response);
          resolve();
        },
        error: (error) => {
          console.error('API Error:', error);
          reject(error);
        }
      });
    });
  }

  // Helper methods
  public getFileDetails(content: any): any {
    if (!content || typeof content !== 'object') return null;
    
    if (content.files && Array.isArray(content.files) && content.files.length > 0) {
      return content.files[0];
    }
    
    return null;
  }

  public getReasoning(content: any): string {
    if (content && typeof content === 'object' && content.reasoning) {
      return content.reasoning;
    }
    return '';
  }

  public getFileExtension(filename: string): string {
    if (!filename) return 'FILE';
    return filename.split('.').pop()?.toUpperCase() || 'FILE';
  }

  public getLanguageFromFilename(filename: string): string {
    if (!filename) return 'plaintext';
    
    const ext = filename.split('.').pop()?.toLowerCase();
    const langMap: { [key: string]: string } = {
      'js': 'javascript', 'jsx': 'javascript', 'ts': 'typescript', 'tsx': 'typescript',
      'py': 'python', 'java': 'java', 'cpp': 'cpp', 'c': 'c', 'cs': 'csharp',
      'php': 'php', 'rb': 'ruby', 'go': 'go', 'rs': 'rust', 'swift': 'swift',
      'kt': 'kotlin', 'sql': 'sql', 'html': 'html', 'css': 'css', 'scss': 'scss',
      'json': 'json', 'xml': 'xml', 'yaml': 'yaml', 'yml': 'yaml', 'md': 'markdown',
      'sh': 'bash', 'bash': 'bash'
    };
    
    return langMap[ext || ''] || 'plaintext';
  }

  public getDiffHtml(originalCode: string, modifiedCode: string, filename: string): SafeHtml {
    const original = (originalCode || '').split('\n');
    const modified = (modifiedCode || '').split('\n');
    const language = this.getLanguageFromFilename(filename);
    
    if (original.length > 1000 || modified.length > 1000) {
      return this.sanitizer.bypassSecurityTrustHtml('<div class="vibe-diff-line">File too large to display diff (>1000 lines)</div>');
    }
    
    const diff = this.computeDiff(original, modified);
    let diffHtml = '';
    let originalLineNum = 1;
    let modifiedLineNum = 1;
    
    for (const block of diff) {
      if (block.type === 'unchanged') {
        for (const line of block.lines || []) {
          const highlightedCode = this.highlightCode(line, language);
          diffHtml += `<div class="vibe-diff-line vibe-diff-unchanged">`;
          diffHtml += `<span class="vibe-line-number">${originalLineNum}</span>`;
          diffHtml += `<span class="vibe-line-number">${modifiedLineNum}</span>`;
          diffHtml += `<span class="vibe-line-prefix">  </span>`;
          diffHtml += `<span class="vibe-line-content">${highlightedCode}</span>`;
          diffHtml += `</div>`;
          originalLineNum++;
          modifiedLineNum++;
        }
      } else if (block.type === 'changed') {
        for (const line of block.removed || []) {
          const highlightedCode = this.highlightCode(line, language);
          diffHtml += `<div class="vibe-diff-line vibe-diff-removed">`;
          diffHtml += `<span class="vibe-line-number">${originalLineNum}</span>`;
          diffHtml += `<span class="vibe-line-number"></span>`;
          diffHtml += `<span class="vibe-line-prefix">- </span>`;
          diffHtml += `<span class="vibe-line-content">${highlightedCode}</span>`;
          diffHtml += `</div>`;
          originalLineNum++;
        }
        
        for (const line of block.added || []) {
          const highlightedCode = this.highlightCode(line, language);
          diffHtml += `<div class="vibe-diff-line vibe-diff-added">`;
          diffHtml += `<span class="vibe-line-number"></span>`;
          diffHtml += `<span class="vibe-line-number">${modifiedLineNum}</span>`;
          diffHtml += `<span class="vibe-line-prefix">+ </span>`;
          diffHtml += `<span class="vibe-line-content">${highlightedCode}</span>`;
          diffHtml += `</div>`;
          modifiedLineNum++;
        }
      }
    }
    
    return this.sanitizer.bypassSecurityTrustHtml(diffHtml);
  }

  private computeDiff(original: string[], modified: string[]): Array<{type: 'unchanged' | 'changed', lines?: string[], removed?: string[], added?: string[]}> {
    const diff: Array<{type: 'unchanged' | 'changed', lines?: string[], removed?: string[], added?: string[]}> = [];
    const maxLen = Math.max(original.length, modified.length);
    let i = 0;
    
    while (i < maxLen) {
      const origLine = i < original.length ? original[i] : null;
      const modLine = i < modified.length ? modified[i] : null;
      
      if (origLine === modLine && origLine !== null) {
        const unchangedLines: string[] = [];
        while (i < maxLen && i < original.length && i < modified.length && original[i] === modified[i]) {
          unchangedLines.push(original[i]);
          i++;
        }
        diff.push({ type: 'unchanged', lines: unchangedLines });
      } else {
        const removedLines: string[] = [];
        const addedLines: string[] = [];
        
        while (i < maxLen && (i >= original.length || i >= modified.length || original[i] !== modified[i])) {
          if (i < original.length) removedLines.push(original[i]);
          if (i < modified.length) addedLines.push(modified[i]);
          i++;
          
          if (i >= maxLen) break;
          if (i < original.length && i < modified.length && original[i] === modified[i]) break;
        }
        
        if (removedLines.length > 0 || addedLines.length > 0) {
          diff.push({ type: 'changed', removed: removedLines, added: addedLines });
        }
      }
    }
    
    return diff;
  }

  private highlightCode(code: string, language: string): string {
    if (!code || typeof hljs === 'undefined') {
      return this.escapeHtml(code);
    }
    
    try {
      if (language !== 'plaintext' && hljs.getLanguage(language)) {
        const result = hljs.highlight(code, { language: language, ignoreIllegals: true });
        return result.value;
      }
    } catch (e) {
      return this.escapeHtml(code);
    }
    
    return this.escapeHtml(code);
  }

  private escapeHtml(text: string): string {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  public formatTime(date: Date): string {
    return date.toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  }

  public getExecutionFlowIcon(tool: string): string {
    const icons: { [key: string]: string } = {
      'READ': 'üìñ',
      'WRITE': '‚úèÔ∏è',
      'MODIFY': 'üîß'
    };
    return icons[tool] || 'üîπ';
  }

  public getStatusClass(status: ExecutionFlowItem['status']): string {
    const classes: { [key: string]: string } = {
      'executing': 'vibe-status-executing',
      'completed': 'vibe-status-completed',
      'rejected': 'vibe-status-rejected',
      'pending': 'vibe-status-pending'
    };
    return classes[status] || '';
  }
}














<div class="vibe-container">
  <!-- Header -->
  <div class="vibe-header">
    <div class="vibe-header-content">
      <div class="vibe-header-left">
        <h1>AI Execution Tracker</h1>
        <p>Real-time code generation & execution monitoring</p>
      </div>
      
      <div class="vibe-header-right">
        <button 
          class="vibe-btn vibe-btn-primary" 
          (click)="runDemo()" 
          [disabled]="isProcessing">
          RUN
        </button>

        <span *ngIf="isProcessing && !isCompleted" class="vibe-badge vibe-badge-processing">
          <span class="vibe-pulse-dot"></span>
          Processing
        </span>

        <span *ngIf="isCompleted" class="vibe-badge vibe-badge-completed">
          <span class="vibe-check-icon">‚úì</span>
          Completed
        </span>

        <button 
          *ngIf="isProcessing && !isCompleted"
          class="vibe-btn-stop" 
          (click)="stopStreaming()"
          title="Stop">
          <svg viewBox="0 0 24 24" fill="none">
            <rect x="6" y="6" width="12" height="12" fill="currentColor" rx="2"/>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <!-- Main Content -->
  <div class="vibe-content">
    <!-- Left Panel: READ Content (80%) -->
    <div class="vibe-read-panel">
      <!-- Empty State -->
      <div *ngIf="readContents.length === 0 && !isProcessing && currentView === 'read'" class="vibe-empty-state">
        <div class="vibe-empty-icon">üìÑ</div>
        <p>No content yet</p>
        <span>Click RUN to start</span>
      </div>

      <!-- Waiting State -->
      <div *ngIf="isProcessing && !hasReceivedFirstChunk" class="vibe-waiting-state">
        <div class="vibe-spinner"></div>
        <h3>Connecting to AI Agent<span class="vibe-dots"><span>.</span><span>.</span><span>.</span></span></h3>
        <p>Preparing execution plan</p>
      </div>

      <!-- READ Content Display -->
      <div 
        *ngIf="currentView === 'read' && readContents.length > 0" 
        class="vibe-read-content"
        #readContentContainer
        [@fadeIn]>
        <div 
          *ngFor="let content of readContents; trackBy: trackByIndex" 
          class="vibe-read-item"
          [innerHTML]="content">
        </div>
      </div>

      <!-- WRITE/MODIFY Approval View -->
      <div 
        *ngIf="currentView === 'approval' && currentApprovalRequest" 
        class="vibe-approval-view"
        [@fadeIn]>
        <div class="vibe-approval-header">
          <div class="vibe-approval-title">
            <span class="vibe-approval-icon">{{ getFileExtension(getFileDetails(currentApprovalRequest.data.content)?.file_name) }}</span>
            <div class="vibe-approval-info">
              <h3>{{ getFileDetails(currentApprovalRequest.data.content)?.file_name }}</h3>
              <p *ngIf="getFileDetails(currentApprovalRequest.data.content)?.file_path">
                {{ getFileDetails(currentApprovalRequest.data.content)?.file_path }}
              </p>
            </div>
            <span class="vibe-approval-badge">{{ currentApprovalRequest.data.tool }}</span>
          </div>
        </div>

        <!-- Reasoning -->
        <div *ngIf="getReasoning(currentApprovalRequest.data.content)" class="vibe-reasoning">
          <h4>Reasoning</h4>
          <p>{{ getReasoning(currentApprovalRequest.data.content) }}</p>
        </div>

        <!-- Code Diff -->
        <div class="vibe-diff-container">
          <div class="vibe-diff-header">
            <span>Changes in {{ getFileDetails(currentApprovalRequest.data.content)?.file_name }}</span>
          </div>
          <div class="vibe-diff-content">
            <pre><code 
              [innerHTML]="getDiffHtml(
                getFileDetails(currentApprovalRequest.data.content)?.original_code || '', 
                getFileDetails(currentApprovalRequest.data.content)?.modified_code || '',
                getFileDetails(currentApprovalRequest.data.content)?.file_name || ''
              )">
            </code></pre>
          </div>
        </div>

        <!-- Actions -->
        <div class="vibe-approval-actions">
          <button 
            class="vibe-btn vibe-btn-reject" 
            (click)="rejectChanges()"
            [disabled]="isApprovingChanges">
            ‚úï Reject
          </button>
          <button 
            class="vibe-btn vibe-btn-accept" 
            (click)="approveAndContinue()"
            [disabled]="isApprovingChanges">
            <span *ngIf="!isApprovingChanges">‚úì Accept & Continue</span>
            <span *ngIf="isApprovingChanges" class="vibe-accepting">
              <span class="vibe-spinner-small"></span>
              Accepting...
            </span>
          </button>
        </div>
      </div>
    </div>

    <!-- Right Panel: Execution Flow (20%) -->
    <div class="vibe-flow-panel">
      <div class="vibe-flow-header">
        <h2>Execution Flow</h2>
        <span class="vibe-flow-count">{{ executionFlow.length }}</span>
      </div>

      <div class="vibe-flow-content">
        <!-- Empty State -->
        <div *ngIf="executionFlow.length === 0" class="vibe-flow-empty">
          <div class="vibe-flow-empty-icon">‚ãØ</div>
          <p>No executions yet</p>
        </div>

        <!-- Flow Items -->
        <div 
          *ngFor="let item of executionFlow; trackBy: trackByIndex" 
          class="vibe-flow-item"
          [ngClass]="getStatusClass(item.status)"
          [@fadeIn]>
          <div class="vibe-flow-icon">{{ getExecutionFlowIcon(item.tool) }}</div>
          <div class="vibe-flow-info">
            <div class="vibe-flow-tool">{{ item.tool }}</div>
            <div *ngIf="item.fileName" class="vibe-flow-file">{{ item.fileName }}</div>
            <div class="vibe-flow-time">{{ formatTime(item.timestamp) }}</div>
          </div>
          <div class="vibe-flow-status">
            <span *ngIf="item.status === 'executing'" class="vibe-status-dot vibe-dot-executing"></span>
            <span *ngIf="item.status === 'completed'" class="vibe-status-dot vibe-dot-completed">‚úì</span>
            <span *ngIf="item.status === 'rejected'" class="vibe-status-dot vibe-dot-rejected">‚úï</span>
          </div>
        </div>

        <!-- Queued Items -->
        <div 
          *ngFor="let item of queuedItems; trackBy: trackByIndex" 
          class="vibe-flow-item vibe-flow-queued"
          [@fadeIn]>
          <div class="vibe-flow-icon">{{ getExecutionFlowIcon(item.tool) }}</div>
          <div class="vibe-flow-info">
            <div class="vibe-flow-tool">{{ item.tool }}</div>
            <div class="vibe-flow-status-text">Queued</div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



















/* CSS Variables */
:root {
  --vibe-bg-primary: #ffffff;
  --vibe-bg-secondary: #f8f9fa;
  --vibe-bg-tertiary: #f1f3f5;
  --vibe-text-primary: #1a1a1a;
  --vibe-text-secondary: #6c757d;
  --vibe-text-muted: #adb5bd;
  --vibe-border: #dee2e6;
  --vibe-blue: #3b82f6;
  --vibe-blue-light: #dbeafe;
  --vibe-green: #22c55e;
  --vibe-green-light: #d1fae5;
  --vibe-red: #ef4444;
  --vibe-red-light: #fee2e2;
  --vibe-yellow: #eab308;
  --vibe-diff-added-bg: #e6ffed;
  --vibe-diff-added-text: #24292e;
  --vibe-diff-removed-bg: #ffebe9;
  --vibe-diff-removed-text: #24292e;
}

[data-theme="dark"] {
  --vibe-bg-primary: #0a0a0b;
  --vibe-bg-secondary: #111113;
  --vibe-bg-tertiary: #1a1a1c;
  --vibe-text-primary: #e5e5e5;
  --vibe-text-secondary: #a3a3a3;
  --vibe-text-muted: #6c757d;
  --vibe-border: #27272a;
  --vibe-blue: #3b82f6;
  --vibe-blue-light: #1e293b;
  --vibe-green: #22c55e;
  --vibe-green-light: #064e3b;
  --vibe-red: #ef4444;
  --vibe-red-light: #450a0a;
  --vibe-yellow: #eab308;
  --vibe-diff-added-bg: #0d3a26;
  --vibe-diff-added-text: #a7f3d0;
  --vibe-diff-removed-bg: #3a0d0d;
  --vibe-diff-removed-text: #fca5a5;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

.vibe-container {
  width: 100%;
  height: 100vh;
  background: var(--vibe-bg-primary);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Header */
.vibe-header {
  background: var(--vibe-bg-secondary);
  padding: 20px 30px;
  border-bottom: 1px solid var(--vibe-border);
  flex-shrink: 0;
}

.vibe-header-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.vibe-header-left h1 {
  font-size: 1.75rem;
  color: var(--vibe-text-primary);
  margin-bottom: 4px;
  font-weight: 600;
}

.vibe-header-left p {
  color: var(--vibe-text-secondary);
  font-size: 0.9rem;
}

.vibe-header-right {
  display: flex;
  align-items: center;
  gap: 12px;
}

/* Buttons */
.vibe-btn {
  padding: 8px 16px;
  font-size: 14px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 500;
  transition: all 0.2s;
}

.vibe-btn-primary {
  background: var(--vibe-blue);
  color: white;
}

.vibe-btn-primary:hover:not(:disabled) {
  background: #2563eb;
}

.vibe-btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.vibe-btn-stop {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
  border: 2px solid var(--vibe-red);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
}

.vibe-btn-stop svg {
  width: 16px;
  height: 16px;
  color: var(--vibe-red);
}

.vibe-btn-stop:hover {
  background: var(--vibe-red);
}

.vibe-btn-stop:hover svg {
  color: white;
}

/* Badges */
.vibe-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 600;
}

.vibe-badge-processing {
  background: var(--vibe-blue-light);
  color: var(--vibe-blue);
  border: 1px solid var(--vibe-border);
}

.vibe-badge-completed {
  background: var(--vibe-green-light);
  color: var(--vibe-green);
  border: 1px solid var(--vibe-green);
}

.vibe-pulse-dot {
  width: 6px;
  height: 6px;
  background: var(--vibe-blue);
  border-radius: 50%;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.5; transform: scale(0.8); }
}

.vibe-check-icon {
  width: 14px;
  height: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--vibe-green);
  color: white;
  border-radius: 50%;
  font-size: 10px;
}

/* Main Content */
.vibe-content {
  flex: 1;
  display: flex;
  overflow: hidden;
}

/* Read Panel (80%) */
.vibe-read-panel {
  flex: 0 0 80%;
  background: var(--vibe-bg-primary);
  border-right: 1px solid var(--vibe-border);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.vibe-read-content {
  flex: 1;
  overflow-y: auto;
  padding: 30px;
}

.vibe-read-content::-webkit-scrollbar {
  width: 8px;
}

.vibe-read-content::-webkit-scrollbar-track {
  background: transparent;
}

.vibe-read-content::-webkit-scrollbar-thumb {
  background: var(--vibe-border);
  border-radius: 4px;
}

.vibe-read-item {
  margin-bottom: 24px;
  color: var(--vibe-text-primary);
  line-height: 1.7;
}

.vibe-read-item h1,
.vibe-read-item h2,
.vibe-read-item h3 {
  margin-top: 1.5em;
  margin-bottom: 0.5em;
  color: var(--vibe-text-primary);
}

.vibe-read-item p {
  margin-bottom: 1em;
}

.vibe-read-item pre {
  background: var(--vibe-bg-tertiary);
  padding: 16px;
  border-radius: 6px;
  overflow-x: auto;
  margin: 1em 0;
  border: 1px solid var(--vibe-border);
}

.vibe-read-item code {
  font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
  font-size: 0.9em;
}

.vibe-read-item pre code {
  background: transparent;
  padding: 0;
}

.vibe-read-item :not(pre) > code {
  background: var(--vibe-bg-tertiary);
  padding: 2px 6px;
  border-radius: 3px;
  color: var(--vibe-red);
}

/* Approval View */
.vibe-approval-view {
  flex: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
}

.vibe-approval-header {
  background: var(--vibe-bg-secondary);
  padding: 20px 30px;
  border-bottom: 1px solid var(--vibe-border);
}

.vibe-approval-title {
  display: flex;
  align-items: center;
  gap: 12px;
}

.vibe-approval-icon {
  width: 40px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--vibe-bg-tertiary);
  border: 1px solid var(--vibe-border);
  border-radius: 4px;
  font-size: 0.7rem;
  font-weight: 600;
  color: var(--vibe-text-secondary);
}

.vibe-approval-info {
  flex: 1;
}

.vibe-approval-info h3 {
  font-size: 1rem;
  color: var(--vibe-text-primary);
  margin-bottom: 4px;
}

.vibe-approval-info p {
  font-size: 0.85rem;
  color: var(--vibe-text-secondary);
  font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
}

.vibe-approval-badge {
  padding: 4px 10px;
  background: var(--vibe-yellow);
  color: #78350f;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: 600;
}

.vibe-reasoning {
  padding: 20px 30px;
  background: var(--vibe-bg-secondary);
  border-bottom: 1px solid var(--vibe-border);
}

.vibe-reasoning h4 {
  font-size: 0.9rem;
  color: var(--vibe-text-primary);
  margin-bottom: 8px;
}

.vibe-reasoning p {
  font-size: 0.85rem;
  color: var(--vibe-text-secondary);
  line-height: 1.6;
}

/* Diff Container */
.vibe-diff-container {
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  margin: 20px 30px;
  border: 1px solid var(--vibe-border);
  border-radius: 6px;
}

.vibe-diff-header {
  background: var(--vibe-bg-secondary);
  padding: 10px 14px;
  font-weight: 600;
  border-bottom: 1px solid var(--vibe-border);
  color: var(--vibe-text-secondary);
  font-size: 0.8rem;
}

.vibe-diff-content {
  flex: 1;
  overflow-y: auto;
  background: var(--vibe-bg-primary);
}

.vibe-diff-content pre {
  margin: 0;
  padding: 0;
  background: transparent;
}

.vibe-diff-content code {
  display: block;
  padding: 0;
  background: transparent;
}

/* Diff Lines */
.vibe-diff-line {
  padding: 2px 8px 2px 0;
  margin: 0;
  display: flex;
  font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
  font-size: 0.75rem;
  line-height: 1.6;
  align-items: flex-start;
}

.vibe-line-number {
  display: inline-block;
  width: 50px;
  padding: 0 8px;
  text-align: right;
  user-select: none;
  color: var(--vibe-text-muted);
  flex-shrink: 0;
  border-right: 1px solid var(--vibe-border);
  margin-right: 8px;
  padding-top: 2px;
}

.vibe-line-prefix {
  display: inline-block;
  width: 20px;
  user-select: none;
  font-weight: bold;
  flex-shrink: 0;
  padding-top: 2px;
}

.vibe-line-content {
  flex: 1;
  white-space: pre-wrap;
  word-wrap: break-word;
  word-break: break-word;
  overflow-wrap: break-word;
  min-width: 0;
}

.vibe-diff-added {
  background-color: var(--vibe-diff-added-bg);
  color: var(--vibe-diff-added-text);
}

.vibe-diff-added .vibe-line-prefix {
  color: var(--vibe-green);
}

.vibe-diff-removed {
  background-color: var(--vibe-diff-removed-bg);
  color: var(--vibe-diff-removed-text);
}

.vibe-diff-removed .vibe-line-prefix {
  color: var(--vibe-red);
}

.vibe-diff-unchanged {
  background-color: transparent;
  color: var(--vibe-text-primary);
}

.vibe-diff-unchanged .vibe-line-prefix {
  color: var(--vibe-text-muted);
}

/* Approval Actions */
.vibe-approval-actions {
  display: flex;
  gap: 12px;
  padding: 20px 30px;
  background: var(--vibe-bg-secondary);
  border-top: 1px solid var(--vibe-border);
  justify-content: flex-end;
}

.vibe-btn-reject,
.vibe-btn-accept {
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  border: none;
}

.vibe-btn-reject {
  background: var(--vibe-red);
  color: white;
}

.vibe-btn-reject:hover:not(:disabled) {
  background: #dc2626;
}

.vibe-btn-accept {
  background: var(--vibe-green);
  color: white;
}

.vibe-btn-accept:hover:not(:disabled) {
  background: #16a34a;
}

.vibe-btn-reject:disabled,
.vibe-btn-accept:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.vibe-accepting {
  display: flex;
  align-items: center;
  gap: 8px;
}

.vibe-spinner-small {
  width: 12px;
  height: 12px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-top: 2px solid white;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Flow Panel (20%) */
.vibe-flow-panel {
  flex: 0 0 20%;
  background: var(--vibe-bg-secondary);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.vibe-flow-header {
  padding: 20px;
  border-bottom: 1px solid var(--vibe-border);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.vibe-flow-header h2 {
  font-size: 1rem;
  color: var(--vibe-text-primary);
  font-weight: 600;
}

.vibe-flow-count {
  background: var(--vibe-bg-tertiary);
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 0.75rem;
  color: var(--vibe-text-secondary);
  border: 1px solid var(--vibe-border);
}

.vibe-flow-content {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
}

.vibe-flow-content::-webkit-scrollbar {
  width: 6px;
}

.vibe-flow-content::-webkit-scrollbar-track {
  background: transparent;
}

.vibe-flow-content::-webkit-scrollbar-thumb {
  background: var(--vibe-border);
  border-radius: 3px;
}

.vibe-flow-item {
  display: flex;
  align-items: flex-start;
  gap: 10px;
  padding: 12px;
  background: var(--vibe-bg-primary);
  border: 1px solid var(--vibe-border);
  border-radius: 6px;
  margin-bottom: 8px;
  transition: all 0.2s;
}

.vibe-flow-item:hover {
  background: var(--vibe-bg-tertiary);
}

.vibe-flow-icon {
  font-size: 1.2rem;
  flex-shrink: 0;
}

.vibe-flow-info {
  flex: 1;
  min-width: 0;
}

.vibe-flow-tool {
  font-size: 0.8rem;
  font-weight: 600;
  color: var(--vibe-text-primary);
  margin-bottom: 2px;
}

.vibe-flow-file {
  font-size: 0.75rem;
  color: var(--vibe-text-secondary);
  word-break: break-word;
  margin-bottom: 4px;
}

.vibe-flow-time {
  font-size: 0.7rem;
  color: var(--vibe-text-muted);
}

.vibe-flow-status-text {
  font-size: 0.75rem;
  color: var(--vibe-text-muted);
  font-style: italic;
}

.vibe-flow-status {
  flex-shrink: 0;
}

.vibe-status-dot {
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  font-size: 10px;
  font-weight: bold;
}

.vibe-dot-executing {
  background: var(--vibe-blue-light);
  color: var(--vibe-blue);
  animation: pulse 1.5s ease-in-out infinite;
}

.vibe-dot-completed {
  background: var(--vibe-green-light);
  color: var(--vibe-green);
}

.vibe-dot-rejected {
  background: var(--vibe-red-light);
  color: var(--vibe-red);
}

.vibe-flow-queued {
  opacity: 0.6;
  border-style: dashed;
}

/* Empty States */
.vibe-empty-state,
.vibe-waiting-state,
.vibe-flow-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 60px 20px;
  text-align: center;
}

.vibe-empty-icon,
.vibe-flow-empty-icon {
  font-size: 3rem;
  margin-bottom: 16px;
  opacity: 0.4;
}

.vibe-empty-state p,
.vibe-flow-empty p {
  font-size: 1rem;
  color: var(--vibe-text-primary);
  margin-bottom: 8px;
}

.vibe-empty-state span {
  font-size: 0.85rem;
  color: var(--vibe-text-secondary);
}

.vibe-spinner {
  width: 50px;
  height: 50px;
  border: 3px solid var(--vibe-border);
  border-top: 3px solid var(--vibe-blue);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 20px;
}

.vibe-waiting-state h3 {
  font-size: 1rem;
  color: var(--vibe-text-primary);
  margin-bottom: 8px;
}

.vibe-waiting-state p {
  font-size: 0.85rem;
  color: var(--vibe-text-secondary);
}

.vibe-dots span {
  animation: blink 1.4s infinite;
}

.vibe-dots span:nth-child(2) {
  animation-delay: 0.2s;
}

.vibe-dots span:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes blink {
  0%, 20% { opacity: 0.2; }
  50% { opacity: 1; }
  100% { opacity: 0.2; }
}

/* Responsive */
@media (max-width: 1024px) {
  .vibe-read-panel {
    flex: 0 0 70%;
  }
  
  .vibe-flow-panel {
    flex: 0 0 30%;
  }
}

@media (max-width: 768px) {
  .vibe-content {
    flex-direction: column;
  }
  
  .vibe-read-panel,
  .vibe-flow-panel {
    flex: 1 1 auto;
  }
  
  .vibe-read-panel {
    border-right: none;
    border-bottom: 1px solid var(--vibe-border);
  }
}
