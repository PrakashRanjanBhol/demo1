insertCommentsAtLines(file: FileData, fileIndex: number): void {
  file.ai_comments.forEach((comment, commentIndex) => {
    const commentId = this.getCommentId(fileIndex, commentIndex);
    let commentElement = document.getElementById(`comment-${commentId}`);

    if (!commentElement) {
      console.warn(`Comment element not found in DOM: comment-${commentId}`);
      return;
    }

    // Clone the comment element to preserve it
    const commentClone = commentElement.cloneNode(true) as HTMLElement;

    // Re-bind event listeners on the cloned element
    this.bindCommentEvents(commentClone, fileIndex, commentIndex);

    // Find the diff container
    const diffContainer = document.querySelector(`#diff-output-${fileIndex}`);
    if (!diffContainer) {
      console.warn(`Diff container not found for file index: ${fileIndex}`);
      return;
    }

    // Get all rows from the diff
    const rows = diffContainer.querySelectorAll('.d2h-diff-tbody tr');
    let commentInserted = false;

    rows.forEach((row) => {
      if (commentInserted) return;

      if (this.viewMode === 'side-by-side') {
        // In side-by-side mode, handle left (FROM) and right (TO) sides
        const allCells = row.querySelectorAll('td');
        
        allCells.forEach((cell, cellIndex) => {
          if (commentInserted) return;
          
          const lineNumElement = cell.querySelector('.d2h-code-side-linenumber');
          if (!lineNumElement) return;
          
          const lineText = lineNumElement.textContent?.trim() || '';
          const lineNum = parseInt(lineText);
          
          if (isNaN(lineNum) || lineNum !== comment.line) return;
          
          // In side-by-side, left columns are old file (FROM), right columns are new file (TO)
          // Typically columns 0-1 are left side, columns 2-3 are right side (for 4 column layout)
          // Or columns 0-2 are left side, columns 3-5 are right side (for 6 column layout)
          const totalCells = allCells.length;
          const isLeftSide = cellIndex < totalCells / 2;
          const isRightSide = cellIndex >= totalCells / 2;
          
          // Check if this matches the comment's side
          const shouldInsertHere = (comment.side === 'FROM' && isLeftSide) || 
                                  (comment.side === 'TO' && isRightSide);
          
          if (!shouldInsertHere) {
            return;
          }

          const nextRow = row.nextElementSibling;
          if (nextRow && nextRow.classList.contains('comment-row')) {
            commentInserted = true;
            return;
          }

          const commentRow = document.createElement('tr');
          commentRow.className = 'comment-row';

          const commentCell = document.createElement('td');
          commentCell.className = 'comment-cell';
          commentCell.setAttribute('colspan', totalCells.toString());
          commentCell.style.padding = '0';
          commentCell.style.border = 'none';
          commentCell.style.backgroundColor = 'var(--bitbucket-file-comparator-bg-overlay)';

          const wrapperDiv = document.createElement('div');
          wrapperDiv.className = 'comment-wrapper';
          wrapperDiv.style.width = '100%';
          wrapperDiv.style.display = 'block';

          commentClone.style.display = 'block';
          commentClone.style.visibility = 'visible';
          commentClone.style.opacity = '1';

          wrapperDiv.appendChild(commentClone);
          commentCell.appendChild(wrapperDiv);
          commentRow.appendChild(commentCell);

          row.parentNode?.insertBefore(commentRow, row.nextSibling);

          commentInserted = true;
        });
      } else {
        // Line-by-line (unified) mode
        const lineNumberCells = row.querySelectorAll('td.d2h-code-linenumber');
        
        lineNumberCells.forEach((cell, index) => {
          if (commentInserted) return;
          
          const lineText = cell.textContent?.trim() || '';
          const lineNum = parseInt(lineText);

          if (isNaN(lineNum) || lineNum !== comment.line) return;

          // In unified view:
          // - Index 0 is old file line number (FROM)
          // - Index 1 is new file line number (TO)
          const shouldInsertHere = (comment.side === 'FROM' && index === 0) || 
                                  (comment.side === 'TO' && index === 1);
          
          if (!shouldInsertHere) {
            return;
          }

          const nextRow = row.nextElementSibling;
          if (nextRow && nextRow.classList.contains('comment-row')) {
            commentInserted = true;
            return;
          }

          const commentRow = document.createElement('tr');
          commentRow.className = 'comment-row';

          const commentCell = document.createElement('td');
          commentCell.className = 'comment-cell';
          commentCell.setAttribute('colspan', '4');
          commentCell.style.padding = '0';
          commentCell.style.border = 'none';
          commentCell.style.backgroundColor = 'var(--bitbucket-file-comparator-bg-overlay)';

          const wrapperDiv = document.createElement('div');
          wrapperDiv.className = 'comment-wrapper';
          wrapperDiv.style.width = '100%';
          wrapperDiv.style.display = 'block';

          commentClone.style.display = 'block';
          commentClone.style.visibility = 'visible';
          commentClone.style.opacity = '1';

          wrapperDiv.appendChild(commentClone);
          commentCell.appendChild(wrapperDiv);
          commentRow.appendChild(commentCell);

          row.parentNode?.insertBefore(commentRow, row.nextSibling);

          commentInserted = true;
        });
      }
    });

    if (!commentInserted) {
      console.warn(`Could not insert comment for line ${comment.line} (side: ${comment.side}) in file ${file.file_path}`);
      console.log('Comment details:', comment);
    }
  });
}
