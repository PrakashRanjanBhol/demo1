/* CSS Variables for Theming */
:host {
    /* Light Theme (Default) */
    --bitbucket-file-comparator-bg-primary: #ffffff;
    --bitbucket-file-comparator-bg-secondary: #f5f5f5;
    --bitbucket-file-comparator-bg-tertiary: #fafbfc;
    --bitbucket-file-comparator-bg-overlay: #f0f7ff;
    
    --bitbucket-file-comparator-text-primary: #24292e;
    --bitbucket-file-comparator-text-secondary: #6c757d;
    --bitbucket-file-comparator-text-tertiary: #57606a;
    
    --bitbucket-file-comparator-border-primary: #e1e4e8;
    --bitbucket-file-comparator-border-secondary: #d0d7de;
    --bitbucket-file-comparator-border-tertiary: #d1d5db;
    
    --bitbucket-file-comparator-accent-primary: #0052cc;
    --bitbucket-file-comparator-accent-secondary: #0065ff;
    
    --bitbucket-file-comparator-comment-bg: #ffffff;
    --bitbucket-file-comparator-comment-border: #e0d4ff;
    --bitbucket-file-comparator-comment-shadow: rgba(0, 0, 0, 0.08);
    
    --bitbucket-file-comparator-success-bg: #f0fdf4;
    --bitbucket-file-comparator-success-border: #86efac;
    --bitbucket-file-comparator-success-text: #166534;
    --bitbucket-file-comparator-success-bg-light: #dcfce7;
    
    --bitbucket-file-comparator-error-bg: #fef2f2;
    --bitbucket-file-comparator-error-border: #fca5a5;
    --bitbucket-file-comparator-error-text: #991b1b;
    --bitbucket-file-comparator-error-bg-light: #fee2e2;
    
    --bitbucket-file-comparator-warning-bg: #fef3c7;
    --bitbucket-file-comparator-warning-text: #92400e;
    
    --bitbucket-file-comparator-info-bg: #dbeafe;
    --bitbucket-file-comparator-info-text: #1e40af;
    
    --bitbucket-file-comparator-purple-bg: #f3e8ff;
    --bitbucket-file-comparator-purple-text: #7c3aed;
    --bitbucket-file-comparator-purple-border: #7c3aed;
    
    --bitbucket-file-comparator-highlight-comment: #faf5ff;
    --bitbucket-file-comparator-highlight-accepted: #f0fdf4;
    --bitbucket-file-comparator-highlight-rejected: #fef2f2;
    
    --bitbucket-file-comparator-spinner-bg: #f3f4f6;
    --bitbucket-file-comparator-spinner-border: #e5e7eb;
    --bitbucket-file-comparator-spinner-accent: #7c3aed;
    
    --bitbucket-file-comparator-code-bg: #f6f8fa;
    --bitbucket-file-comparator-code-text: #24292e;
}

/* Dark Theme */
:host-context(.dark-theme),
:host.dark-theme {
    --bitbucket-file-comparator-bg-primary: #0a0a0b;
    --bitbucket-file-comparator-bg-secondary: #161618;
    --bitbucket-file-comparator-bg-tertiary: #1e1e20;
    --bitbucket-file-comparator-bg-overlay: #1a1d2e;
    
    --bitbucket-file-comparator-text-primary: #e6e6e6;
    --bitbucket-file-comparator-text-secondary: #9ca3af;
    --bitbucket-file-comparator-text-tertiary: #6b7280;
    
    --bitbucket-file-comparator-border-primary: #2d2d30;
    --bitbucket-file-comparator-border-secondary: #3d3d40;
    --bitbucket-file-comparator-border-tertiary: #4d4d50;
    
    --bitbucket-file-comparator-accent-primary: #3b82f6;
    --bitbucket-file-comparator-accent-secondary: #60a5fa;
    
    --bitbucket-file-comparator-comment-bg: #1e1e20;
    --bitbucket-file-comparator-comment-border: #4c1d95;
    --bitbucket-file-comparator-comment-shadow: rgba(0, 0, 0, 0.3);
    
    --bitbucket-file-comparator-success-bg: #14532d;
    --bitbucket-file-comparator-success-border: #16a34a;
    --bitbucket-file-comparator-success-text: #86efac;
    --bitbucket-file-comparator-success-bg-light: #166534;
    
    --bitbucket-file-comparator-error-bg: #450a0a;
    --bitbucket-file-comparator-error-border: #dc2626;
    --bitbucket-file-comparator-error-text: #fca5a5;
    --bitbucket-file-comparator-error-bg-light: #991b1b;
    
    --bitbucket-file-comparator-warning-bg: #451a03;
    --bitbucket-file-comparator-warning-text: #fbbf24;
    
    --bitbucket-file-comparator-info-bg: #1e3a8a;
    --bitbucket-file-comparator-info-text: #93c5fd;
    
    --bitbucket-file-comparator-purple-bg: #2e1065;
    --bitbucket-file-comparator-purple-text: #a78bfa;
    --bitbucket-file-comparator-purple-border: #7c3aed;
    
    --bitbucket-file-comparator-highlight-comment: #2e1065;
    --bitbucket-file-comparator-highlight-accepted: #14532d;
    --bitbucket-file-comparator-highlight-rejected: #450a0a;
    
    --bitbucket-file-comparator-spinner-bg: #2d2d30;
    --bitbucket-file-comparator-spinner-border: #3d3d40;
    --bitbucket-file-comparator-spinner-accent: #a78bfa;
    
    --bitbucket-file-comparator-code-bg: #1e1e20;
    --bitbucket-file-comparator-code-text: #e6e6e6;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:host {
    display: block;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    background-color: var(--bitbucket-file-comparator-bg-secondary);
    padding: 20px;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    background: var(--bitbucket-file-comparator-bg-primary);
    border-radius: 8px;
    box-shadow: 0 2px 8px var(--bitbucket-file-comparator-comment-shadow);
}

.header {
    padding: 24px;
    border-bottom: 1px solid var(--bitbucket-file-comparator-border-primary);
}

.header-content {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 20px;
}

.header-left {
    flex: 1;
}

.header-right {
    display: flex;
    align-items: center;
    gap: 12px;
}

.header h1 {
    font-size: 24px;
    color: var(--bitbucket-file-comparator-accent-primary);
    margin-bottom: 8px;
}

.header .pr-info {
    color: var(--bitbucket-file-comparator-text-secondary);
    font-size: 14px;
}

/* View Toggle */
.view-toggle {
    display: flex;
    gap: 4px;
}

.toggle-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px;
    background: var(--bitbucket-file-comparator-bg-primary);
    border: 2px solid var(--bitbucket-file-comparator-border-primary);
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    color: var(--bitbucket-file-comparator-text-primary);
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 1px 3px var(--bitbucket-file-comparator-comment-shadow);
}

.toggle-btn:hover {
    border-color: var(--bitbucket-file-comparator-accent-primary);
    background: var(--bitbucket-file-comparator-bg-tertiary);
    transform: translateY(-1px);
    box-shadow: 0 2px 6px rgba(0, 82, 204, 0.15);
}

.toggle-btn.active {
    background: linear-gradient(135deg, var(--bitbucket-file-comparator-accent-primary) 0%, var(--bitbucket-file-comparator-accent-secondary) 100%);
    border-color: var(--bitbucket-file-comparator-accent-primary);
    color: white;
    box-shadow: 0 2px 8px rgba(0, 82, 204, 0.3);
}

.toggle-icon {
    font-size: 18px;
    font-weight: bold;
}

.toggle-text {
    font-size: 13px;
    letter-spacing: 0.3px;
}

.file-header {
    background-color: var(--bitbucket-file-comparator-bg-tertiary);
    padding: 12px 20px;
    border-top: 1px solid var(--bitbucket-file-comparator-border-primary);
    font-weight: 600;
    color: var(--bitbucket-file-comparator-text-primary);
    display: flex;
    align-items: center;
    gap: 10px;
}

.file-icon {
    color: var(--bitbucket-file-comparator-text-secondary);
}

.diff-container {
    padding: 0;
    position: relative;
}

/* Custom styling for diff2html */
::ng-deep .d2h-wrapper {
    border: none !important;
}

::ng-deep .d2h-file-header {
    display: none !important;
}

::ng-deep .d2h-diff-table {
    width: 100%;
    border-collapse: collapse;
}

::ng-deep .d2h-code-line-ctn {
    padding-left: 8px !important;
}

/* AI Comment styling */
.comments-hidden-container {
    position: absolute;
    left: -9999px;
    top: -9999px;
    visibility: hidden;
    opacity: 0;
}

.ai-comment-thread {
    background-color: var(--bitbucket-file-comparator-bg-overlay);
    border-left: 3px solid var(--bitbucket-file-comparator-purple-border);
    margin: 0;
    padding: 0;
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
}

.ai-comment {
    padding: 16px 20px;
    background-color: var(--bitbucket-file-comparator-comment-bg);
    margin: 8px 16px;
    border-radius: 6px;
    box-shadow: 0 1px 3px var(--bitbucket-file-comparator-comment-shadow);
    border: 1px solid var(--bitbucket-file-comparator-comment-border);
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Comment row styling for inline display */
::ng-deep .comment-row {
    background-color: var(--bitbucket-file-comparator-bg-overlay) !important;
    display: table-row !important;
    animation: fadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

::ng-deep .comment-row .comment-cell {
    padding: 0 !important;
    border: none !important;
    background-color: var(--bitbucket-file-comparator-bg-overlay) !important;
    display: table-cell !important;
    width: 100% !important;
}

/* Ensure comment cell spans full width in both views */
::ng-deep .d2h-file-side-diff .comment-row .comment-cell,
::ng-deep .d2h-file-diff .comment-row .comment-cell {
    width: 100% !important;
    max-width: 100% !important;
}

::ng-deep .comment-wrapper {
    width: 100% !important;
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
    padding: 10px !important;
}

::ng-deep .comment-row .ai-comment-thread {
    width: 100% !important;
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
    position: relative !important;
    left: 0 !important;
    top: 0 !important;
}

::ng-deep .comment-row .ai-comment {
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
}

/* Force visibility in side-by-side mode */
::ng-deep .d2h-file-side-diff tbody .comment-row,
::ng-deep .d2h-wrapper .comment-row {
    display: table-row !important;
    visibility: visible !important;
}

::ng-deep .d2h-file-side-diff tbody .comment-row td,
::ng-deep .d2h-wrapper .comment-row td {
    display: table-cell !important;
    visibility: visible !important;
}

.ai-comment.editing {
    border-color: var(--bitbucket-file-comparator-purple-border);
    box-shadow: 0 2px 8px rgba(124, 58, 237, 0.15);
}

.ai-comment.accepted {
    background-color: var(--bitbucket-file-comparator-success-bg);
    border-color: var(--bitbucket-file-comparator-success-border);
}

.ai-comment.rejected {
    background-color: var(--bitbucket-file-comparator-error-bg);
    border-color: var(--bitbucket-file-comparator-error-border);
    opacity: 0.7;
}

.comment-header {
    display: flex;
    align-items: center;
    margin-bottom: 12px;
    gap: 8px;
}

.ai-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    background: linear-gradient(135deg, #7c3aed 0%, #a78bfa 100%);
    color: white;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.ai-badge::before {
    content: "âœ¨";
    font-size: 12px;
}

.severity-badge {
    display: inline-block;
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
}

.severity-suggestion {
    background-color: var(--bitbucket-file-comparator-info-bg);
    color: var(--bitbucket-file-comparator-info-text);
}

.severity-warning {
    background-color: var(--bitbucket-file-comparator-warning-bg);
    color: var(--bitbucket-file-comparator-warning-text);
}

.severity-error {
    background-color: var(--bitbucket-file-comparator-error-bg-light);
    color: var(--bitbucket-file-comparator-error-text);
}

.comment-time {
    color: var(--bitbucket-file-comparator-text-secondary);
    font-size: 12px;
    margin-left: auto;
}

.comment-body {
    color: var(--bitbucket-file-comparator-text-primary);
    line-height: 1.6;
    font-size: 14px;
    margin-bottom: 12px;
    transition: opacity 0.3s ease;
}

.comment-body-editable {
    width: 100%;
    min-height: 60px;
    padding: 10px;
    border: 2px solid var(--bitbucket-file-comparator-purple-border);
    border-radius: 6px;
    font-family: inherit;
    font-size: 14px;
    resize: vertical;
    margin-bottom: 12px;
    background-color: var(--bitbucket-file-comparator-comment-bg);
    color: var(--bitbucket-file-comparator-text-primary);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    animation: fadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.comment-body-editable:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.1);
}

.suggested-patch {
    background-color: var(--bitbucket-file-comparator-code-bg);
    border: 1px solid var(--bitbucket-file-comparator-border-secondary);
    border-radius: 6px;
    padding: 12px;
    margin-top: 8px;
    margin-bottom: 12px;
}

.suggested-patch-header {
    font-size: 12px;
    font-weight: 600;
    color: var(--bitbucket-file-comparator-text-tertiary);
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 6px;
}

.suggested-patch-header::before {
    content: "ðŸ’¡";
}

.suggested-patch-code {
    background-color: var(--bitbucket-file-comparator-comment-bg);
    padding: 8px 12px;
    border-radius: 4px;
    font-family: 'Courier New', monospace;
    font-size: 13px;
    color: var(--bitbucket-file-comparator-code-text);
    white-space: pre-wrap;
    word-break: break-all;
}

.comment-actions {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    transition: opacity 0.3s ease;
}

.action-btn {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    border: 2px solid;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
    box-shadow: 0 2px 4px var(--bitbucket-file-comparator-comment-shadow);
    opacity: 1;
}

.action-btn::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.3);
    transform: translate(-50%, -50%);
    transition: width 0.4s, height 0.4s;
}

.action-btn:hover::before {
    width: 300px;
    height: 300px;
}

.action-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px var(--bitbucket-file-comparator-comment-shadow);
}

.action-btn:active {
    transform: translateY(0);
}

.btn-icon {
    font-size: 16px;
    font-weight: bold;
    line-height: 1;
}

.btn-text {
    position: relative;
    z-index: 1;
}

.btn-accept {
    background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
    color: white;
    border-color: #22c55e;
}

.btn-accept:hover {
    background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
    border-color: #16a34a;
    box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
}

.btn-reject {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    color: white;
    border-color: #ef4444;
}

.btn-reject:hover {
    background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
    border-color: #dc2626;
    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
}

.btn-modify {
    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
    color: white;
    border-color: #f59e0b;
}

.btn-modify:hover {
    background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
    border-color: #d97706;
    box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
}

.btn-save {
    background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
    color: white;
    border-color: #7c3aed;
}

.btn-save:hover {
    background: linear-gradient(135deg, #6d28d9 0%, #5b21b6 100%);
    border-color: #6d28d9;
    box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
}

.btn-cancel {
    background: var(--bitbucket-file-comparator-bg-primary);
    color: var(--bitbucket-file-comparator-text-secondary);
    border-color: var(--bitbucket-file-comparator-border-tertiary);
}

.btn-cancel:hover {
    background: var(--bitbucket-file-comparator-bg-tertiary);
    border-color: var(--bitbucket-file-comparator-text-secondary);
    color: var(--bitbucket-file-comparator-text-primary);
    box-shadow: 0 4px 12px var(--bitbucket-file-comparator-comment-shadow);
}

.btn-undo {
    background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
    color: white;
    border-color: #6366f1;
}

.btn-undo:hover {
    background: linear-gradient(135deg, #4f46e5 0%, #4338ca 100%);
    border-color: #4f46e5;
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
}

/* Status badges for accepted/rejected */
.status-badge {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    margin-left: 8px;
}

.status-accepted {
    background-color: var(--bitbucket-file-comparator-success-bg-light);
    color: var(--bitbucket-file-comparator-success-text);
}

.status-rejected {
    background-color: var(--bitbucket-file-comparator-error-bg-light);
    color: var(--bitbucket-file-comparator-error-text);
}

/* Line highlighting */
::ng-deep .has-ai-comment {
    background-color: var(--bitbucket-file-comparator-highlight-comment) !important;
}

::ng-deep .has-ai-comment-accepted {
    background-color: var(--bitbucket-file-comparator-highlight-accepted) !important;
}

::ng-deep .has-ai-comment-rejected {
    background-color: var(--bitbucket-file-comparator-highlight-rejected) !important;
}

/* File stats */
.file-stats {
    display: inline-flex;
    gap: 8px;
    font-size: 12px;
    margin-left: auto;
}

.stat-additions {
    color: #22863a;
}

.stat-deletions {
    color: #cb2431;
}

.ai-comment-count {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    background-color: var(--bitbucket-file-comparator-purple-bg);
    color: var(--bitbucket-file-comparator-purple-text);
    padding: 3px 10px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 600;
    margin-left: 12px;
}

.ai-comment-count::before {
    content: "âœ¨";
    font-size: 11px;
}

/* Summary panel */
.summary-panel {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px 24px;
    margin-bottom: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.summary-stats {
    display: flex;
    gap: 24px;
}

.stat-item {
    display: flex;
    flex-direction: column;
}

.stat-value {
    font-size: 28px;
    font-weight: 700;
}

.stat-label {
    font-size: 12px;
    opacity: 0.9;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Diff line numbers */
::ng-deep .d2h-code-linenumber {
    position: relative;
}

/* Smooth fade animations */
@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(-5px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes fadeOut {
    from {
        opacity: 1;
        transform: translateY(0);
    }
    to {
        opacity: 0;
        transform: translateY(-5px);
    }
}

::ng-deep .comment-row.removing {
    animation: fadeOut 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.comment-actions.loading {
    opacity: 0.6;
    pointer-events: none;
}

/* Inline Spinner */
.inline-spinner {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px;
    background: var(--bitbucket-file-comparator-spinner-bg);
    border-radius: 8px;
    font-size: 13px;
    color: var(--bitbucket-file-comparator-text-secondary);
    font-weight: 600;
    animation: fadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.spinner {
    width: 16px;
    height: 16px;
    border: 2px solid var(--bitbucket-file-comparator-spinner-border);
    border-top-color: var(--bitbucket-file-comparator-spinner-accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

/* Loading state for comment */
.ai-comment.loading {
    opacity: 0.6;
    pointer-events: none;
}

















import { Component, OnInit, AfterViewInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

// Declare Diff2HtmlUI for TypeScript
declare const Diff2HtmlUI: any;

interface AIComment {
  file_path: string;
  line: number;
  side: string;
  comment_text: string;
  severity: 'suggestion' | 'warning' | 'error';
  suggested_patch: string | null;
}

interface FileData {
  file_path: string;
  old_lines: string[];
  new_lines: string[];
  ai_comments: AIComment[];
}

interface ResponseData {
  files: FileData[];
}

interface CommentState {
  status: 'pending' | 'accepted' | 'rejected';
  originalText: string;
  currentText: string;
  isEditing?: boolean;
}

interface SummaryStats {
  total: number;
  accepted: number;
  rejected: number;
  pending: number;
}

@Component({
  selector: 'app-ai-pr-diff-viewer',
  templateUrl: './ai-pr-diff-viewer.component.html',
  styleUrls: ['./ai-pr-diff-viewer.component.scss']
})
export class AiPrDiffViewerComponent implements OnInit, AfterViewInit {
  responseData: ResponseData = {
    files: [
      {
        file_path: "src/app/services/auth.service.ts",
        old_lines: [
          "import { Injectable } from '@angular/core';",
          "import { HttpClient } from '@angular/common/http';",
          "import { Observable } from 'rxjs';",
          "",
          "@Injectable({",
          "  providedIn: 'root'",
          "})",
          "export class AuthService {",
          "  private apiUrl = 'http://localhost:3000/api';",
          "",
          "  constructor(private http: HttpClient) { }",
          "",
          "  login(username: string, password: string): Observable<any> {",
          "    return this.http.post(`${this.apiUrl}/login`, { username, password });",
          "  }",
          "}"
        ],
        new_lines: [
          "import { Injectable } from '@angular/core';",
          "import { HttpClient, HttpHeaders } from '@angular/common/http';",
          "import { Observable, throwError } from 'rxjs';",
          "import { catchError, tap } from 'rxjs/operators';",
          "import { environment } from '../../environments/environment';",
          "",
          "@Injectable({",
          "  providedIn: 'root'",
          "})",
          "export class AuthService {",
          "  private apiUrl = environment.apiUrl;",
          "  private tokenKey = 'auth_token';",
          "",
          "  constructor(private http: HttpClient) { }",
          "",
          "  login(username: string, password: string): Observable<any> {",
          "    if (!username || !password) {",
          "      return throwError('Username and password are required');",
          "    }",
          "",
          "    const headers = new HttpHeaders({ 'Content-Type': 'application/json' });",
          "    ",
          "    return this.http.post(`${this.apiUrl}/auth/login`, ",
          "      { username, password },",
          "      { headers }",
          "    ).pipe(",
          "      tap((response: any) => {",
          "        if (response.token) {",
          "          localStorage.setItem(this.tokenKey, response.token);",
          "        }",
          "      }),",
          "      catchError(error => {",
          "        console.error('Login error:', error);",
          "        return throwError(error);",
          "      })",
          "    );",
          "  }",
          "",
          "  logout(): void {",
          "    localStorage.removeItem(this.tokenKey);",
          "  }",
          "",
          "  getToken(): string | null {",
          "    return localStorage.getItem(this.tokenKey);",
          "  }",
          "",
          "  isAuthenticated(): boolean {",
          "    return !!this.getToken();",
          "  }",
          "}"
        ],
        ai_comments: [
          {
            file_path: "src/app/services/auth.service.ts",
            line: 11,
            side: "TO",
            comment_text: "Good practice using environment variables instead of hardcoded URLs. This makes the application more flexible across different environments.",
            severity: "suggestion",
            suggested_patch: null
          },
          {
            file_path: "src/app/services/auth.service.ts",
            line: 17,
            side: "TO",
            comment_text: "Input validation is good, but consider using a more descriptive error object instead of a plain string for better error handling.",
            severity: "warning",
            suggested_patch: "      return throwError(() => new Error('Username and password are required'));"
          },
          {
            file_path: "src/app/services/auth.service.ts",
            line: 28,
            side: "TO",
            comment_text: "Security concern: Storing tokens in localStorage is vulnerable to XSS attacks. Consider using httpOnly cookies or sessionStorage with additional security measures.",
            severity: "error",
            suggested_patch: null
          },
          {
            file_path: "src/app/services/auth.service.ts",
            line: 32,
            side: "TO",
            comment_text: "Console.error in production code can expose sensitive information. Use a proper logging service with environment-based log levels.",
            severity: "warning",
            suggested_patch: "        // Use logging service instead of console.error"
          }
        ]
      },
      {
        file_path: "src/app/components/login/login.component.ts",
        old_lines: [
          "import { Component } from '@angular/core';",
          "import { AuthService } from '../../services/auth.service';",
          "",
          "@Component({",
          "  selector: 'app-login',",
          "  templateUrl: './login.component.html',",
          "  styleUrls: ['./login.component.scss']",
          "})",
          "export class LoginComponent {",
          "  username = '';",
          "  password = '';",
          "",
          "  constructor(private authService: AuthService) { }",
          "",
          "  onSubmit() {",
          "    this.authService.login(this.username, this.password).subscribe(",
          "      response => {",
          "        console.log('Login successful');",
          "      }",
          "    );",
          "  }",
          "}"
        ],
        new_lines: [
          "import { Component, OnDestroy } from '@angular/core';",
          "import { Router } from '@angular/router';",
          "import { AuthService } from '../../services/auth.service';",
          "import { Subject } from 'rxjs';",
          "import { takeUntil } from 'rxjs/operators';",
          "",
          "@Component({",
          "  selector: 'app-login',",
          "  templateUrl: './login.component.html',",
          "  styleUrls: ['./login.component.scss']",
          "})",
          "export class LoginComponent implements OnDestroy {",
          "  username = '';",
          "  password = '';",
          "  isLoading = false;",
          "  errorMessage = '';",
          "  private destroy$ = new Subject<void>();",
          "",
          "  constructor(",
          "    private authService: AuthService,",
          "    private router: Router",
          "  ) { }",
          "",
          "  ngOnDestroy(): void {",
          "    this.destroy$.next();",
          "    this.destroy$.complete();",
          "  }",
          "",
          "  onSubmit(): void {",
          "    if (!this.username.trim() || !this.password.trim()) {",
          "      this.errorMessage = 'Please enter both username and password';",
          "      return;",
          "    }",
          "",
          "    this.isLoading = true;",
          "    this.errorMessage = '';",
          "",
          "    this.authService.login(this.username, this.password)",
          "      .pipe(takeUntil(this.destroy$))",
          "      .subscribe({",
          "        next: (response) => {",
          "          this.isLoading = false;",
          "          this.router.navigate(['/dashboard']);",
          "        },",
          "        error: (error) => {",
          "          this.isLoading = false;",
          "          this.errorMessage = error.message || 'Login failed. Please try again.';",
          "        }",
          "      });",
          "  }",
          "",
          "  clearError(): void {",
          "    this.errorMessage = '';",
          "  }",
          "}"
        ],
        ai_comments: [
          {
            file_path: "src/app/components/login/login.component.ts",
            line: 17,
            side: "TO",
            comment_text: "Excellent addition of the destroy$ subject for proper subscription cleanup. This prevents memory leaks.",
            severity: "suggestion",
            suggested_patch: null
          },
          {
            file_path: "src/app/components/login/login.component.ts",
            line: 29,
            side: "TO",
            comment_text: "Good client-side validation, but remember this should also be validated on the server side for security.",
            severity: "suggestion",
            suggested_patch: null
          },
          {
            file_path: "src/app/components/login/login.component.ts",
            line: 34,
            side: "TO",
            comment_text: "Consider disabling the submit button while isLoading is true to prevent multiple submissions.",
            severity: "suggestion",
            suggested_patch: null
          },
          {
            file_path: "src/app/components/login/login.component.ts",
            line: 45,
            side: "TO",
            comment_text: "Generic error messages are good for security, but consider logging detailed errors for debugging purposes.",
            severity: "suggestion",
            suggested_patch: "          this.errorMessage = 'Login failed. Please try again.';\n          console.debug('Login error details:', error);"
          }
        ]
      },
      {
        file_path: "src/app/guards/auth.guard.ts",
        old_lines: [],
        new_lines: [
          "import { Injectable } from '@angular/core';",
          "import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';",
          "import { AuthService } from '../services/auth.service';",
          "",
          "@Injectable({",
          "  providedIn: 'root'",
          "})",
          "export class AuthGuard implements CanActivate {",
          "",
          "  constructor(",
          "    private authService: AuthService,",
          "    private router: Router",
          "  ) { }",
          "",
          "  canActivate(",
          "    route: ActivatedRouteSnapshot,",
          "    state: RouterStateSnapshot",
          "  ): boolean {",
          "    if (this.authService.isAuthenticated()) {",
          "      return true;",
          "    }",
          "",
          "    this.router.navigate(['/login'], {",
          "      queryParams: { returnUrl: state.url }",
          "    });",
          "    return false;",
          "  }",
          "}"
        ],
        ai_comments: [
          {
            file_path: "src/app/guards/auth.guard.ts",
            line: 19,
            side: "TO",
            comment_text: "The authentication check looks good. However, consider also validating the token's expiration and integrity, not just its presence.",
            severity: "warning",
            suggested_patch: null
          },
          {
            file_path: "src/app/guards/auth.guard.ts",
            line: 24,
            side: "TO",
            comment_text: "Great addition of returnUrl query parameter! This provides better user experience by redirecting users back to their intended destination after login.",
            severity: "suggestion",
            suggested_patch: null
          },
          {
            file_path: "src/app/guards/auth.guard.ts",
            line: 15,
            side: "TO",
            comment_text: "Consider making canActivate return Observable<boolean> instead of just boolean to support async token validation.",
            severity: "suggestion",
            suggested_patch: "  canActivate(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<boolean> | boolean {"
          }
        ]
      }
    ]
  };

  commentStates: { [key: string]: CommentState } = {};
  summaryStats: SummaryStats = {
    total: 0,
    accepted: 0,
    rejected: 0,
    pending: 0
  };

  editingCommentText: { [key: string]: string } = {};
  viewMode: 'side-by-side' | 'line-by-line' = 'line-by-line';
  loadingComments: { [key: string]: boolean } = {};

  constructor() { }

  ngOnInit(): void {
    this.initializeCommentStates();
    this.updateSummaryStats();
  }

  ngAfterViewInit(): void {
    // Render diffs after view initialization
    setTimeout(() => {
      this.renderAllDiffs();
    }, 100);
  }

  initializeCommentStates(): void {
    this.responseData.files.forEach((file, fileIndex) => {
      file.ai_comments.forEach((comment, commentIndex) => {
        const commentId = this.getCommentId(fileIndex, commentIndex);
        this.commentStates[commentId] = {
          status: 'pending',
          originalText: comment.comment_text,
          currentText: comment.comment_text,
          isEditing: false
        };
      });
    });
  }

  renderAllDiffs(): void {
    this.responseData.files.forEach((file, fileIndex) => {
      this.renderDiff(file, fileIndex);
      setTimeout(() => {
        this.highlightCommentedLines(file, fileIndex);
      }, 200);
    });
  }

  renderDiff(file: FileData, fileIndex: number): void {
    const diffString = this.generateDiffString(file);
    const diffOutputElement = document.getElementById(`diff-output-${fileIndex}`);

    if (diffOutputElement && typeof Diff2HtmlUI !== 'undefined') {
      // Clear existing content
      diffOutputElement.innerHTML = '';

      const diff2htmlUi = new Diff2HtmlUI(
        diffOutputElement,
        diffString,
        {
          drawFileList: false,
          matching: 'lines',
          outputFormat: this.viewMode === 'side-by-side' ? 'side-by-side' : 'line-by-line',
          highlight: true,
        }
      );
      diff2htmlUi.draw();

      setTimeout(() => {
        this.insertCommentsAtLines(file, fileIndex);
      }, 300);
    }
  }

  insertCommentsAtLines(file: FileData, fileIndex: number): void {
    file.ai_comments.forEach((comment, commentIndex) => {
      const commentId = this.getCommentId(fileIndex, commentIndex);
      let commentElement = document.getElementById(`comment-${commentId}`);

      if (!commentElement) {
        console.warn(`Comment element not found in DOM: comment-${commentId}`);
        return;
      }

      // Clone the comment element to preserve it
      const commentClone = commentElement.cloneNode(true) as HTMLElement;

      // Re-bind event listeners on the cloned element
      this.bindCommentEvents(commentClone, fileIndex, commentIndex);

      // Find the diff container
      const diffContainer = document.querySelector(`#diff-output-${fileIndex}`);
      if (!diffContainer) {
        console.warn(`Diff container not found for file index: ${fileIndex}`);
        return;
      }

      // Get all rows from the diff
      const rows = diffContainer.querySelectorAll('.d2h-diff-tbody tr');
      let commentInserted = false;

      rows.forEach((row) => {
        if (commentInserted) return;

        if (this.viewMode === 'side-by-side') {
          const lineNumberElements = row.querySelectorAll('.d2h-code-side-linenumber');

          Array.from(lineNumberElements).forEach((lineNumElement, index) => {
            if (commentInserted) return;

            const lineText = lineNumElement.textContent?.trim() || '';
            const lineNum = parseInt(lineText);

            if (!isNaN(lineNum) && lineNum === comment.line) {
              const nextRow = row.nextElementSibling;
              if (nextRow && nextRow.classList.contains('comment-row')) {
                commentInserted = true;
                return;
              }

              const commentRow = document.createElement('tr');
              commentRow.className = 'comment-row';

              const commentCell = document.createElement('td');
              commentCell.className = 'comment-cell';
              commentCell.setAttribute('colspan', '6');
              commentCell.style.padding = '0';
              commentCell.style.border = 'none';
              commentCell.style.backgroundColor = '#f0f7ff';

              const wrapperDiv = document.createElement('div');
              wrapperDiv.className = 'comment-wrapper';
              wrapperDiv.style.width = '100%';
              wrapperDiv.style.display = 'block';

              commentClone.style.display = 'block';
              commentClone.style.visibility = 'visible';
              commentClone.style.opacity = '1';

              wrapperDiv.appendChild(commentClone);
              commentCell.appendChild(wrapperDiv);
              commentRow.appendChild(commentCell);

              row.parentNode?.insertBefore(commentRow, row.nextSibling);

              commentInserted = true;
            }
          });
        } else {
          const lineNumberElements = row.querySelectorAll('.d2h-code-linenumber');

          lineNumberElements.forEach((lineNumElement) => {
            if (commentInserted) return;

            const lineText = lineNumElement.textContent?.trim() || '';
            const lineNum = parseInt(lineText);

            if (!isNaN(lineNum) && lineNum === comment.line) {
              const nextRow = row.nextElementSibling;
              if (nextRow && nextRow.classList.contains('comment-row')) {
                return;
              }

              const commentRow = document.createElement('tr');
              commentRow.className = 'comment-row';

              const commentCell = document.createElement('td');
              commentCell.className = 'comment-cell';
              commentCell.setAttribute('colspan', '4');
              commentCell.style.padding = '0';
              commentCell.style.border = 'none';
              commentCell.style.backgroundColor = '#f0f7ff';

              const wrapperDiv = document.createElement('div');
              wrapperDiv.className = 'comment-wrapper';
              wrapperDiv.style.width = '100%';
              wrapperDiv.style.display = 'block';

              commentClone.style.display = 'block';
              commentClone.style.visibility = 'visible';
              commentClone.style.opacity = '1';

              wrapperDiv.appendChild(commentClone);
              commentCell.appendChild(wrapperDiv);
              commentRow.appendChild(commentCell);

              row.parentNode?.insertBefore(commentRow, row.nextSibling);

              commentInserted = true;
            }
          });
        }
      });

      if (!commentInserted) {
        console.warn(`Could not insert comment for line ${comment.line} in file ${file.file_path}`);
      }
    });
  }

  // Add this new method to bind events manually
  bindCommentEvents(commentElement: HTMLElement, fileIndex: number, commentIndex: number): void {
    const commentId = this.getCommentId(fileIndex, commentIndex);

    // Find buttons within the cloned element
    const acceptBtn = commentElement.querySelector('.btn-accept');
    const rejectBtn = commentElement.querySelector('.btn-reject');
    const modifyBtn = commentElement.querySelector('.btn-modify');
    const saveBtn = commentElement.querySelector('.btn-save');
    const cancelBtn = commentElement.querySelector('.btn-cancel');
    const undoBtn = commentElement.querySelector('.btn-undo');

    // Find textarea for two-way binding
    const textarea = commentElement.querySelector('.comment-body-editable') as HTMLTextAreaElement;
    if (textarea) {
      textarea.value = this.editingCommentText[commentId] || '';
      textarea.addEventListener('input', (e) => {
        const target = e.target as HTMLTextAreaElement;
        this.editingCommentText[commentId] = target.value;
      });
    }

    // Bind events with loading check
    if (acceptBtn) {
      acceptBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!this.loadingComments[commentId]) {
          this.acceptComment(fileIndex, commentIndex);
        }
      });
    }

    if (rejectBtn) {
      rejectBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!this.loadingComments[commentId]) {
          this.rejectComment(fileIndex, commentIndex);
        }
      });
    }

    if (modifyBtn) {
      modifyBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!this.loadingComments[commentId]) {
          this.modifyComment(fileIndex, commentIndex);
        }
      });
    }

    if (saveBtn) {
      saveBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!this.loadingComments[commentId]) {
          this.saveModifiedComment(fileIndex, commentIndex);
        }
      });
    }

    if (cancelBtn) {
      cancelBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!this.loadingComments[commentId]) {
          this.cancelModification(fileIndex, commentIndex);
        }
      });
    }

    if (undoBtn) {
      undoBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!this.loadingComments[commentId]) {
          this.undoAction(fileIndex, commentIndex);
        }
      });
    }
  }

  toggleViewMode(): void {
    this.viewMode = this.viewMode === 'side-by-side' ? 'line-by-line' : 'side-by-side';
    setTimeout(() => {
      this.renderAllDiffs();
    }, 50);
  }

  generateDiffString(file: FileData): string {
    let diffString = `diff --git a/${file.file_path} b/${file.file_path}\n`;
    diffString += `--- a/${file.file_path}\n`;
    diffString += `+++ b/${file.file_path}\n`;
    diffString += `@@ -1,${file.old_lines.length} +1,${file.new_lines.length} @@\n`;

    const maxLength = Math.max(file.old_lines.length, file.new_lines.length);

    for (let i = 0; i < maxLength; i++) {
      if (i < file.old_lines.length && i < file.new_lines.length) {
        if (file.old_lines[i] === file.new_lines[i]) {
          diffString += ` ${file.old_lines[i]}\n`;
        } else {
          diffString += `-${file.old_lines[i]}\n`;
          diffString += `+${file.new_lines[i]}\n`;
        }
      } else if (i < file.old_lines.length) {
        diffString += `-${file.old_lines[i]}\n`;
      } else {
        diffString += `+${file.new_lines[i]}\n`;
      }
    }

    return diffString;
  }

  highlightCommentedLines(file: FileData, fileIndex: number): void {
    const diffLines = document.querySelectorAll(`#diff-output-${fileIndex} .d2h-code-line`);

    diffLines.forEach(line => {
      line.classList.remove('has-ai-comment', 'has-ai-comment-accepted', 'has-ai-comment-rejected');
    });

    file.ai_comments.forEach((comment, commentIndex) => {
      const commentId = this.getCommentId(fileIndex, commentIndex);
      const state = this.commentStates[commentId];
      const lineIndex = comment.line - 1;

      if (diffLines[lineIndex]) {
        if (state.status === 'accepted') {
          diffLines[lineIndex].classList.add('has-ai-comment-accepted');
        } else if (state.status === 'rejected') {
          diffLines[lineIndex].classList.add('has-ai-comment-rejected');
        } else {
          diffLines[lineIndex].classList.add('has-ai-comment');
        }
      }
    });
  }

  getCommentId(fileIndex: number, commentIndex: number): string {
    return `comment-${fileIndex}-${commentIndex}`;
  }

  getCommentState(fileIndex: number, commentIndex: number): CommentState {
    const commentId = this.getCommentId(fileIndex, commentIndex);
    return this.commentStates[commentId];
  }

  getFileStats(file: FileData): { additions: number; deletions: number } {
    const additions = Math.max(0, file.new_lines.length - file.old_lines.length);
    const deletions = Math.abs(Math.min(0, file.new_lines.length - file.old_lines.length));
    return { additions, deletions };
  }

  acceptComment(fileIndex: number, commentIndex: number): void {
    const commentId = this.getCommentId(fileIndex, commentIndex);

    // Set loading state
    this.loadingComments[commentId] = true;
    this.showLoadingSpinner(commentId, 'Accepting...');

    // Simulate API call with 2000ms delay
    setTimeout(() => {
      this.commentStates[commentId].status = 'accepted';
      this.commentStates[commentId].isEditing = false;
      this.updateSummaryStats();
      this.highlightCommentedLines(this.responseData.files[fileIndex], fileIndex);

      // Only update this specific comment
      this.updateSingleComment(fileIndex, commentIndex);
    }, 1000);
  }

  rejectComment(fileIndex: number, commentIndex: number): void {
    const commentId = this.getCommentId(fileIndex, commentIndex);

    // Set loading state
    this.loadingComments[commentId] = true;
    this.showLoadingSpinner(commentId, 'Rejecting...');

    // Simulate API call with 2000ms delay
    setTimeout(() => {
      this.commentStates[commentId].status = 'rejected';
      this.commentStates[commentId].isEditing = false;
      this.updateSummaryStats();
      this.highlightCommentedLines(this.responseData.files[fileIndex], fileIndex);

      // Only update this specific comment
      this.updateSingleComment(fileIndex, commentIndex);
    }, 2000);
  }

  modifyComment(fileIndex: number, commentIndex: number): void {
    const commentId = this.getCommentId(fileIndex, commentIndex);
    this.commentStates[commentId].isEditing = true;
    this.editingCommentText[commentId] = this.commentStates[commentId].currentText;

    // Only update this specific comment
    this.updateSingleComment(fileIndex, commentIndex);
  }

  saveModifiedComment(fileIndex: number, commentIndex: number): void {
    const commentId = this.getCommentId(fileIndex, commentIndex);
    const newText = this.editingCommentText[commentId]?.trim();

    if (!newText) {
      return;
    }

    // Set loading state
    this.loadingComments[commentId] = true;
    this.showLoadingSpinner(commentId, 'Saving...');

    // Simulate API call with 2000ms delay
    setTimeout(() => {
      this.commentStates[commentId].currentText = newText;
      this.commentStates[commentId].isEditing = false;
      delete this.editingCommentText[commentId];

      // Only update this specific comment
      this.updateSingleComment(fileIndex, commentIndex);
    }, 2000);
  }

  cancelModification(fileIndex: number, commentIndex: number): void {
    const commentId = this.getCommentId(fileIndex, commentIndex);
    this.commentStates[commentId].isEditing = false;
    delete this.editingCommentText[commentId];

    // Only update this specific comment
    this.updateSingleComment(fileIndex, commentIndex);
  }

  undoAction(fileIndex: number, commentIndex: number): void {
    const commentId = this.getCommentId(fileIndex, commentIndex);

    // Set loading state
    this.loadingComments[commentId] = true;
    this.showLoadingSpinner(commentId, 'Undoing...');

    // Simulate API call with 2000ms delay
    setTimeout(() => {
      this.commentStates[commentId].status = 'pending';
      this.updateSummaryStats();
      this.highlightCommentedLines(this.responseData.files[fileIndex], fileIndex);

      // Only update this specific comment
      this.updateSingleComment(fileIndex, commentIndex);
    }, 2000);
  }

  // Add this new method to show loading spinner
  showLoadingSpinner(commentId: string, message: string): void {
    const commentElement = document.getElementById(commentId);
    if (!commentElement) return;

    const actionsContainer = commentElement.querySelector('.comment-actions');
    if (!actionsContainer) return;

    // Hide existing buttons
    actionsContainer.classList.add('loading');

    // Create and add spinner
    const spinnerContainer = document.createElement('div');
    spinnerContainer.className = 'inline-spinner';
    spinnerContainer.id = `spinner-${commentId}`;
    spinnerContainer.innerHTML = `
    <div class="spinner"></div>
    <span>${message}</span>
  `;

    actionsContainer.appendChild(spinnerContainer);
  }

  // Add this new method to update only a single comment
  updateSingleComment(fileIndex: number, commentIndex: number): void {
    const commentId = this.getCommentId(fileIndex, commentIndex);
    const diffContainer = document.querySelector(`#diff-output-${fileIndex}`);

    if (!diffContainer) {
      delete this.loadingComments[commentId];
      return;
    }

    const allCommentRows = diffContainer.querySelectorAll('.comment-row');
    let targetCommentRow: any | null = null;

    allCommentRows.forEach(row => {
      const commentInRow = row.querySelector(`#${commentId}`);
      if (commentInRow) {
        targetCommentRow = row;
      }
    });

    if (!targetCommentRow) {
      console.warn(`Comment row not found for ${commentId}`);
      delete this.loadingComments[commentId];
      return;
    }

    targetCommentRow.classList.add('removing');

    // Updated to 400ms to match the smoother CSS animation
    setTimeout(() => {
      const parentRow = targetCommentRow!.previousElementSibling;
      targetCommentRow!.remove();

      const file = this.responseData.files[fileIndex];
      const comment = file.ai_comments[commentIndex];
      let commentElement = document.getElementById(`comment-${commentId}`);

      if (!commentElement) {
        console.warn(`Original comment element not found: comment-${commentId}`);
        delete this.loadingComments[commentId];
        return;
      }

      const commentClone = commentElement.cloneNode(true) as HTMLElement;
      this.bindCommentEvents(commentClone, fileIndex, commentIndex);

      const commentRow = document.createElement('tr');
      commentRow.className = 'comment-row';

      const commentCell = document.createElement('td');
      commentCell.className = 'comment-cell';
      const colspan = this.viewMode === 'side-by-side' ? '6' : '4';
      commentCell.setAttribute('colspan', colspan);
      commentCell.style.padding = '0';
      commentCell.style.border = 'none';
      commentCell.style.backgroundColor = '#f0f7ff';

      const wrapperDiv = document.createElement('div');
      wrapperDiv.className = 'comment-wrapper';
      wrapperDiv.style.width = '100%';
      wrapperDiv.style.display = 'block';

      commentClone.style.display = 'block';
      commentClone.style.visibility = 'visible';
      commentClone.style.opacity = '1';

      wrapperDiv.appendChild(commentClone);
      commentCell.appendChild(wrapperDiv);
      commentRow.appendChild(commentCell);

      if (parentRow && parentRow.parentNode) {
        parentRow.parentNode.insertBefore(commentRow, parentRow.nextSibling);
      }

      delete this.loadingComments[commentId];
    }, 400); // Changed from 300ms to 400ms
  }

  refreshCommentsForFile(fileIndex: number): void {
    const diffContainer = document.querySelector(`#diff-output-${fileIndex}`);
    if (diffContainer) {
      const commentRows = diffContainer.querySelectorAll('.comment-row');

      commentRows.forEach(row => {
        row.classList.add('removing');
      });

      setTimeout(() => {
        commentRows.forEach(row => row.remove());
        this.insertCommentsAtLines(this.responseData.files[fileIndex], fileIndex);
      }, 400); // Changed from 300ms to 400ms
    } else {
      this.insertCommentsAtLines(this.responseData.files[fileIndex], fileIndex);
    }
  }

  updateSummaryStats(): void {
    this.summaryStats = {
      total: 0,
      accepted: 0,
      rejected: 0,
      pending: 0
    };

    Object.values(this.commentStates).forEach(state => {
      this.summaryStats.total++;
      if (state.status === 'accepted') {
        this.summaryStats.accepted++;
      } else if (state.status === 'rejected') {
        this.summaryStats.rejected++;
      } else {
        this.summaryStats.pending++;
      }
    });
  }

  getCommentClasses(fileIndex: number, commentIndex: number): string {
    const state = this.getCommentState(fileIndex, commentIndex);
    const classes = ['ai-comment'];

    if (state.status === 'accepted') {
      classes.push('accepted');
    } else if (state.status === 'rejected') {
      classes.push('rejected');
    }

    if (state.isEditing) {
      classes.push('editing');
    }

    return classes.join(' ');
  }

  // Method to load data from API
  loadDataFromAPI(data: ResponseData): void {
    this.responseData = data;
    this.commentStates = {};
    this.editingCommentText = {};
    this.initializeCommentStates();
    this.updateSummaryStats();

    // Re-render diffs
    setTimeout(() => {
      this.renderAllDiffs();
    }, 100);
  }
}
















<div class="container">
    <div class="header">
        <div class="header-content">
            <div class="header-left">
                <h1>Pull Request #1234: Add user authentication feature</h1>
                <div class="pr-info">
                    <span>john.doe wants to merge changes into <strong>main</strong></span>
                </div>
            </div>
            <div class="header-right">
                <div class="view-toggle">
                    <button class="toggle-btn" [class.active]="viewMode === 'line-by-line'" (click)="toggleViewMode()"
                        title="Toggle view mode">
                        <span class="toggle-icon">{{ viewMode === 'line-by-line' ? 'âŠŸ' : 'âŠž' }}</span>
                        <span class="toggle-text">{{ viewMode === 'line-by-line' ? 'Unified' : 'Split' }}</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Summary Panel -->
    <div class="summary-panel">
        <div class="summary-stats">
            <div class="stat-item">
                <div class="stat-value">{{ summaryStats.total }}</div>
                <div class="stat-label">AI Comments</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">{{ summaryStats.accepted }}</div>
                <div class="stat-label">Accepted</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">{{ summaryStats.rejected }}</div>
                <div class="stat-label">Rejected</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">{{ summaryStats.pending }}</div>
                <div class="stat-label">Pending</div>
            </div>
        </div>
    </div>

    <!-- Files Container -->
    <div id="files-container">
        <div class="file-section" *ngFor="let file of responseData.files; let fileIndex = index">
            <!-- File Header -->
            <div class="file-header">
                <span class="file-icon">ðŸ“„</span>
                <span>{{ file.file_path }}</span>
                <span class="ai-comment-count">
                    {{ file.ai_comments.length }} AI {{ file.ai_comments.length === 1 ? 'comment' : 'comments' }}
                </span>
                <div class="file-stats">
                    <span class="stat-additions">+{{ getFileStats(file).additions }}</span>
                    <span class="stat-deletions">-{{ getFileStats(file).deletions }}</span>
                </div>
            </div>

            <!-- Diff Container -->
            <div class="diff-container">
                <div [id]="'diff-output-' + fileIndex"></div>

                <!-- AI Comments (hidden, will be moved to appropriate lines) -->
                <div class="comments-hidden-container">
                    <div class="ai-comment-thread" *ngFor="let comment of file.ai_comments; let commentIndex = index"
                        [attr.data-line]="comment.line" [id]="'comment-' + getCommentId(fileIndex, commentIndex)">

                        <div [class]="getCommentClasses(fileIndex, commentIndex)"
                            [id]="getCommentId(fileIndex, commentIndex)">

                            <!-- Comment Header -->
                            <div class="comment-header">
                                <span class="ai-badge">AI Review</span>
                                <span class="severity-badge" [ngClass]="'severity-' + comment.severity">
                                    {{ comment.severity }}
                                </span>

                                <span *ngIf="getCommentState(fileIndex, commentIndex).status !== 'pending'"
                                    class="status-badge"
                                    [ngClass]="'status-' + getCommentState(fileIndex, commentIndex).status">
                                    {{ getCommentState(fileIndex, commentIndex).status }}
                                </span>

                                <span class="comment-time">Line {{ comment.line }}</span>
                            </div>

                            <!-- Comment Body -->
                            <div *ngIf="!getCommentState(fileIndex, commentIndex).isEditing" class="comment-body"
                                [id]="getCommentId(fileIndex, commentIndex) + '-body'">
                                {{ getCommentState(fileIndex, commentIndex).currentText }}
                            </div>

                            <!-- Edit Mode -->
                            <div *ngIf="getCommentState(fileIndex, commentIndex).isEditing">
                                <textarea class="comment-body-editable"
                                    [(ngModel)]="editingCommentText[getCommentId(fileIndex, commentIndex)]"
                                    [id]="getCommentId(fileIndex, commentIndex) + '-textarea'">
                </textarea>
                            </div>

                            <!-- Suggested Patch -->
                            <div class="suggested-patch" *ngIf="comment.suggested_patch">
                                <div class="suggested-patch-header">Suggested Fix:</div>
                                <div class="suggested-patch-code">{{ comment.suggested_patch }}</div>
                            </div>

                            <!-- Comment Actions -->
                            <div class="comment-actions" [id]="getCommentId(fileIndex, commentIndex) + '-actions'">

                                <!-- Pending State Actions -->
                                <ng-container
                                    *ngIf="getCommentState(fileIndex, commentIndex).status === 'pending' && !getCommentState(fileIndex, commentIndex).isEditing">
                                    <button class="action-btn btn-accept"
                                        (click)="acceptComment(fileIndex, commentIndex)">
                                        <span class="btn-icon">âœ“</span>
                                        <span class="btn-text">Accept</span>
                                    </button>
                                    <button class="action-btn btn-reject"
                                        (click)="rejectComment(fileIndex, commentIndex)">
                                        <span class="btn-icon">âœ—</span>
                                        <span class="btn-text">Reject</span>
                                    </button>
                                    <button class="action-btn btn-modify"
                                        (click)="modifyComment(fileIndex, commentIndex)">
                                        <span class="btn-icon">âœŽ</span>
                                        <span class="btn-text">Modify</span>
                                    </button>
                                </ng-container>

                                <!-- Editing State Actions -->
                                <ng-container *ngIf="getCommentState(fileIndex, commentIndex).isEditing">
                                    <button class="action-btn btn-save"
                                        (click)="saveModifiedComment(fileIndex, commentIndex)">
                                        <span class="btn-icon">ðŸ’¾</span>
                                        <span class="btn-text">Save</span>
                                    </button>
                                    <button class="action-btn btn-cancel"
                                        (click)="cancelModification(fileIndex, commentIndex)">
                                        <span class="btn-icon">âœ•</span>
                                        <span class="btn-text">Cancel</span>
                                    </button>
                                </ng-container>

                                <!-- Accepted/Rejected State Actions -->
                                <ng-container
                                    *ngIf="getCommentState(fileIndex, commentIndex).status !== 'pending' && !getCommentState(fileIndex, commentIndex).isEditing">
                                    <button class="action-btn btn-undo" (click)="undoAction(fileIndex, commentIndex)">
                                        <span class="btn-icon">â†¶</span>
                                        <span class="btn-text">Undo</span>
                                    </button>
                                </ng-container>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
