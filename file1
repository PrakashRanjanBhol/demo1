import { Injectable } from '@angular/core';

export interface ToolData {
  tool: 'READ' | 'WRITE' | 'MODIFY';
  content: string;
}

export interface ParserResult {
  success: boolean;
  data: any;
}

export interface ApprovalRequest {
  data: ToolData;
  timestamp: Date;
}

export interface ParserCallbacks {
  onToolDetected?: (toolData: ToolData) => void;
  onApprovalRequest?: (approvalRequest: ApprovalRequest) => void;
  onCompletion?: () => void;
  onError?: (error: string) => void;
}

@Injectable({
  providedIn: 'root'
})
export class ChunkedJsonParserService {
  private buffer = '';
  private pendingQueue: ToolData[] = [];
  private isWaitingForApproval = false;
  private isStreamComplete = false;
  private currentPendingData: ToolData | null = null;

  // Callbacks for component
  private callbacks: ParserCallbacks = {};

  // Configuration
  private readonly API_URL = 'https://api.anthropic.com/v1/messages';
  private readonly API_KEY = 'YOUR_API_KEY_HERE'; // Replace with your actual API key
  private readonly REQUEST_BODY = {
    model: 'claude-3-5-sonnet-20241022',
    max_tokens: 1024,
    messages: [
      {
        role: 'user',
        content: 'Generate 5 JSON objects with this exact structure: {"tool": "READ", "content": "..."}. Mix READ, WRITE, and MODIFY tools. Return only JSON objects, one per line, nothing else.'
      }
    ],
    stream: true
  };

  constructor() {}

  public setCallbacks(callbacks: ParserCallbacks): void {
    this.callbacks = callbacks;
  }

  private processChunk(chunk: string): ParserResult {
    this.buffer += chunk;

    try {
      const parsed = JSON.parse(this.buffer);
      const result: ParserResult = { success: true, data: parsed };
      this.buffer = '';
      return result;
    } catch (error) {
      return { success: false, data: null };
    }
  }

  private reset(): void {
    this.buffer = '';
    this.pendingQueue = [];
    this.isWaitingForApproval = false;
    this.isStreamComplete = false;
    this.currentPendingData = null;
  }

  private handleParsedJSON(data: ToolData): void {
    const tool = data.tool;

    // Emit tool detected event via callback
    if (this.callbacks.onToolDetected) {
      this.callbacks.onToolDetected(data);
    }

    if (tool === 'READ') {
      // READ tool - process immediately
      // Continue processing queue
      this.processQueue();
    } else if (tool === 'WRITE' || tool === 'MODIFY') {
      // WRITE/MODIFY tool - require approval
      this.isWaitingForApproval = true;
      this.currentPendingData = data;
      
      if (this.callbacks.onApprovalRequest) {
        this.callbacks.onApprovalRequest({
          data: data,
          timestamp: new Date()
        });
      }
    } else {
      // Unknown tool - process immediately
      this.processQueue();
    }
  }

  private processQueue(): void {
    if (this.pendingQueue.length > 0 && !this.isWaitingForApproval) {
      const nextItem = this.pendingQueue.shift();
      if (nextItem) {
        this.handleParsedJSON(nextItem);
      }
    } else if (this.pendingQueue.length === 0 && this.isStreamComplete && !this.isWaitingForApproval) {
      // All done
      if (this.callbacks.onCompletion) {
        this.callbacks.onCompletion();
      }
    }
  }

  public approveAndContinue(): void {
    if (this.currentPendingData) {
      this.currentPendingData = null;
      this.isWaitingForApproval = false;

      // Process next item in queue
      this.processQueue();
    }
  }

  public async startStreaming(): Promise<void> {
    this.reset();

    try {
      const response = await fetch(this.API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.API_KEY,
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify(this.REQUEST_BODY)
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('Failed to get reader from response');
      }

      const decoder = new TextDecoder();

      while (true) {
        const { done, value } = await reader.read();

        if (done) {
          this.isStreamComplete = true;

          // Check if we're done or still waiting
          if (!this.isWaitingForApproval && this.pendingQueue.length === 0) {
            if (this.callbacks.onCompletion) {
              this.callbacks.onCompletion();
            }
          }
          break;
        }

        const chunk = decoder.decode(value, { stream: true });

        // Process each character in the chunk
        for (let char of chunk) {
          const result = this.processChunk(char);

          if (result.success) {
            let toolData = result.data;

            // Handle Anthropic API response format
            if (result.data.type === 'content_block_delta' && result.data.delta?.text) {
              try {
                // Try to parse each line as JSON
                const lines = result.data.delta.text.split('\n');
                for (const line of lines) {
                  if (line.trim()) {
                    try {
                      toolData = JSON.parse(line.trim());
                      if (toolData.tool) {
                        this.pendingQueue.push(toolData);
                        if (!this.isWaitingForApproval) {
                          this.processQueue();
                        }
                      }
                    } catch (e) {
                      // Not a valid JSON line, continue
                    }
                  }
                }
              } catch (e) {
                // Not JSON, skip
              }
            } else if (toolData.tool) {
              // Direct tool format
              this.pendingQueue.push(toolData);
              if (!this.isWaitingForApproval) {
                this.processQueue();
              }
            }
          }
        }
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      if (this.callbacks.onError) {
        this.callbacks.onError(errorMessage);
      }
      throw error;
    }
  }

  public getIsWaitingForApproval(): boolean {
    return this.isWaitingForApproval;
  }
}












import { Component, OnInit } from '@angular/core';
import { ChunkedJsonParserService, ToolData, ApprovalRequest } from './chunked-json-parser.service';

@Component({
  selector: 'app-chunked-json-parser',
  templateUrl: './chunked-json-parser.component.html',
  styleUrls: ['./chunked-json-parser.component.css']
})
export class ChunkedJsonParserComponent implements OnInit {
  public isWaitingForApproval = false;
  public currentApprovalRequest: ApprovalRequest | null = null;
  public isProcessing = false;

  constructor(private parserService: ChunkedJsonParserService) {}

  ngOnInit(): void {
    this.setupCallbacks();
  }

  private setupCallbacks(): void {
    this.parserService.setCallbacks({
      onToolDetected: (toolData: ToolData) => {
        this.logToolDetected(toolData);
      },
      onApprovalRequest: (approvalRequest: ApprovalRequest) => {
        this.isWaitingForApproval = true;
        this.currentApprovalRequest = approvalRequest;
        this.logWaitingForApproval(approvalRequest.data);
      },
      onCompletion: () => {
        this.isProcessing = false;
        this.logCompleted();
      },
      onError: (error: string) => {
        this.isProcessing = false;
        this.logError(error);
      }
    });
  }

  private logToolDetected(toolData: ToolData): void {
    const tool = toolData.tool;
    
    if (tool === 'READ') {
      console.log('üìñ READ Tool detected:', toolData);
    } else if (tool === 'WRITE') {
      console.log('‚úèÔ∏è WRITE Tool detected:', toolData);
    } else if (tool === 'MODIFY') {
      console.log('üîß MODIFY Tool detected:', toolData);
    } else {
      console.log('üîπ Tool detected:', toolData);
    }
  }

  private logWaitingForApproval(toolData: ToolData): void {
    console.log(`‚ö†Ô∏è WAITING FOR APPROVAL - ${toolData.tool} Tool:`, toolData);
    console.log('Click "ACCEPT AND CONTINUE" button to proceed');
  }

  private logCompleted(): void {
    console.log('üéâ COMPLETED - All operations finished successfully');
  }

  private logError(error: string): void {
    console.error('‚ùå Error:', error);
  }

  public async runDemo(): Promise<void> {
    console.clear();
    console.log('üöÄ Starting streaming process...\n');
    
    this.isProcessing = true;
    
    try {
      await this.parserService.startStreaming();
    } catch (error) {
      console.error('Failed to start streaming:', error);
      this.isProcessing = false;
    }
  }

  public approveAndContinue(): void {
    if (this.currentApprovalRequest) {
      console.log('‚úÖ APPROVED:', this.currentApprovalRequest.data);
      console.log('Continuing with next operation...\n');
      
      // Reset approval state
      this.isWaitingForApproval = false;
      this.currentApprovalRequest = null;
      
      this.parserService.approveAndContinue();
    }
  }
}
















<div class="parser-container">
  <h2>Chunked JSON Parser</h2>
  
  <div class="button-container">
    <button 
      class="btn btn-primary" 
      (click)="runDemo()" 
      [disabled]="isProcessing">
      {{ isProcessing ? 'Processing...' : 'RUN' }}
    </button>
    
    <button 
      *ngIf="isWaitingForApproval" 
      class="btn btn-success" 
      (click)="approveAndContinue()">
      ACCEPT AND CONTINUE
    </button>
  </div>

  <div *ngIf="isProcessing" class="status-message">
    <p>Processing stream... Check console for logs.</p>
  </div>

  <div *ngIf="isWaitingForApproval && currentApprovalRequest" class="approval-message">
    <h3>‚ö†Ô∏è Approval Required</h3>
    <p><strong>Tool:</strong> {{ currentApprovalRequest.data.tool }}</p>
    <p><strong>Content:</strong> {{ currentApprovalRequest.data.content }}</p>
    <p class="warning-text">Click "ACCEPT AND CONTINUE" to proceed</p>
  </div>
</div>
