import {
  Component,
  ElementRef,
  ViewChild,
  AfterViewInit,
} from '@angular/core';
import * as echarts from 'echarts';
import { EChartsOption, BarSeriesOption } from 'echarts';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-charts',
  templateUrl: './charts.component.html',
  styleUrls: ['./charts.component.scss'],
})
export class ChartsComponent implements AfterViewInit {
  @ViewChild('chartContainer') chartContainer!: ElementRef;
  chartInstance!: echarts.ECharts;

  fromDateStr: string;
  toDateStr: string;

  appliedFromDate!: Date;
  appliedToDate!: Date;
  appliedGranularity: any = null;

  minDate: string = '2024-01-01';
  maxDate: string = new Date().toISOString().split('T')[0];

  allGranularities = [
    { label: 'Year', value: 'year' },
    { label: 'Month', value: 'month' },
    { label: 'Week', value: 'week' },
    { label: 'Day', value: 'day' },
  ];
  availableGranularities = [...this.allGranularities];
  selectedGranularity = this.allGranularities[0];

  allLanguages: string[] = [];
  dailyData: any[] = [];
  aggregatedData: any[] = [];

  constructor(private http: HttpClient) {
    const today = new Date();
    const sevenDaysAgo = new Date(today);
    sevenDaysAgo.setDate(today.getDate() - 7);

    this.toDateStr = today.toISOString().split('T')[0];
    this.fromDateStr = sevenDaysAgo.toISOString().split('T')[0];
  }

  get fromDate(): Date {
    return new Date(this.fromDateStr);
  }

  get toDate(): Date {
    return new Date(this.toDateStr);
  }

  ngAfterViewInit() {
    this.chartInstance = echarts.init(this.chartContainer.nativeElement);
    setTimeout(() => this.applyDateRange());
  }

  applyDateRange() {
    if (this.fromDate > this.toDate) {
      alert('From date cannot be after To date.');
      return;
    }

    this.appliedFromDate = this.fromDate;
    this.appliedToDate = this.toDate;
    this.appliedGranularity = this.selectedGranularity;

    this.fetchDataFromApi();
  }

  fetchDataFromApi() {
    const formatDateToDDMMYYYY = (date: Date): string => {
      const dd = String(date.getDate()).padStart(2, '0');
      const mm = String(date.getMonth() + 1).padStart(2, '0');
      const yyyy = date.getFullYear();
      return `${dd}-${mm}-${yyyy}`;
    };

    const payload = {
      fromDate: formatDateToDDMMYYYY(this.appliedFromDate),
      toDate: formatDateToDDMMYYYY(this.appliedToDate),
    };

    this.http.post<any[]>('https://your-api.com/loc', payload).subscribe({
      next: (response) => {
        const languageSet = new Set<string>();
        const grouped: Record<string, any> = {};

        for (const entry of response) {
          const dateKey = entry.date;
          languageSet.add(entry.language);

          if (!grouped[dateKey]) {
            grouped[dateKey] = { date: new Date(dateKey) };
          }

          if (!(entry.language in grouped[dateKey])) {
            grouped[dateKey][entry.language] = 0;
          }

          grouped[dateKey][entry.language] += entry.loc;
        }

        this.allLanguages = Array.from(languageSet);
        this.dailyData = Object.values(grouped);

        this.filterGranularities(); // Triggers aggregate + chart update
      },
      error: (err) => {
        console.error('API error:', err);
        alert('Failed to fetch data.');
      }
    });
  }

  onGranularityChanged(event: Event) {
    const selectElement = event.target as HTMLSelectElement;
    const selectedIndex = selectElement.selectedIndex;
    this.selectedGranularity = this.availableGranularities[selectedIndex];

    this.appliedGranularity = this.selectedGranularity;
    this.aggregateData();
    this.updateChart();
  }

  filterGranularities() {
    const diff = this.appliedToDate.getTime() - this.appliedFromDate.getTime();
    const days = diff / (1000 * 3600 * 24);

    let filtered = [];

    if (days >= 365) {
      filtered = this.allGranularities;
    } else if (days >= 30) {
      filtered = this.allGranularities.filter(g =>
        ['month', 'week', 'day'].includes(g.value)
      );
    } else if (days > 7) {
      filtered = this.allGranularities.filter(g =>
        ['week', 'day'].includes(g.value)
      );
    } else {
      filtered = this.allGranularities.filter(g =>
        g.value === 'day'
      );
    }

    this.availableGranularities = filtered;
    this.selectedGranularity = filtered[0];
    this.appliedGranularity = this.selectedGranularity;

    this.aggregateData();
    this.updateChart();
  }

  aggregateData() {
    const map = new Map<string, any>();

    for (const entry of this.dailyData) {
      const dateObj = new Date(entry.date);
      const key = this.getAggregationKey(dateObj);

      if (!map.has(key)) {
        const aggregated: any = { date: key };
        for (const lang of this.allLanguages) aggregated[lang] = 0;
        map.set(key, aggregated);
      }

      const aggregated = map.get(key);
      for (const lang of this.allLanguages) {
        if (entry[lang]) aggregated[lang] += entry[lang];
      }
    }

    this.aggregatedData = Array.from(map.values());
  }

  getAggregationKey(date: Date): string {
    const y = date.getFullYear();
    const mShort = date.toLocaleString('default', { month: 'short' });

    switch (this.appliedGranularity.value) {
      case 'year':
        return `${y}`;
      case 'month':
        return `${mShort} ${y}`;
      case 'week': {
        const start = this.getWeekStart(date);
        const end = this.getWeekEnd(start);
        return `${this.mmdd(start)} - ${this.mmdd(end)}`;
      }
      case 'day':
      default:
        return this.mmdd(date);
    }
  }

  getWeekStart(date: Date): Date {
    const d = new Date(date);
    const day = d.getDay();
    const diff = d.getDate() - day + (day === 0 ? -6 : 1);
    return new Date(d.setDate(diff));
  }

  getWeekEnd(startDate: Date): Date {
    return new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() + 6);
  }

  mmdd(date: Date): string {
    const mm = (date.getMonth() + 1).toString().padStart(2, '0');
    const dd = date.getDate().toString().padStart(2, '0');
    return `${mm}/${dd}`;
  }

  formatDateRange(start: Date, end: Date): string {
    if (!start || !end) return '';
    const options: Intl.DateTimeFormatOptions = {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    };
    return `${start.toLocaleDateString('en-US', options)} - ${end.toLocaleDateString('en-US', options)}`;
  }

  updateChart() {
    const series: BarSeriesOption[] = this.allLanguages.map((lang) => ({
      name: lang,
      type: 'bar',
      stack: 'total',
      emphasis: { focus: 'series' },
      data: this.aggregatedData.map((d) => d[lang] || 0),
    }));

    const option: EChartsOption = {
      tooltip: { trigger: 'axis' },
      legend: {
        type: 'scroll',
        orient: 'horizontal',
        top: 10,
        left: '10%',
        right: '10%',
        pageButtonItemGap: 8,
        pageButtonGap: 5,
        pageTextStyle: { color: '#444' }
      },
      grid: {
        top: 80,
        left: '3%',
        right: '4%',
        bottom: '3%',
        containLabel: true
      },
      dataZoom: [{ type: 'slider', xAxisIndex: 0 }],
      textStyle: { fontSize: 14 },
      xAxis: {
        type: 'category',
        data: this.aggregatedData.map((d) => d.date),
        axisLabel: { rotate: 45 },
      },
      yAxis: {
        type: 'value',
        name: 'Lines of Code',
      },
      series: series as echarts.SeriesOption[],
    };

    this.chartInstance.setOption(option);
  }
}













<div class="controls-container">
    <div class="controls">
        <div class="left-group">
            <input type="date" [(ngModel)]="fromDateStr" class="date-input styled-input" [attr.min]="minDate"
                [attr.max]="maxDate" />
            <input type="date" [(ngModel)]="toDateStr" class="date-input styled-input" [attr.min]="minDate"
                [attr.max]="maxDate" />

            <button pButton type="button" label="Apply" (click)="applyDateRange()"
                class="p-button-sm apply-button"></button>
        </div>

        <div class="right-group">
            <select [(ngModel)]="selectedGranularity" (change)="onGranularityChanged($event)" class="styled-dropdown">
                <option *ngFor="let g of availableGranularities" [ngValue]="g">{{ g.label }}</option>
            </select>
        </div>
    </div>

    <div class="selected-period">
        <span class="period-label">ðŸ“… Selected Period:</span>
        <strong>{{ formatDateRange(appliedFromDate, appliedToDate) }}</strong>
    </div>
</div>

<div #chartContainer class="chart-container"></div>











.controls-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 1rem;
}

.controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 2rem;
}

.left-group,
.right-group {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.styled-input {
    width: 130px;
    padding: 6px 10px;
    font-size: 14px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    outline: none;
    transition: border-color 0.2s ease;
}

.styled-input:focus {
    border-color: #007ad9;
}

.styled-dropdown {
    width: 130px;
    height: 34px;
    font-size: 14px;
    padding: 6px 10px;
    border-radius: 4px;
    border: 1px solid #ced4da;
    appearance: none;
    background-color: white;
    background-image: url("data:image/svg+xml,%3Csvg fill='gray' height='16' viewBox='0 0 24 24' width='16' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 12px;
    cursor: pointer;
}

.styled-dropdown:focus {
    border-color: #007ad9;
}

.apply-button {
    height: 34px;
}

.selected-period {
    margin-top: 0.5rem;
    font-size: 15px;
    color: #444;
    background-color: #f7f7f7;
    padding: 8px 16px;
    border-radius: 8px;
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.05);
    display: flex;
    align-items: center;
    gap: 5px;
}

.period-label {
    color: #555;
}

.chart-container {
    width: 100%;
    height: 600px;
    font-size: 14px;
}
