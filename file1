import { Component, Input, OnInit, OnDestroy } from '@angular/core';

@Component({
  selector: 'app-ai-thinking-animation',
  template: `
    <div class="ai-response">
      <div class="ai-avatar">AI</div>
      
      <div class="response-content">
        <div class="thinking-animation">
          <div class="brain-container">
            <div class="neuron" *ngFor="let neuron of neurons; let i = index" 
                 [style.top.px]="neuron.top" 
                 [style.left.px]="neuron.left"
                 [style.background]="neuron.color"
                 [style.animation-delay.s]="neuron.delay">
            </div>
            <div class="connection" *ngFor="let connection of connections; let i = index"
                 [style.top.px]="connection.top"
                 [style.left.px]="connection.left" 
                 [style.width.px]="connection.width"
                 [style.transform]="'rotate(' + connection.rotation + 'deg)'"
                 [style.animation-delay.s]="connection.delay">
            </div>
          </div>
          
          <div class="thinking-content">
            <div class="thinking-text">{{ statusText }}</div>
            <div class="thought-words">
              <span class="word" *ngFor="let word of thoughtWords; let i = index"
                    [style.animation-delay.s]="word.delay">
                {{ word.text }}
              </span>
            </div>
          </div>
        </div>
        
        <div class="processing-indicator" *ngIf="showSpinner">
          <div class="spinner"></div>
          <span>{{ processingMessage }}</span>
        </div>
      </div>
    </div>
  `,
  styles: [`
    .ai-response {
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }

    .ai-avatar {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: linear-gradient(135deg, #8b5cf6, #06b6d4);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 14px;
      flex-shrink: 0;
    }

    .thinking-animation {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 16px 0;
    }

    .brain-container {
      position: relative;
      width: 60px;
      height: 40px;
    }

    .neuron {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #8b5cf6;
      animation: neuronFire 2s infinite ease-in-out;
    }

    .connection {
      position: absolute;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.6), transparent);
      animation: synapseFlow 2s infinite ease-in-out;
    }

    .thinking-text {
      color: #999;
      font-size: 14px;
      font-weight: 500;
    }

    .thought-words {
      display: flex;
      gap: 8px;
      margin-left: 8px;
    }

    .word {
      color: #666;
      font-size: 12px;
      opacity: 0;
      animation: wordAppear 3s infinite ease-in-out;
    }

    .processing-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 12px;
      color: #666;
      font-size: 12px;
    }

    .spinner {
      width: 12px;
      height: 12px;
      border: 1px solid #333;
      border-top: 1px solid #8b5cf6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes neuronFire {
      0%, 100% {
        transform: scale(1);
        opacity: 0.6;
        box-shadow: 0 0 0 rgba(139, 92, 246, 0);
      }
      50% {
        transform: scale(1.5);
        opacity: 1;
        box-shadow: 0 0 20px rgba(139, 92, 246, 0.8);
      }
    }

    @keyframes synapseFlow {
      0% {
        opacity: 0;
        transform: scale(0.5);
      }
      50% {
        opacity: 1;
        transform: scale(1);
      }
      100% {
        opacity: 0;
        transform: scale(0.5);
      }
    }

    @keyframes wordAppear {
      0%, 20% {
        opacity: 0;
        transform: translateY(10px);
      }
      30%, 70% {
        opacity: 1;
        transform: translateY(0);
      }
      80%, 100% {
        opacity: 0;
        transform: translateY(-10px);
      }
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  `]
})
export class AiThinkingAnimationComponent implements OnInit, OnDestroy {
  @Input() statusText: string = 'Processing your request';
  @Input() processingMessage: string = 'AI is thinking deeply about your request';
  @Input() showSpinner: boolean = true;
  @Input() customThoughtWords: string[] = [];

  neurons = [
    { top: 5, left: 10, color: '#8b5cf6', delay: 0 },
    { top: 15, left: 25, color: '#06b6d4', delay: 0.3 },
    { top: 8, left: 40, color: '#00ff88', delay: 0.6 },
    { top: 25, left: 15, color: '#ff6b6b', delay: 0.9 },
    { top: 30, left: 35, color: '#ffd93d', delay: 1.2 }
  ];

  connections = [
    { top: 9, left: 18, width: 15, rotation: 20, delay: 0.3 },
    { top: 19, left: 33, width: 12, rotation: -30, delay: 0.6 },
    { top: 29, left: 23, width: 18, rotation: 10, delay: 0.9 }
  ];

  thoughtWords: Array<{text: string, delay: number}> = [];

  private defaultWords = ['analyzing...', 'understanding...', 'generating...', 'crafting...'];

  ngOnInit() {
    this.initializeThoughtWords();
  }

  ngOnDestroy() {
    // Cleanup if needed
  }

  private initializeThoughtWords() {
    const wordsToUse = this.customThoughtWords.length > 0 ? this.customThoughtWords : this.defaultWords;
    
    this.thoughtWords = wordsToUse.map((word, index) => ({
      text: word,
      delay: 0.5 + (index * 0.5)
    }));
  }

  // Method to restart animation (can be called from parent component)
  restartAnimation() {
    // Trigger change detection to restart animations
    this.thoughtWords = [...this.thoughtWords];
    this.neurons = [...this.neurons];
    this.connections = [...this.connections];
  }

  // Method to update thought words dynamically
  updateThoughtWords(newWords: string[]) {
    this.customThoughtWords = newWords;
    this.initializeThoughtWords();
  }

  // Method to update status text
  updateStatus(newStatus: string, newProcessingMessage?: string) {
    this.statusText = newStatus;
    if (newProcessingMessage) {
      this.processingMessage = newProcessingMessage;
    }
  }
}
