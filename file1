import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

export interface FileItem {
  id: number;
  original_name: string;
  inserted_at: string;
  progress: string | null;
  summary_prompt: string | null;  // New property
  faq_prompt: string | null;      // New property
}

export interface FilesResponse {
  status: string;
  data: {
    files: FileItem[];
  };
}

export interface DateRangeRequest {
  start_date: string;
  end_date: string;
}

@Injectable({
  providedIn: 'root'
})
export class HistoryService {
  private apiUrl = 'http://localhost:3000/api';

  constructor(private http: HttpClient) {}

  getFilesByDateRange(startDate: string, endDate: string): Observable<FilesResponse> {
    const payload: DateRangeRequest = {
      start_date: startDate,
      end_date: endDate
    };

    return this.http.post<FilesResponse>(
      `${this.apiUrl}/content_analytics/files/by-date/`, 
      payload
    );
  }
}








import { Component, EventEmitter, Output, Input, OnInit, OnChanges, SimpleChanges } from '@angular/core';
import { HistoryService, FileItem } from './history.service';

interface HistoryItem {
  id: string;
  name: string;
  displayDate: string;
  date: Date;
  hasResult: boolean;
  summary_prompt: string | null;  // New property
  faq_prompt: string | null;      // New property
}

export interface HistoryItemSelect {
  id: string;
  name: string;
  displayDate: string;
  date: Date;
  summary_prompt: string | null;  // New property
  faq_prompt: string | null;      // New property
}

interface RemoveGenerateFile {
  id: number;
  name: string;
}

interface GenerationStatus {
  id: number;
  status: 'Success' | 'Failure';
}

interface NewUploadFile {
  id: number;
  original_name: string;
  created_at: string;
}

@Component({
  selector: 'app-history',
  templateUrl: './history.component.html',
  styleUrls: ['./history.component.css']
})
export class HistoryComponent implements OnInit, OnChanges {
  @Input() removeGenerateFile: RemoveGenerateFile | null = null;
  @Input() generationStatus: GenerationStatus | null = null;
  @Input() newUploadFile: NewUploadFile | null = null;
  
  @Output() onItemSelect = new EventEmitter<HistoryItemSelect>();
  @Output() onAddToContentGeneration = new EventEmitter<HistoryItem>();
  @Output() onRemoveFromContentGeneration = new EventEmitter<string>();

  selectedHistoryItem: HistoryItem | null = null;
  addedToGenerationId: string | null = null;
  isPendingExpanded: boolean = true;
  isCompletedExpanded: boolean = true;

  startDate: string = '';
  endDate: string = '';

  historyItems: HistoryItem[] = [];
  isLoading: boolean = false;
  isRefreshing: boolean = false;
  errorMessage: string = '';

  // Filter properties
  isFilterVisible: boolean = false;
  filterFromDate: string = '';
  filterToDate: string = '';
  searchText: string = '';

  constructor(private historyService: HistoryService) {}

  ngOnInit(): void {
    this.initializeDateRange();
    this.fetchHistoryData();
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['removeGenerateFile'] && changes['removeGenerateFile'].currentValue) {
      const fileToRemove = changes['removeGenerateFile'].currentValue as RemoveGenerateFile;
      this.handleRemoveFromParent(fileToRemove);
    }

    if (changes['generationStatus'] && changes['generationStatus'].currentValue) {
      const statusUpdate = changes['generationStatus'].currentValue as GenerationStatus;
      this.handleGenerationStatusChange(statusUpdate);
    }

    if (changes['newUploadFile'] && changes['newUploadFile'].currentValue) {
      const newFile = changes['newUploadFile'].currentValue as NewUploadFile;
      this.handleNewFileUpload(newFile);
    }
  }

  get pendingFiles(): HistoryItem[] {
    return this.historyItems.filter(item => !item.hasResult);
  }

  get completedFiles(): HistoryItem[] {
    return this.historyItems.filter(item => item.hasResult);
  }

  get filteredPendingFiles(): HistoryItem[] {
    return this.applyTextSearch(this.pendingFiles);
  }

  get filteredCompletedFiles(): HistoryItem[] {
    return this.applyTextSearch(this.completedFiles);
  }

  onHistoryItemClick(itemId: string): void {
    const item = this.historyItems.find(i => i.id === itemId);
    if (item) {
      this.selectedHistoryItem = item;
      
      // Emit only the required properties
      const itemToEmit: HistoryItemSelect = {
        id: item.id,
        name: item.name,
        displayDate: item.displayDate,
        date: item.date,
        summary_prompt: item.summary_prompt,  // Include new property
        faq_prompt: item.faq_prompt           // Include new property
      };
      
      this.onItemSelect.emit(itemToEmit);
    }
  }

  // ... other methods ...

  private mapFilesToHistoryItems(files: FileItem[]): HistoryItem[] {
    return files.map(file => {
      const hasResult = file.progress === 'completed';

      return {
        id: file.id.toString(),
        name: file.original_name,
        displayDate: `Created on ${file.inserted_at}`,
        date: this.parseInsertedDate(file.inserted_at),
        hasResult: hasResult,
        summary_prompt: file.summary_prompt,  // Map new property
        faq_prompt: file.faq_prompt           // Map new property
      };
    });
  }

  private handleGenerationStatusChange(statusUpdate: GenerationStatus): void {
    const itemId = statusUpdate.id.toString();
    const item = this.historyItems.find(i => i.id === itemId);

    if (!item) {
      console.warn('Item not found for status update:', itemId);
      return;
    }

    console.log(`Generation status update for item ${itemId}: ${statusUpdate.status}`);

    if (statusUpdate.status === 'Success') {
      // Move to Completed Results
      if (!item.hasResult) {
        console.log(`Moving item ${itemId} to Completed Results`);
        
        // Update the item's hasResult property first
        item.hasResult = true;

        // Expand Completed section if it's collapsed
        if (!this.isCompletedExpanded) {
          this.isCompletedExpanded = true;
        }

        // Wait for DOM to update, then find element, animate, scroll and select
        setTimeout(() => {
          const historyItemElement = document.querySelector(
            `.history-item[data-item-id="${itemId}"]`
          ) as HTMLElement;

          if (historyItemElement) {
            // Add success animation
            historyItemElement.classList.add('success-animation');
            setTimeout(() => {
              historyItemElement.classList.remove('success-animation');
            }, 1000);

            // Scroll to the card smoothly
            historyItemElement.scrollIntoView({
              behavior: 'smooth',
              block: 'center',
              inline: 'nearest'
            });

            // Select the card after scrolling
            setTimeout(() => {
              this.selectedHistoryItem = item;
              
              // Emit the correct format with new properties
              const itemToEmit: HistoryItemSelect = {
                id: item.id,
                name: item.name,
                displayDate: item.displayDate,
                date: item.date,
                summary_prompt: item.summary_prompt,
                faq_prompt: item.faq_prompt
              };
              
              this.onItemSelect.emit(itemToEmit);
              console.log(`Card ${itemId} selected and scrolled into view`);
            }, 300);
          }
        }, 100);
      } else {
        // Item was already in Completed section
        const historyItemElement = document.querySelector(
          `.history-item[data-item-id="${itemId}"]`
        ) as HTMLElement;

        if (historyItemElement) {
          // Add success animation
          historyItemElement.classList.add('success-animation');
          setTimeout(() => {
            historyItemElement.classList.remove('success-animation');
          }, 1000);

          // Scroll to the card smoothly
          historyItemElement.scrollIntoView({
            behavior: 'smooth',
            block: 'center',
            inline: 'nearest'
          });

          // Select the card after scrolling
          setTimeout(() => {
            this.selectedHistoryItem = item;
            
            // Emit the correct format with new properties
            const itemToEmit: HistoryItemSelect = {
              id: item.id,
              name: item.name,
              displayDate: item.displayDate,
              date: item.date,
              summary_prompt: item.summary_prompt,
              faq_prompt: item.faq_prompt
            };
            
            this.onItemSelect.emit(itemToEmit);
            console.log(`Card ${itemId} selected and scrolled into view`);
          }, 300);
        }
      }

      // Clear the added state (remove minus icon, restore plus icon)
      if (this.addedToGenerationId === itemId) {
        console.log(`Clearing added state for item ${itemId} - restoring plus icon`);
        this.addedToGenerationId = null;
      }
    } else if (statusUpdate.status === 'Failure') {
      // Move to Pending Results
      if (item.hasResult) {
        console.log(`Moving item ${itemId} to Pending Results`);
        
        // Update the item's hasResult property first
        item.hasResult = false;

        // Expand Pending section if it's collapsed
        if (!this.isPendingExpanded) {
          this.isPendingExpanded = true;
        }

        // Wait for DOM to update, then find element and animate
        setTimeout(() => {
          const historyItemElement = document.querySelector(
            `.history-item[data-item-id="${itemId}"]`
          ) as HTMLElement;

          if (historyItemElement) {
            // Add failure animation
            historyItemElement.classList.add('failure-animation');
            setTimeout(() => {
              historyItemElement.classList.remove('failure-animation');
            }, 1000);
          }
        }, 100);
      } else {
        // Item was already in Pending section
        const historyItemElement = document.querySelector(
          `.history-item[data-item-id="${itemId}"]`
        ) as HTMLElement;

        if (historyItemElement) {
          // Add failure animation
          historyItemElement.classList.add('failure-animation');
          setTimeout(() => {
            historyItemElement.classList.remove('failure-animation');
          }, 1000);
        }
      }

      // Clear the added state (remove minus icon, restore plus icon)
      if (this.addedToGenerationId === itemId) {
        console.log(`Clearing added state for item ${itemId} - restoring plus icon`);
        this.addedToGenerationId = null;
      }
    }
  }

  private handleNewFileUpload(newFile: NewUploadFile): void {
    console.log('New file uploaded:', newFile);

    // Check if file already exists (prevent duplicates)
    const existingFile = this.historyItems.find(item => item.id === newFile.id.toString());
    if (existingFile) {
      console.warn('File already exists in history:', newFile.id);
      return;
    }

    // Create new history item
    const newHistoryItem: HistoryItem = {
      id: newFile.id.toString(),
      name: newFile.original_name,
      displayDate: `Created on ${newFile.created_at}`,
      date: new Date(newFile.created_at),
      hasResult: false, // Always add to Pending Results
      summary_prompt: null,  // Initialize new properties as null
      faq_prompt: null       // Initialize new properties as null
    };

    // Add to the beginning of the array (top of the list)
    this.historyItems.unshift(newHistoryItem);

    // Expand Pending section if it's collapsed
    if (!this.isPendingExpanded) {
      this.isPendingExpanded = true;
    }

    console.log('New file added to Pending Results:', newHistoryItem);

    // Wait for DOM to update, then scroll to and highlight the new item
    setTimeout(() => {
      const historyItemElement = document.querySelector(
        `.history-item[data-item-id="${newFile.id}"]`
      ) as HTMLElement;

      if (historyItemElement) {
        // Add new item animation (slide in from top)
        historyItemElement.classList.add('new-item-animation');
        setTimeout(() => {
          historyItemElement.classList.remove('new-item-animation');
        }, 800);

        // Scroll to the new card
        historyItemElement.scrollIntoView({
          behavior: 'smooth',
          block: 'start',
          inline: 'nearest'
        });
      }
    }, 100);
  }

  // ... rest of the methods remain the same ...
}









// parent.component.ts
export class ParentComponent {
  removeGenerateFile: { id: number; name: string } | null = null;
  generationStatus: { id: number; status: 'Success' | 'Failure' } | null = null;
  newUploadFile: { id: number; original_name: string; created_at: string } | null = null;

  // Updated handler to receive properties including new ones
  handleItemSelect(item: { 
    id: string; 
    name: string; 
    displayDate: string; 
    date: Date;
    summary_prompt: string | null;
    faq_prompt: string | null;
  }) {
    console.log('Selected Item ID:', item.id);
    console.log('Selected Item Name:', item.name);
    console.log('Selected Item Display Date:', item.displayDate);
    console.log('Selected Item Date:', item.date);
    console.log('Summary Prompt:', item.summary_prompt);
    console.log('FAQ Prompt:', item.faq_prompt);
    
    // Use the prompts if they exist
    if (item.summary_prompt) {
      console.log('Has summary prompt:', item.summary_prompt);
    }
    
    if (item.faq_prompt) {
      console.log('Has FAQ prompt:', item.faq_prompt);
    }
  }

  handleAddToGeneration(item: any) {
    console.log('File added:', item);
    console.log('Summary Prompt:', item.summary_prompt);
    console.log('FAQ Prompt:', item.faq_prompt);
  }

  handleRemoveFromGeneration(itemId: string) {
    console.log('File removed:', itemId);
  }
}
