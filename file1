if (this.viewMode === 'side-by-side') {
  // In side-by-side mode, look for line numbers directly in the row
  const lineNumberElements = row.querySelectorAll('.d2h-code-side-linenumber');
  
  if (lineNumberElements.length === 0) return; // Skip rows without line numbers
  
  Array.from(lineNumberElements).forEach((lineNumElement) => {
    if (commentInserted) return;
    
    const lineText = lineNumElement.textContent?.trim() || '';
    const lineNum = parseInt(lineText);
    
    if (isNaN(lineNum) || lineNum !== comment.line) return;
    
    // Determine which side by checking the parent td's position
    const parentTd = lineNumElement.closest('td');
    if (!parentTd) return;
    
    const allTds = Array.from(row.querySelectorAll('td'));
    const tdIndex = allTds.indexOf(parentTd as HTMLTableCellElement);
    
    // In side-by-side mode, the table structure is typically:
    // [line-num-left] [code-left] [line-num-right] [code-right]
    // So line number cells at even positions (0, 2, 4) are left/FROM
    // And line number cells at odd positions (1, 3, 5) are right/TO
    // OR it could be structured as:
    // [line-num-left] [code-left] | [line-num-right] [code-right]
    // Let's check the total columns and determine the midpoint
    const totalColumns = allTds.length;
    const isLeftSide = tdIndex < totalColumns / 2;
    const isRightSide = tdIndex >= totalColumns / 2;
    
    // Check if this matches the comment's side
    const shouldInsertHere = (comment.side === 'FROM' && isLeftSide) || 
                            (comment.side === 'TO' && isRightSide);
    
    if (!shouldInsertHere) {
      console.log(`Skipping: Line ${lineNum} at td index ${tdIndex} (total: ${totalColumns}), need side ${comment.side}, this is ${isLeftSide ? 'LEFT/FROM' : 'RIGHT/TO'}`);
      return;
    }

    const nextRow = row.nextElementSibling;
    if (nextRow && nextRow.classList.contains('comment-row')) {
      commentInserted = true;
      return;
    }

    const commentRow = document.createElement('tr');
    commentRow.className = 'comment-row';

    const commentCell = document.createElement('td');
    commentCell.className = 'comment-cell';
    
    // Count total columns in the row
    commentCell.setAttribute('colspan', totalColumns.toString());
    commentCell.style.padding = '0';
    commentCell.style.border = 'none';
    commentCell.style.backgroundColor = 'var(--bitbucket-file-comparator-bg-overlay)';

    const wrapperDiv = document.createElement('div');
    wrapperDiv.className = 'comment-wrapper';
    wrapperDiv.style.width = '100%';
    wrapperDiv.style.display = 'block';

    commentClone.style.display = 'block';
    commentClone.style.visibility = 'visible';
    commentClone.style.opacity = '1';

    wrapperDiv.appendChild(commentClone);
    commentCell.appendChild(wrapperDiv);
    commentRow.appendChild(commentCell);

    row.parentNode?.insertBefore(commentRow, row.nextSibling);

    commentInserted = true;
    console.log(`âœ“ Comment inserted for line ${comment.line} (side: ${comment.side}) at td index ${tdIndex}`);
  });
}
