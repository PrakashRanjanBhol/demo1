import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { BehaviorSubject, Observable, throwError, Subject } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';
import { Router } from '@angular/router';
import { environment } from '../environments/environment';

export interface User {
  id: string;
  email: string;
  name: string;
  avatar?: string;
  role?: string;
}

export interface AuthResponse {
  user: User;
  token?: string;
}

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private apiUrl = 'YOUR_API_BASE_URL';
  private wsUrl = 'YOUR_WEBSOCKET_URL'; // Add your WebSocket URL
  private ws: WebSocket | null = null;
  private currentUserSubject: BehaviorSubject<User | null>;
  public currentUser: Observable<User | null>;
  private authCheckCompleteSubject: BehaviorSubject<boolean>;
  public authCheckComplete: Observable<boolean>;
  private ssoErrorSubject = new Subject<string>();
  public ssoError$ = this.ssoErrorSubject.asObservable();

  constructor(
    private http: HttpClient,
    private router: Router
  ) {
    this.currentUserSubject = new BehaviorSubject<User | null>(null);
    this.currentUser = this.currentUserSubject.asObservable();
    this.authCheckCompleteSubject = new BehaviorSubject<boolean>(false);
    this.authCheckComplete = this.authCheckCompleteSubject.asObservable();
  }

  public get currentUserValue(): User | null {
    return this.currentUserSubject.value;
  }

  public get isAuthCheckComplete(): boolean {
    return this.authCheckCompleteSubject.value;
  }

  checkAuthStatus(): Observable<AuthResponse> {
    return this.http.get<AuthResponse>(`${this.apiUrl}/auth/status`, {
      withCredentials: true
    }).pipe(
      tap(response => {
        this.currentUserSubject.next(response.user);
        this.authCheckCompleteSubject.next(true);
      }),
      catchError((error: HttpErrorResponse) => {
        this.currentUserSubject.next(null);
        this.authCheckCompleteSubject.next(true);
        return throwError(() => error);
      })
    );
  }

  // Initiate SSO login with WebSocket
  initiateSSO(): Observable<any> {
    return new Observable(observer => {
      // Create WebSocket connection
      this.ws = new WebSocket(this.wsUrl);

      this.ws.onopen = () => {
        console.log('WebSocket connection opened');
        
        // Send initial message
        const message = {
          rqtype: environment.SSO.RQTYPE,
          token: '',
          data: environment.SSO.DATA
        };
        
        this.ws?.send(JSON.stringify(message));
      };

      this.ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          
          if (msg?.recode === 'RETURN_SUCCESS') {
            // Success - make SSO API call
            const ssoInfo = msg?.data;
            this.performSSOLogin(ssoInfo).subscribe({
              next: (response) => {
                observer.next(response);
                observer.complete();
                this.closeWebSocket();
              },
              error: (error) => {
                observer.error(error);
                this.closeWebSocket();
              }
            });
          } else {
            // SSO login failed
            const errorMsg = 'SSO login failed';
            this.ssoErrorSubject.next(errorMsg);
            observer.error(new Error(errorMsg));
            this.closeWebSocket();
          }
        } catch (error) {
          observer.error(error);
          this.closeWebSocket();
        }
      };

      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        observer.error(new Error('WebSocket connection error'));
        this.closeWebSocket();
      };

      this.ws.onclose = () => {
        console.log('WebSocket connection closed');
      };
    });
  }

  // Perform SSO login API call
  private performSSOLogin(ssoInfo: any): Observable<AuthResponse> {
    const payload = {
      userInfo: ssoInfo.userInfo,
      aeskey: ssoInfo.key
    };

    return this.http.post<AuthResponse>(`${this.apiUrl}/auth/sso/login`, payload, {
      withCredentials: true
    }).pipe(
      tap(response => {
        this.currentUserSubject.next(response.user);
        this.authCheckCompleteSubject.next(true);
      }),
      catchError(this.handleError)
    );
  }

  // Close WebSocket connection
  private closeWebSocket(): void {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }

  handleSSOCallback(code: string): Observable<AuthResponse> {
    return this.http.post<AuthResponse>(`${this.apiUrl}/auth/sso/callback`, 
      { code },
      { withCredentials: true }
    ).pipe(
      tap(response => {
        this.currentUserSubject.next(response.user);
        this.authCheckCompleteSubject.next(true);
      }),
      catchError(this.handleError)
    );
  }

  logout(): Observable<any> {
    this.closeWebSocket(); // Close any open WebSocket connections
    return this.http.post(`${this.apiUrl}/auth/logout`, {}, {
      withCredentials: true
    }).pipe(
      tap(() => {
        this.currentUserSubject.next(null);
        this.router.navigate(['/sso-connect']);
      }),
      catchError(this.handleError)
    );
  }

  isAuthenticated(): boolean {
    return this.currentUserValue !== null;
  }

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'An error occurred';
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Error: ${error.error.message}`;
    } else {
      errorMessage = `Error Code: ${error.status}\nMessage: ${error.message}`;
    }
    console.error(errorMessage);
    return throwError(() => new Error(errorMessage));
  }
}












connectSSO(): void {
  if (this.isConnecting) return;
  
  this.isConnecting = true;
  this.errorMessage = '';

  this.authService.initiateSSO().subscribe({
    next: (response) => {
      console.log('SSO login successful:', response);
      this.isConnecting = false;
      this.router.navigate(['/content-analytics']);
    },
    error: (error) => {
      console.error('SSO login error:', error);
      this.errorMessage = error.message || 'SSO authentication failed. Please try again.';
      this.isConnecting = false;
    }
  });
}











export const environment = {
  production: false,
  SSO: {
    RQTYPE: 'YOUR_REQUEST_TYPE', // Replace with your actual request type
    DATA: {} // Replace with your actual data object
  }
};
