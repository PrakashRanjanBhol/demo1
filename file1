async renderStream(text, chunkSize = 5, delay = 50) {
    this.contentElement.innerHTML = '';
    this.buffer = '';
    
    // Add streaming cursor
    const cursor = document.createElement('span');
    cursor.className = 'streaming-cursor';
    this.contentElement.appendChild(cursor);
    
    // Simulate streaming by adding characters chunk by chunk
    for (let i = 0; i < text.length; i += chunkSize) {
        const chunk = text.slice(i, i + chunkSize);
        this.buffer += chunk;
        
        // Process the buffer
        this.processBuffer();
        
        // Re-add cursor at the end
        if (cursor.parentNode) {
            cursor.parentNode.removeChild(cursor);
        }
        this.contentElement.appendChild(cursor);
        
        await new Promise(resolve => setTimeout(resolve, delay));
    }
    
    // Final processing
    this.processBuffer(true);
    
    // Remove cursor
    if (cursor.parentNode) {
        cursor.parentNode.removeChild(cursor);
    }
}

processBuffer(isFinal = false) {
    // Try to extract complete code blocks from buffer
    const codeBlockRegex = /```(\w+)?\s*\n([\s\S]*?)\n```/g;
    let lastProcessedIndex = 0;
    let match;
    
    // Clear content except cursor
    const cursor = this.contentElement.querySelector('.streaming-cursor');
    this.contentElement.innerHTML = '';
    
    while ((match = codeBlockRegex.exec(this.buffer)) !== null) {
        const matchStart = match.index;
        const matchEnd = codeBlockRegex.lastIndex;
        
        // Render markdown before this code block
        const beforeMarkdown = this.buffer.slice(lastProcessedIndex, matchStart);
        if (beforeMarkdown.trim().length > 0) {
            const markdownElement = this.renderMarkdown(beforeMarkdown);
            while (markdownElement.firstChild) {
                this.contentElement.appendChild(markdownElement.firstChild);
            }
        }
        
        // Render the code block
        const language = match[1] || 'plaintext';
        const codeContent = match[2];
        const codeBlock = this.createCodeBlock(language, codeContent);
        this.contentElement.appendChild(codeBlock);
        
        lastProcessedIndex = matchEnd;
    }
    
    // Render remaining markdown (incomplete code blocks will show as markdown)
    const remaining = this.buffer.slice(lastProcessedIndex);
    if (remaining.trim().length > 0 || isFinal) {
        const markdownElement = this.renderMarkdown(remaining);
        while (markdownElement.firstChild) {
            this.contentElement.appendChild(markdownElement.firstChild);
        }
    }
    
    // Re-add cursor if it existed
    if (cursor) {
        this.contentElement.appendChild(cursor);
    }
}
