import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

export interface FileItem {
  id: number;
  original_name: string;
  inserted_at: string;
  progress: string | null;
}

export interface FilesResponse {
  status: string;
  data: {
    files: FileItem[];
  };
}

export interface DateRangeRequest {
  start_date: string;
  end_date: string;
}

@Injectable({
  providedIn: 'root'
})
export class HistoryService {
  private apiUrl = 'http://localhost:3000/api';

  constructor(private http: HttpClient) {}

  getFilesByDateRange(startDate: string, endDate: string): Observable<FilesResponse> {
    const payload: DateRangeRequest = {
      start_date: startDate,
      end_date: endDate
    };

    // Authorization header will be added automatically by the interceptor
    return this.http.post<FilesResponse>(
      `${this.apiUrl}/content_analytics/files/by-date/`, 
      payload
    );
  }
}















import { Component, EventEmitter, Output, OnInit } from '@angular/core';
import { HistoryService, FileItem } from './history.service';

interface HistoryItem {
  id: string;
  name: string;
  displayDate: string;
  date: Date;
  hasResult: boolean;
}

@Component({
  selector: 'app-history',
  templateUrl: './history.component.html',
  styleUrls: ['./history.component.css']
})
export class HistoryComponent implements OnInit {
  @Output() onItemSelect = new EventEmitter<string>();

  selectedHistoryItem: HistoryItem | null = null;
  isPendingExpanded: boolean = true;
  isCompletedExpanded: boolean = true;

  startDate: string = '';
  endDate: string = '';

  historyItems: HistoryItem[] = [];
  isLoading: boolean = false;
  errorMessage: string = '';

  constructor(private historyService: HistoryService) {}

  ngOnInit(): void {
    this.initializeDateRange();
    this.fetchHistoryData();
  }

  get pendingFiles(): HistoryItem[] {
    return this.historyItems.filter(item => !item.hasResult);
  }

  get completedFiles(): HistoryItem[] {
    return this.historyItems.filter(item => item.hasResult);
  }

  onHistoryItemClick(itemId: string): void {
    const item = this.historyItems.find(i => i.id === itemId);
    if (item) {
      this.selectedHistoryItem = item;
      this.onItemSelect.emit(itemId);
    }
  }

  togglePendingSection(): void {
    this.isPendingExpanded = !this.isPendingExpanded;
  }

  toggleCompletedSection(): void {
    this.isCompletedExpanded = !this.isCompletedExpanded;
  }

  clearSelection(): void {
    this.selectedHistoryItem = null;
  }

  addHistoryItem(item: HistoryItem): void {
    this.historyItems.unshift(item);
  }

  private initializeDateRange(): void {
    const today = new Date();
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(today.getDate() - 30);

    // Format for display in header (e.g., "Jan 13, 2026")
    this.startDate = this.formatDateForDisplay(thirtyDaysAgo);
    this.endDate = this.formatDateForDisplay(today);
  }

  private fetchHistoryData(): void {
    this.isLoading = true;
    this.errorMessage = '';

    const today = new Date();
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(today.getDate() - 30);

    // Format for API request (e.g., "2026-01-13")
    const startDateForApi = this.formatDateForApi(thirtyDaysAgo);
    const endDateForApi = this.formatDateForApi(today);

    this.historyService.getFilesByDateRange(startDateForApi, endDateForApi)
      .subscribe({
        next: (response) => {
          if (response.status === 'success' && response.data.files) {
            this.historyItems = this.mapFilesToHistoryItems(response.data.files);
          }
          this.isLoading = false;
        },
        error: (error) => {
          console.error('Error fetching history data:', error);
          this.errorMessage = 'Failed to load history data. Please try again.';
          this.isLoading = false;
        }
      });
  }

  private mapFilesToHistoryItems(files: FileItem[]): HistoryItem[] {
    return files.map(file => {
      // Determine if file has result (completed) or is pending
      // progress is null or has a numeric value -> pending
      // progress is 'completed' -> completed
      const hasResult = file.progress === 'completed';

      return {
        id: file.id.toString(),
        name: file.original_name,
        displayDate: `Created on ${file.inserted_at}`,
        date: this.parseInsertedDate(file.inserted_at),
        hasResult: hasResult
      };
    });
  }

  private parseInsertedDate(dateString: string): Date {
    // Parse "February 12, 2026" format to Date object
    return new Date(dateString);
  }

  private formatDateForDisplay(date: Date): string {
    // Format as "Jan 13, 2026"
    const options: Intl.DateTimeFormatOptions = { 
      month: 'short', 
      day: 'numeric', 
      year: 'numeric' 
    };
    return date.toLocaleDateString('en-US', options);
  }

  private formatDateForApi(date: Date): string {
    // Format as "2026-01-13"
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }
}
