import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';

@Component({
  selector: 'app-chat',
  templateUrl: './chat.component.html',
  styleUrls: ['./chat.component.css']
})
export class ChatComponent implements OnChanges {
  @Input() chunk: string = ''; // streamed chunk from parent

  htmlCode: string = '';
  cssCode: string = '';
  jsCode: string = '';
  otherCode: string = ''; // for codeblocks without language

  // Streaming parser state
  private unprocessed: string = '';
  private isInsideBlock = false;
  private currentLang: string | null = null;
  private waitingForLang = false;

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['chunk'] && this.chunk) {
      this.processChunk(this.chunk);
    }
  }

  private processChunk(chunk: string): void {
    if (!chunk) return;

    let normalized = chunk
      .replace(/\\r\\n/g, '\n')
      .replace(/\\n/g, '\n')
      .replace(/\r/g, '');

    this.unprocessed += normalized;

    while (true) {
      if (!this.isInsideBlock) {
        // ðŸ”¹ opening fence must be its own line
        const fenceMatch = this.unprocessed.match(/(^|\n)\s*```+\s*([^\n]*)\n?/);
        if (!fenceMatch) {
          if (this.unprocessed.length > 2000) {
            this.unprocessed = this.unprocessed.slice(-3);
          }
          break;
        }

        this.unprocessed = this.unprocessed.slice(fenceMatch.index! + fenceMatch[0].length);
        this.isInsideBlock = true;

        // Extract language (group 2)
        const lang = (fenceMatch[2] || '').trim().toLowerCase();
        this.currentLang = lang || 'other';
        this.waitingForLang = false;
      }

      if (this.waitingForLang) {
        const nlIndex = this.unprocessed.indexOf('\n');
        if (nlIndex === -1) break;

        const langLine = this.unprocessed.slice(0, nlIndex).trim();
        this.currentLang = langLine ? langLine.toLowerCase() : 'other';
        this.unprocessed = this.unprocessed.slice(nlIndex + 1);
        this.waitingForLang = false;
      }

      // ðŸ”¹ closing fence must also be its own line
      const closingMatch = this.unprocessed.match(/(^|\n)\s*```+\s*($|\n)/);
      if (!closingMatch) {
        if (this.currentLang) {
          this.appendToLanguageBucket(this.currentLang, this.unprocessed);
        }
        this.unprocessed = '';
        break;
      } else {
        const closingIndex = closingMatch.index!;
        const content = this.unprocessed.slice(0, closingIndex);
        if (this.currentLang) {
          this.appendToLanguageBucket(this.currentLang, content);
        }
        this.unprocessed = this.unprocessed.slice(closingIndex + closingMatch[0].length);
        this.isInsideBlock = false;
        this.currentLang = null;
        this.waitingForLang = false;
        continue;
      }
    }
  }

  private appendToLanguageBucket(lang: string, content: string) {
    if (!content) return;

    const safe = content.replace(/\\n/g, '\n').replace(/\r/g, '');

    switch (lang) {
      case 'html':
        this.htmlCode += safe;
        break;
      case 'css':
        this.cssCode += safe;
        break;
      case 'js':
      case 'javascript':
        this.jsCode += safe;
        break;
      default:
        this.otherCode += safe;
        break;
    }
  }
}
