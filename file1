div class="action-cards-carousel">
                    <button class="carousel-nav prev" (click)="scrollCarousel('prev')" [disabled]="isAtStart()"
                        *ngIf="showCarouselNav">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="15 18 9 12 15 6"></polyline>
                        </svg>
                    </button>

                    <div class="action-cards-wrapper" #carouselContainer>





<button class="carousel-nav next" (click)="scrollCarousel('next')" [disabled]="isAtEnd()"
                        *ngIf="showCarouselNav">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="9 18 15 12 9 6"></polyline>
                        </svg>
                    </button>
                </div>






@ViewChild('carouselContainer') carouselContainer!: ElementRef;

  carouselScrollPosition = 0;
  maxCarouselScroll = 0;
  showCarouselNav = false;

  cardWidth = 180;
  gap = 12;
  visibleCards = 4;

  private resizeObserver?: ResizeObserver;
  private scrollTimeout: any;

  constructor(private cdr: ChangeDetectorRef) { }

  ngAfterViewInit() {
    setTimeout(() => {
      this.calculateCarouselDimensions();
      this.setupResizeObserver();
      this.setupScrollListener();
    }, 100);
  }

  setupScrollListener() {
    if (this.carouselContainer) {
      this.carouselContainer.nativeElement.addEventListener('scroll', () => {
        // Clear existing timeout
        if (this.scrollTimeout) {
          clearTimeout(this.scrollTimeout);
        }

        // Debounce scroll updates
        this.scrollTimeout = setTimeout(() => {
          this.updateScrollPosition();
        }, 50);
      });
    }
  }

  updateScrollPosition() {
    if (this.carouselContainer) {
      const container = this.carouselContainer.nativeElement;
      this.carouselScrollPosition = container.scrollLeft;

      // Trigger change detection to update button states
      this.cdr.detectChanges();

      console.log('Scroll Position:', this.carouselScrollPosition);
      console.log('Max Scroll:', this.maxCarouselScroll);
      console.log('At End:', this.isAtEnd());
    }
  }

  isAtEnd(): boolean {
    // Add small tolerance (1px) for floating point precision
    return this.carouselScrollPosition >= (this.maxCarouselScroll - 1);
  }

  isAtStart(): boolean {
    return this.carouselScrollPosition <= 1;
  }

  setupResizeObserver() {
    if (this.carouselContainer) {
      this.resizeObserver = new ResizeObserver(() => {
        this.calculateCarouselDimensions();
      });
      this.resizeObserver.observe(this.carouselContainer.nativeElement);
    }
  }

  calculateCarouselDimensions() {
    if (this.carouselContainer) {
      const container = this.carouselContainer.nativeElement;
      const totalCards = container.children.length;
      const containerWidth = container.offsetWidth;

      // Calculate actual card width from first card if available
      if (container.children.length > 0) {
        const firstCard = container.children[0] as HTMLElement;
        this.cardWidth = firstCard.offsetWidth;
      }

      // Calculate total content width including all gaps
      const totalContentWidth = (totalCards * this.cardWidth) + ((totalCards - 1) * this.gap);

      // Show navigation only if content overflows
      this.showCarouselNav = totalContentWidth > containerWidth;

      // Calculate max scroll position
      // scrollWidth gives us the total scrollable width
      // offsetWidth gives us the visible width
      this.maxCarouselScroll = container.scrollWidth - container.offsetWidth;

      // Update current scroll position
      this.updateScrollPosition();

      console.log('Container Width:', containerWidth);
      console.log('Scroll Width:', container.scrollWidth);
      console.log('Total Content Width:', totalContentWidth);
      console.log('Max Scroll:', this.maxCarouselScroll);
      console.log('Show Nav:', this.showCarouselNav);
    }
  }

  scrollCarousel(direction: 'prev' | 'next') {
    const container = this.carouselContainer.nativeElement;
    const scrollAmount = (this.cardWidth + this.gap) * this.visibleCards;

    if (direction === 'next') {
      const newPosition = Math.min(
        this.carouselScrollPosition + scrollAmount,
        this.maxCarouselScroll
      );
      container.scrollTo({
        left: newPosition,
        behavior: 'smooth'
      });
    } else {
      const newPosition = Math.max(
        this.carouselScrollPosition - scrollAmount,
        0
      );
      container.scrollTo({
        left: newPosition,
        behavior: 'smooth'
      });
    }
  }

  ngOnDestroy() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
    if (this.scrollTimeout) {
      clearTimeout(this.scrollTimeout);
    }
  }


