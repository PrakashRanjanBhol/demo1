import { Component, OnInit, ChangeDetectorRef, ViewChild, ElementRef, SecurityContext } from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { ChunkedJsonParserService, ToolData, ApprovalRequest } from './chunked-json-parser.service';
import { marked } from 'marked';
import hljs from 'highlight.js'; // CORRECT IMPORT

// ... rest of imports and interface ...

@Component({
  selector: 'vibe-coding-chunked-json-parser',
  templateUrl: './chunked-json-parser.component.html',
  styleUrls: ['./chunked-json-parser.component.css'],
  animations: [
    trigger('fadeIn', [
      state('void', style({ opacity: 0 })),
      state('*', style({ opacity: 1 })),
      transition('void => *', animate('300ms ease-out')),
      transition('* => void', animate('300ms ease-in'))
    ])
  ]
})
export class ChunkedJsonParserComponent implements OnInit {
  // ... existing properties ...

  constructor(
    private parserService: ChunkedJsonParserService,
    private cdr: ChangeDetectorRef,
    private http: HttpClient,
    private sanitizer: DomSanitizer
  ) {
    this.configureMarked();
  }

  // CORRECTED: Configure marked with highlight.js
  private configureMarked(): void {
    // Custom renderer for code blocks
    const renderer = new marked.Renderer();
    
    renderer.code = (code: string, language: string | undefined) => {
      const validLanguage = language && hljs.getLanguage(language) ? language : 'plaintext';
      const highlighted = hljs.highlight(code, { language: validLanguage }).value;
      return `<pre><code class="hljs language-${validLanguage}">${highlighted}</code></pre>`;
    };

    renderer.codespan = (code: string) => {
      return `<code class="inline-code">${this.escapeHtml(code)}</code>`;
    };

    marked.setOptions({
      renderer: renderer,
      breaks: true,
      gfm: true
    });
  }

  private handleReadTool(toolData: ToolData): void {
    const content = typeof toolData.content === 'string' ? toolData.content : '';
    
    if (content) {
      try {
        // Parse markdown with highlight.js support
        const htmlContent = marked.parse(content) as string;
        const safeHtml = this.sanitizer.sanitize(SecurityContext.HTML, htmlContent);
        
        if (safeHtml) {
          this.readContents.push(this.sanitizer.bypassSecurityTrustHtml(safeHtml));
          this.addToExecutionFlow(toolData, 'completed');
          this.scrollReadToBottom();
        }
      } catch (e) {
        console.error('Markdown parse error:', e);
      }
    }
  }

  // ... rest of the methods remain the same ...

  private highlightCode(code: string, language: string): string {
    if (!code) {
      return this.escapeHtml('');
    }
    
    try {
      if (language !== 'plaintext' && hljs.getLanguage(language)) {
        const result = hljs.highlight(code, { language: language, ignoreIllegals: true });
        return result.value;
      }
    } catch (e) {
      return this.escapeHtml(code);
    }
    
    return this.escapeHtml(code);
  }

  private escapeHtml(text: string): string {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  public trackByIndex(index: number): number {
    return index;
  }

  // ... rest of existing methods ...
}
