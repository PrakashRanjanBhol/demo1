// Update the constant
private readonly LINES_PER_LOAD = 1000; // Reduced from 5000 to 1000

// Update loadMoreLines with requestAnimationFrame for better performance
loadMoreLines(): void {
  if (this.isLoading || !this.hasMoreLines) return;
  
  this.isLoading = true;
  
  // Use requestAnimationFrame for smoother UI updates
  requestAnimationFrame(() => {
    const newLoadedLines = Math.min(
      this.currentLoadedLines + this.LINES_PER_LOAD,
      this.totalLines
    );
    
    this.currentLoadedLines = newLoadedLines;
    this.renderContent(true);
    
    // Delay to let browser update UI
    setTimeout(() => {
      this.isLoading = false;
    }, 100);
  });
}

// Optimize renderCodeView to handle syntax highlighting in chunks
private renderCodeView(content: string, language: string, startLine: number = 1): string {
  const lines = content.split('\n');
  
  let highlightedLines: string[];
  
  // Skip syntax highlighting for very large chunks
  const shouldHighlight = lines.length < 2000 && language && language !== 'markdown' && hljs.getLanguage(language);
  
  try {
    if (shouldHighlight) {
      const highlighted = hljs.highlight(content, { language: language }).value;
      highlightedLines = highlighted.split('\n');
    } else {
      highlightedLines = lines.map(line => this.escapeHtml(line));
    }
  } catch (e) {
    highlightedLines = lines.map(line => this.escapeHtml(line));
  }

  const lineNumbers = highlightedLines
    .map((_, i) => `<div class="line-number">${startLine + i}</div>`)
    .join('');

  const codeContent = highlightedLines
    .map(line => `<div class="code-line">${line || '&nbsp;'}</div>`)
    .join('');

  return `
    <div class="code-view">
      <div class="line-numbers">${lineNumbers}</div>
      <div class="code-lines">${codeContent}</div>
    </div>
  `;
}

// Add virtual scrolling hint for very large files
private initializeContent(): void {
  if (!this.content) return;

  const lines = this.content.split('\n');
  this.totalLines = lines.length;
  
  // Reduce initial load for very large files
  const initialLoad = this.totalLines > 50000 ? 500 : this.LINES_PER_LOAD;
  this.currentLoadedLines = Math.min(initialLoad, this.totalLines);

  this.renderContent(false);
}














<div class="file-content-renderer">
  <div class="file-content-wrapper">
    <div [innerHTML]="renderedContent"></div>
    
    <!-- Load More Section -->
    <div class="load-more-section" *ngIf="hasMoreLines">
      <div class="lines-info">{{ getLinesInfo() }}</div>
      <div class="load-more-actions">
        <button class="load-more-btn" (click)="loadMoreLines()" [disabled]="isLoading">
          <svg *ngIf="!isLoading" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="6 9 12 15 18 9"/>
          </svg>
          <svg *ngIf="isLoading" class="spinner" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/>
          </svg>
          <span>{{ isLoading ? 'Loading...' : 'Load Next 1,000 Lines' }}</span>
        </button>
        <button class="load-all-btn" (click)="loadAllLines()" [disabled]="isLoading" *ngIf="totalLines - currentLoadedLines > 5000">
          <span>⚠️ Load All Remaining ({{ totalLines - currentLoadedLines }} lines)</span>
        </button>
      </div>
    </div>
  </div>
</div>
















// Add this method for loading all remaining lines
loadAllLines(): void {
  if (this.isLoading || !this.hasMoreLines) return;
  
  const remaining = this.totalLines - this.currentLoadedLines;
  const confirmed = confirm(
    `This will load ${remaining} more lines and may freeze the browser temporarily. Continue?`
  );
  
  if (!confirmed) return;
  
  this.isLoading = true;
  
  // Load in batches to prevent complete freeze
  this.loadInBatches();
}

private loadInBatches(): void {
  const batchSize = 2000;
  
  const loadNextBatch = () => {
    if (this.currentLoadedLines >= this.totalLines) {
      this.isLoading = false;
      return;
    }
    
    const newLoadedLines = Math.min(
      this.currentLoadedLines + batchSize,
      this.totalLines
    );
    
    this.currentLoadedLines = newLoadedLines;
    this.renderContent(true);
    
    // Continue loading next batch
    if (this.currentLoadedLines < this.totalLines) {
      setTimeout(() => {
        requestAnimationFrame(loadNextBatch);
      }, 150); // Increased delay between batches
    } else {
      this.isLoading = false;
    }
  };
  
  requestAnimationFrame(loadNextBatch);
}



















.load-more-actions {
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: center;
  width: 100%;
}

.load-more-btn {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 10px 24px;
  background: var(--bitbucket-file-accent-blue);
  color: #ffffff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s;
}

.load-all-btn {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 8px 20px;
  background: #f59e0b;
  color: #ffffff;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.2s;
}

.load-all-btn:hover:not(:disabled) {
  background: #d97706;
}

.load-all-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

















// Add CSS class to disable animations during loading
private renderContent(append: boolean = false): void {
  if (!this.content) return;

  const lines = this.content.split('\n');

  if (this.fileType === 'markdown') {
    const contentToDisplay = lines.slice(0, this.currentLoadedLines).join('\n');
    this.renderedContent = this.sanitizer.bypassSecurityTrustHtml(
      this.renderMarkdownView(contentToDisplay)
    );
  } else {
    if (append && this.currentLoadedLines) {
      const previousLines = this.currentLoadedLines - this.LINES_PER_LOAD;
      const newLines = lines.slice(previousLines, this.currentLoadedLines).join('\n');
      
      const newRenderedContent = this.renderCodeView(
        newLines, 
        this.fileType, 
        previousLines + 1
      );
      
      const existingHtml = this.getHtmlString(this.renderedContent);
      const updatedHtml = this.appendCodeContent(existingHtml, newRenderedContent);
      this.renderedContent = this.sanitizer.bypassSecurityTrustHtml(updatedHtml);
    } else {
      const contentToDisplay = lines.slice(0, this.currentLoadedLines).join('\n');
      this.renderedContent = this.sanitizer.bypassSecurityTrustHtml(
        this.renderCodeView(contentToDisplay, this.fileType, 1)
      );
    }
  }
  
  // Force change detection
  this.renderedContent = this.sanitizer.bypassSecurityTrustHtml(
    this.getHtmlString(this.renderedContent)
  );
}
