private fixCommonJsonIssues(str: string): string {
  let result = '';
  let inString = false;
  let stringChar = '';
  let escaped = false;
  
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    
    if (escaped) {
      result += char;
      escaped = false;
      continue;
    }
    
    if (char === '\\') {
      result += char;
      escaped = true;
      continue;
    }
    
    // Track string boundaries
    if ((char === '"' || char === "'") && !inString) {
      inString = true;
      stringChar = char;
      result += char;
    } else if (char === stringChar && inString) {
      inString = false;
      stringChar = '';
      result += char;
    } else {
      result += char;
    }
  }
  
  // Remove BOM and zero-width characters
  result = result
    .replace(/^\uFEFF/, '')
    .replace(/[\u200B-\u200D\uFEFF]/g, '');
  
  return result;
}

private parseObject(obj: string): ToolCommand | null {
  try {
    let jsonStr = obj.trim();
    
    // Step 1: Deep sanitize
    jsonStr = this.deepSanitize(jsonStr);
    
    // Step 2: Quote property names BEFORE normalizing quotes
    jsonStr = this.quotePropertyNames(jsonStr);
    
    // Step 3: Normalize quotes carefully
    jsonStr = this.normalizeQuotesCarefully(jsonStr);
    
    // Step 4: Fix common issues
    jsonStr = this.fixCommonJsonIssues(jsonStr);
    
    // Step 5: Remove trailing commas
    jsonStr = this.removeTrailingCommas(jsonStr);
    
    // Step 6: Validate and fix structure
    jsonStr = this.validateJsonStructure(jsonStr);
    
    // Try to parse
    const parsed = JSON.parse(jsonStr);

    if (typeof parsed !== 'object' || !parsed.tool) {
      console.warn('Invalid tool command structure:', parsed);
      return null;
    }

    return parsed as ToolCommand;

  } catch (error) {
    console.error('Parse object error:', error);
    console.error('Problematic JSON string:', obj);
    
    // Last resort: manual extraction
    console.warn('Attempting manual extraction...');
    return this.manualExtract(obj);
  }
}

// New method: Carefully normalize quotes
private normalizeQuotesCarefully(str: string): string {
  let result = '';
  let inString = false;
  let currentQuote = '';
  let escaped = false;

  for (let i = 0; i < str.length; i++) {
    const char = str[i];

    if (escaped) {
      result += char;
      escaped = false;
      continue;
    }

    if (char === '\\') {
      result += char;
      escaped = true;
      continue;
    }

    // Handle quotes
    if (!inString && (char === '"' || char === "'")) {
      inString = true;
      currentQuote = char;
      result += '"'; // Convert to double quote
    } else if (inString && char === currentQuote) {
      inString = false;
      currentQuote = '';
      result += '"'; // Convert to double quote
    } else {
      result += char;
    }
  }

  // If string wasn't closed, close it
  if (inString) {
    result += '"';
  }

  return result;
}

// New method: Remove trailing commas
private removeTrailingCommas(str: string): string {
  let result = '';
  let inString = false;
  let escaped = false;
  
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    
    if (escaped) {
      result += char;
      escaped = false;
      continue;
    }
    
    if (char === '\\') {
      result += char;
      escaped = true;
      continue;
    }
    
    if (char === '"' && !inString) {
      inString = true;
      result += char;
    } else if (char === '"' && inString) {
      inString = false;
      result += char;
    } else if (!inString && char === ',') {
      // Look ahead to see if next non-whitespace is } or ]
      let nextNonSpace = '';
      for (let j = i + 1; j < str.length; j++) {
        if (str[j] !== ' ' && str[j] !== '\n' && str[j] !== '\r' && str[j] !== '\t') {
          nextNonSpace = str[j];
          break;
        }
      }
      
      // If next char is } or ], skip the comma (trailing comma)
      if (nextNonSpace === '}' || nextNonSpace === ']') {
        continue; // Skip this comma
      } else {
        result += char;
      }
    } else {
      result += char;
    }
  }
  
  return result;
}

// New method: Validate JSON structure
private validateJsonStructure(str: string): string {
  let result = str;
  let depth = 0;
  let inString = false;
  let escaped = false;
  
  // Count braces to ensure they're balanced
  for (let i = 0; i < result.length; i++) {
    const char = result[i];
    
    if (escaped) {
      escaped = false;
      continue;
    }
    
    if (char === '\\') {
      escaped = true;
      continue;
    }
    
    if (char === '"' && !inString) {
      inString = true;
    } else if (char === '"' && inString) {
      inString = false;
    }
    
    if (!inString) {
      if (char === '{' || char === '[') {
        depth++;
      } else if (char === '}' || char === ']') {
        depth--;
      }
    }
  }
  
  // Add missing closing braces
  while (depth > 0) {
    result += '}';
    depth--;
  }
  
  return result;
}










private quotePropertyNames(str: string): string {
  let result = '';
  let inString = false;
  let escaped = false;
  let i = 0;
  
  while (i < str.length) {
    const char = str[i];
    
    if (escaped) {
      result += char;
      escaped = false;
      i++;
      continue;
    }
    
    if (char === '\\') {
      result += char;
      escaped = true;
      i++;
      continue;
    }
    
    if (char === '"' || char === "'") {
      if (!inString) {
        inString = true;
      } else {
        inString = false;
      }
      result += char;
      i++;
      continue;
    }
    
    // If not in string and we find a property name pattern
    if (!inString && (char === '{' || char === ',')) {
      result += char;
      i++;
      
      // Skip whitespace
      while (i < str.length && /\s/.test(str[i])) {
        result += str[i];
        i++;
      }
      
      // Check if next is an unquoted property name
      if (i < str.length && /[a-zA-Z_$]/.test(str[i])) {
        let propName = '';
        while (i < str.length && /[a-zA-Z0-9_$]/.test(str[i])) {
          propName += str[i];
          i++;
        }
        
        // Add quoted property name
        result += '"' + propName + '"';
        continue;
      }
    } else {
      result += char;
      i++;
    }
  }
  
  return result;
}
