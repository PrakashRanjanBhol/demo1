import { Component, OnInit, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { ChunkedJsonParserService, ToolData, ApprovalRequest } from './chunked-json-parser.service';

declare var hljs: any;

interface ExecutionFlowItem {
  id: string;
  tool: string;
  fileName?: string;
  status: 'executing' | 'completed' | 'rejected';
  timestamp: number;
}

@Component({
  selector: 'vibe-coding-chunked-json-parser',
  templateUrl: './chunked-json-parser.component.html',
  styleUrls: ['./chunked-json-parser.component.css'],
  changeDetection: ChangeDetectionStrategy.OnPush,
  animations: [
    trigger('fadeIn', [
      transition(':enter', [
        style({ opacity: 0 }),
        animate('200ms ease-out', style({ opacity: 1 }))
      ])
    ])
  ]
})
export class ChunkedJsonParserComponent implements OnInit {
  // State
  isProcessing = false;
  isCompleted = false;
  hasFirstChunk = false;
  showApproval = false;
  isApproving = false;
  
  // Data
  executionFlow: ExecutionFlowItem[] = [];
  queuedCount = 0;
  approvalData: any = null;
  diffHtml: SafeHtml | null = null;
  
  // Cache
  private flowIdCounter = 0;

  constructor(
    private parser: ChunkedJsonParserService,
    private cdr: ChangeDetectorRef,
    private http: HttpClient,
    private sanitizer: DomSanitizer
  ) {}

  ngOnInit(): void {}

  async run(): Promise<void> {
    // Reset
    this.reset();
    this.isProcessing = true;
    this.cdr.markForCheck();
    
    // Setup callbacks
    this.parser.setCallbacks({
      onToolDetected: (data: ToolData) => this.onTool(data),
      onApprovalRequest: (req: ApprovalRequest) => this.onApproval(req),
      onCompletion: () => this.onComplete(),
      onError: (err: string) => this.onError(err),
      onFirstChunk: () => {
        this.hasFirstChunk = true;
        this.cdr.markForCheck();
      }
    });
    
    try {
      await this.parser.startStreaming();
    } catch (e) {
      if (e instanceof Error && e.name !== 'AbortError') {
        console.error('Stream error:', e);
      }
      this.isProcessing = false;
      this.cdr.markForCheck();
    }
  }

  stop(): void {
    this.parser.stopStreaming();
    this.isProcessing = false;
    this.cdr.markForCheck();
  }

  async accept(): Promise<void> {
    if (!this.approvalData || this.isApproving) return;
    
    this.isApproving = true;
    this.cdr.markForCheck();
    
    try {
      await this.saveChanges(this.approvalData);
      this.updateFlowStatus('completed');
      this.continueFlow();
    } catch (e) {
      console.error('Save failed:', e);
      alert('Failed to save changes');
      this.isApproving = false;
      this.cdr.markForCheck();
    }
  }

  reject(): void {
    if (!this.approvalData) return;
    
    this.updateFlowStatus('rejected');
    this.continueFlow();
  }

  // Private methods
  private reset(): void {
    const container = document.getElementById('read-container');
    if (container) container.innerHTML = '';
    
    this.executionFlow = [];
    this.queuedCount = 0;
    this.approvalData = null;
    this.diffHtml = null;
    this.showApproval = false;
    this.isCompleted = false;
    this.hasFirstChunk = false;
    this.isApproving = false;
    this.flowIdCounter = 0;
  }

  private onTool(data: ToolData): void {
    if (data.tool === 'READ') {
      this.appendRead(data.content);
      this.addFlow(data.tool, undefined, 'completed');
    } else {
      this.addFlow(data.tool, this.extractFileName(data.content), 'executing');
    }
    
    this.queuedCount = this.parser.getPendingTools().length;
    this.cdr.markForCheck();
  }

  private onApproval(req: ApprovalRequest): void {
    this.approvalData = req.data;
    this.showApproval = true;
    this.diffHtml = this.buildDiff(req.data.content);
    this.cdr.markForCheck();
  }

  private onComplete(): void {
    this.isProcessing = false;
    this.isCompleted = true;
    this.showApproval = false;
    this.cdr.markForCheck();
  }

  private onError(err: string): void {
    console.error('Error:', err);
    this.isProcessing = false;
    this.cdr.markForCheck();
  }

  private continueFlow(): void {
    this.approvalData = null;
    this.showApproval = false;
    this.diffHtml = null;
    this.isApproving = false;
    
    this.parser.approveAndContinue();
    this.queuedCount = this.parser.getPendingTools().length;
    this.cdr.markForCheck();
  }

  private appendRead(content: any): void {
    const container = document.getElementById('read-container');
    if (!container) return;
    
    const text = typeof content === 'string' ? content : '';
    if (!text) return;
    
    const div = document.createElement('div');
    div.className = 'read-item';
    div.textContent = text;
    container.appendChild(div);
    
    // Auto-scroll
    setTimeout(() => {
      container.scrollTop = container.scrollHeight;
    }, 0);
  }

  private addFlow(tool: string, fileName: string | undefined, status: ExecutionFlowItem['status']): void {
    this.executionFlow.push({
      id: `flow-${this.flowIdCounter++}`,
      tool,
      fileName,
      status,
      timestamp: Date.now()
    });
  }

  private updateFlowStatus(status: 'completed' | 'rejected'): void {
    const fileName = this.extractFileName(this.approvalData?.content);
    const item = this.executionFlow.find(
      f => f.status === 'executing' && f.fileName === fileName
    );
    if (item) item.status = status;
  }

  private extractFileName(content: any): string | undefined {
    if (!content || typeof content !== 'object') return undefined;
    const files = content.files;
    return Array.isArray(files) && files[0]?.file_name ? files[0].file_name : undefined;
  }

  private buildDiff(content: any): SafeHtml {
    const files = content?.files;
    if (!Array.isArray(files) || !files[0]) {
      return this.sanitizer.bypassSecurityTrustHtml('');
    }
    
    const file = files[0];
    const orig = (file.original_code || '').split('\n');
    const mod = (file.modified_code || '').split('\n');
    const lang = this.getLang(file.file_name);
    
    let html = '';
    let origNum = 1;
    let modNum = 1;
    const maxLen = Math.max(orig.length, mod.length);
    
    for (let i = 0; i < maxLen; i++) {
      if (orig[i] === mod[i]) {
        html += this.diffLine('unchanged', origNum++, modNum++, orig[i] || '', lang);
      } else {
        if (i < orig.length) {
          html += this.diffLine('removed', origNum++, null, orig[i], lang);
        }
        if (i < mod.length) {
          html += this.diffLine('added', null, modNum++, mod[i], lang);
        }
      }
    }
    
    return this.sanitizer.bypassSecurityTrustHtml(html);
  }

  private diffLine(type: string, origNum: number | null, modNum: number | null, code: string, lang: string): string {
    const prefix = type === 'added' ? '+ ' : type === 'removed' ? '- ' : '  ';
    const highlighted = this.highlight(code, lang);
    
    return `<div class="diff-line diff-${type}">` +
      `<span class="line-num">${origNum || ''}</span>` +
      `<span class="line-num">${modNum || ''}</span>` +
      `<span class="line-prefix">${prefix}</span>` +
      `<span class="line-code">${highlighted}</span>` +
      `</div>`;
  }

  private highlight(code: string, lang: string): string {
    if (!code) return '';
    
    try {
      if (typeof hljs !== 'undefined' && lang !== 'plaintext' && hljs.getLanguage(lang)) {
        return hljs.highlight(code, { language: lang, ignoreIllegals: true }).value;
      }
    } catch (e) {}
    
    return this.escape(code);
  }

  private escape(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  private getLang(filename: string): string {
    if (!filename) return 'plaintext';
    
    const ext = filename.split('.').pop()?.toLowerCase() || '';
    const map: { [key: string]: string } = {
      js: 'javascript', jsx: 'javascript', ts: 'typescript', tsx: 'typescript',
      py: 'python', java: 'java', cpp: 'cpp', c: 'c', cs: 'csharp',
      php: 'php', rb: 'ruby', go: 'go', rs: 'rust', html: 'html',
      css: 'css', json: 'json', sql: 'sql', sh: 'bash'
    };
    
    return map[ext] || 'plaintext';
  }

  private async saveChanges(data: any): Promise<void> {
    const files = data?.content?.files;
    if (!Array.isArray(files) || !files[0]) return;
    
    const file = files[0];
    const payload = {
      tool: data.tool,
      file_path: file.file_path,
      file_name: file.file_name,
      original_code: file.original_code || '',
      modified_code: file.modified_code || '',
      reasoning: data.content?.reasoning || '',
      timestamp: new Date().toISOString()
    };
    
    return new Promise((resolve, reject) => {
      const headers = new HttpHeaders({ 'Content-Type': 'application/json' });
      this.http.post('https://your-api-endpoint.com/api/save-code', payload, { headers })
        .subscribe({
          next: () => resolve(),
          error: (e) => reject(e)
        });
    });
  }

  // Template helpers - pure functions
  getExt(name: string): string {
    return name ? (name.split('.').pop()?.toUpperCase() || 'FILE') : 'FILE';
  }

  getIcon(tool: string): string {
    return tool === 'READ' ? 'üìñ' : tool === 'WRITE' ? '‚úèÔ∏è' : 'üîß';
  }

  getTime(ts: number): string {
    return new Date(ts).toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  }

  getReason(): string {
    return this.approvalData?.content?.reasoning || '';
  }

  getFileName(): string {
    return this.extractFileName(this.approvalData?.content) || '';
  }

  getFilePath(): string {
    const files = this.approvalData?.content?.files;
    return Array.isArray(files) && files[0]?.file_path ? files[0].file_path : '';
  }

  trackById(index: number, item: ExecutionFlowItem): string {
    return item.id;
  }
}



















<div class="container">
  <!-- Header -->
  <div class="header">
    <div class="header-content">
      <div class="header-left">
        <h1>AI Execution Tracker</h1>
        <p>Real-time code generation & execution monitoring</p>
      </div>
      
      <div class="header-right">
        <button class="btn btn-primary" (click)="run()" [disabled]="isProcessing">RUN</button>

        <span *ngIf="isProcessing && !isCompleted" class="badge badge-processing">
          <span class="pulse-dot"></span>
          Processing
        </span>

        <span *ngIf="isCompleted" class="badge badge-completed">
          <span class="check-icon">‚úì</span>
          Completed
        </span>

        <button *ngIf="isProcessing && !isCompleted" class="btn-stop" (click)="stop()" title="Stop">
          <svg viewBox="0 0 24 24" fill="none">
            <rect x="6" y="6" width="12" height="12" fill="currentColor" rx="2"/>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <!-- Main Content -->
  <div class="content">
    <!-- Left Panel (80%) -->
    <div class="read-panel">
      <!-- Empty State -->
      <div *ngIf="!isProcessing && executionFlow.length === 0 && !showApproval" class="empty-state">
        <div class="empty-icon">üìÑ</div>
        <p>No content yet</p>
        <span>Click RUN to start</span>
      </div>

      <!-- Waiting State -->
      <div *ngIf="isProcessing && !hasFirstChunk" class="waiting-state">
        <div class="spinner"></div>
        <h3>Connecting to AI Agent<span class="dots"><span>.</span><span>.</span><span>.</span></span></h3>
        <p>Preparing execution plan</p>
      </div>

      <!-- READ Content -->
      <div *ngIf="!showApproval" id="read-container" class="read-content"></div>

      <!-- Approval View -->
      <div *ngIf="showApproval" class="approval-view" @fadeIn>
        <div class="approval-header">
          <div class="approval-title">
            <span class="approval-icon">{{ getExt(getFileName()) }}</span>
            <div class="approval-info">
              <h3>{{ getFileName() }}</h3>
              <p *ngIf="getFilePath()">{{ getFilePath() }}</p>
            </div>
            <span class="approval-badge">{{ approvalData?.tool }}</span>
          </div>
        </div>

        <div *ngIf="getReason()" class="reasoning">
          <h4>Reasoning</h4>
          <p>{{ getReason() }}</p>
        </div>

        <div class="diff-container">
          <div class="diff-header">
            <span>Changes in {{ getFileName() }}</span>
          </div>
          <div class="diff-content">
            <pre><code [innerHTML]="diffHtml"></code></pre>
          </div>
        </div>

        <div class="approval-actions">
          <button class="btn btn-reject" (click)="reject()" [disabled]="isApproving">‚úï Reject</button>
          <button class="btn btn-accept" (click)="accept()" [disabled]="isApproving">
            <span *ngIf="!isApproving">‚úì Accept & Continue</span>
            <span *ngIf="isApproving" class="accepting">
              <span class="spinner-small"></span>
              Accepting...
            </span>
          </button>
        </div>
      </div>
    </div>

    <!-- Right Panel (20%) -->
    <div class="flow-panel">
      <div class="flow-header">
        <h2>Execution Flow</h2>
        <span class="flow-count">{{ executionFlow.length }}</span>
      </div>

      <div class="flow-content">
        <div *ngIf="executionFlow.length === 0" class="flow-empty">
          <div class="flow-empty-icon">‚ãØ</div>
          <p>No executions yet</p>
        </div>

        <div *ngFor="let item of executionFlow; trackBy: trackById" class="flow-item" @fadeIn>
          <div class="flow-icon">{{ getIcon(item.tool) }}</div>
          <div class="flow-info">
            <div class="flow-tool">{{ item.tool }}</div>
            <div *ngIf="item.fileName" class="flow-file">{{ item.fileName }}</div>
            <div class="flow-time">{{ getTime(item.timestamp) }}</div>
          </div>
          <div class="flow-status">
            <span *ngIf="item.status === 'executing'" class="status-dot dot-executing"></span>
            <span *ngIf="item.status === 'completed'" class="status-dot dot-completed">‚úì</span>
            <span *ngIf="item.status === 'rejected'" class="status-dot dot-rejected">‚úï</span>
          </div>
        </div>

        <div *ngIf="queuedCount > 0" class="flow-queued">
          <div class="queued-icon">‚è≥</div>
          <div class="queued-text">{{ queuedCount }} queued</div>
        </div>
      </div>
    </div>
  </div>
</div>
