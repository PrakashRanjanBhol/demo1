// Add this property
private readonly LARGE_FILE_THRESHOLD = 500;
private readonly CONTEXT_LINES = 3; // Number of context lines to show around changes

// Replace the generateUnifiedDiff method
private generateUnifiedDiff(file: DiffFile): DiffLine[] {
  const isLargeFile = Math.max(file.old_lines.length, file.new_lines.length) > this.LARGE_FILE_THRESHOLD;
  
  if (isLargeFile) {
    return this.generateCompactDiff(file);
  } else {
    return this.generateFullDiff(file);
  }
}

// Full diff for small files (original logic)
private generateFullDiff(file: DiffFile): DiffLine[] {
  const oldText = file.old_lines.join('\n');
  const newText = file.new_lines.join('\n');
  const diff = Diff.diffLines(oldText, newText);

  const lines: DiffLine[] = [];
  let oldLineNum = 1;
  let newLineNum = 1;

  diff.forEach(part => {
    const lineTexts = part.value.split('\n');
    if (lineTexts[lineTexts.length - 1] === '') {
      lineTexts.pop();
    }

    lineTexts.forEach(lineText => {
      if (part.added) {
        const comment = this.findCommentForLine(file, newLineNum, 'TO');
        lines.push({
          type: 'added',
          newLineNum,
          content: this.highlightSyntax(lineText, file.file_path),
          comment
        });
        newLineNum++;
      } else if (part.removed) {
        const comment = this.findCommentForLine(file, oldLineNum, 'FROM');
        lines.push({
          type: 'deleted',
          oldLineNum,
          content: this.highlightSyntax(lineText, file.file_path),
          comment
        });
        oldLineNum++;
      } else {
        const commentFrom = this.findCommentForLine(file, oldLineNum, 'FROM');
        const commentTo = this.findCommentForLine(file, newLineNum, 'TO');
        const comment = commentTo || commentFrom;
        
        lines.push({
          type: 'context',
          oldLineNum,
          newLineNum,
          content: this.highlightSyntax(lineText, file.file_path),
          comment
        });
        oldLineNum++;
        newLineNum++;
      }
    });
  });

  return lines;
}

// Compact diff for large files - shows only changes with context
private generateCompactDiff(file: DiffFile): DiffLine[] {
  const oldText = file.old_lines.join('\n');
  const newText = file.new_lines.join('\n');
  const diff = Diff.diffLines(oldText, newText);

  const allLines: DiffLine[] = [];
  let oldLineNum = 1;
  let newLineNum = 1;

  // First pass: generate all lines with their types
  diff.forEach(part => {
    const lineTexts = part.value.split('\n');
    if (lineTexts[lineTexts.length - 1] === '') {
      lineTexts.pop();
    }

    lineTexts.forEach(lineText => {
      if (part.added) {
        const comment = this.findCommentForLine(file, newLineNum, 'TO');
        allLines.push({
          type: 'added',
          newLineNum,
          content: this.highlightSyntax(lineText, file.file_path),
          comment
        });
        newLineNum++;
      } else if (part.removed) {
        const comment = this.findCommentForLine(file, oldLineNum, 'FROM');
        allLines.push({
          type: 'deleted',
          oldLineNum,
          content: this.highlightSyntax(lineText, file.file_path),
          comment
        });
        oldLineNum++;
      } else {
        const commentFrom = this.findCommentForLine(file, oldLineNum, 'FROM');
        const commentTo = this.findCommentForLine(file, newLineNum, 'TO');
        const comment = commentTo || commentFrom;
        
        allLines.push({
          type: 'context',
          oldLineNum,
          newLineNum,
          content: this.highlightSyntax(lineText, file.file_path),
          comment
        });
        oldLineNum++;
        newLineNum++;
      }
    });
  });

  // Second pass: identify ranges to show (changes + context + comments)
  const linesToShow = new Set<number>();
  
  allLines.forEach((line, index) => {
    // Include all changed lines
    if (line.type === 'added' || line.type === 'deleted') {
      linesToShow.add(index);
      // Add context lines around changes
      for (let i = Math.max(0, index - this.CONTEXT_LINES); i <= Math.min(allLines.length - 1, index + this.CONTEXT_LINES); i++) {
        linesToShow.add(i);
      }
    }
    
    // Include lines with comments and their context
    if (line.comment) {
      linesToShow.add(index);
      for (let i = Math.max(0, index - this.CONTEXT_LINES); i <= Math.min(allLines.length - 1, index + this.CONTEXT_LINES); i++) {
        linesToShow.add(i);
      }
    }
  });

  // Third pass: build final output with separators
  const compactLines: DiffLine[] = [];
  const sortedIndices = Array.from(linesToShow).sort((a, b) => a - b);
  
  let lastIndex = -1;
  sortedIndices.forEach(index => {
    // Add separator if there's a gap
    if (lastIndex !== -1 && index - lastIndex > 1) {
      compactLines.push({
        type: 'context',
        content: this.createSeparatorContent(lastIndex, index, allLines),
        oldLineNum: undefined,
        newLineNum: undefined
      });
    }
    
    compactLines.push(allLines[index]);
    lastIndex = index;
  });

  return compactLines;
}

// Create separator line showing skipped lines
private createSeparatorContent(lastIndex: number, currentIndex: number, allLines: DiffLine[]): string {
  const skippedCount = currentIndex - lastIndex - 1;
  const lastLine = allLines[lastIndex];
  const currentLine = allLines[currentIndex];
  
  let rangeText = '';
  if (lastLine.oldLineNum && currentLine.oldLineNum) {
    rangeText = `Lines ${lastLine.oldLineNum + 1}-${currentLine.oldLineNum - 1}`;
  } else if (lastLine.newLineNum && currentLine.newLineNum) {
    rangeText = `Lines ${lastLine.newLineNum + 1}-${currentLine.newLineNum - 1}`;
  }
  
  return `<span style="color: #6b7280; font-style: italic;">⋯ ${skippedCount} lines hidden ${rangeText ? '(' + rangeText + ')' : ''} ⋯</span>`;
}

// Check if current file is showing compact view
isCompactView(): boolean {
  if (!this.selectedFile) return false;
  return Math.max(this.selectedFile.old_lines.length, this.selectedFile.new_lines.length) > this.LARGE_FILE_THRESHOLD;
}

















<!-- Compact View Info Banner -->
<div class="info-banner compact-mode" *ngIf="isCompactView()">
  <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="info-icon">
    <path d="M11 17h2v-6h-2v6zm1-15C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 9h2V7h-2v2z"/>
  </svg>
  <div class="info-content">
    <strong>Compact View Active</strong>
    <span>This file has over 500 lines. Showing only modified sections with {{ isCompactView() ? '3' : '' }} lines of context.</span>
  </div>
</div>











.info-banner.compact-mode {
  background: linear-gradient(135deg, 
    rgba(245, 158, 11, 0.1) 0%, 
    rgba(217, 119, 6, 0.05) 100%);
  border-color: rgba(245, 158, 11, 0.3);
  border-left-color: #f59e0b;

  .info-icon {
    fill: #f59e0b;
  }
}

// Style for separator lines
.diff-line.context {
  &:has(.line-content span[style*="font-style: italic"]) {
    background-color: var(--bitbucket-pr-review-bg-tertiary);
    
    .line-content {
      text-align: center;
      padding: 8px 12px;
      font-weight: 500;
    }
  }
}

// Dark mode for compact banner
:host.dark-mode {
  .info-banner.compact-mode {
    background: linear-gradient(135deg, 
      rgba(245, 158, 11, 0.15) 0%, 
      rgba(217, 119, 6, 0.08) 100%);
    border-color: rgba(245, 158, 11, 0.4);
  }
}





