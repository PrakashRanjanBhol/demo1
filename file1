// ✅ UPDATE Repository interface
interface Repository {
  repo_key: string;
  repo_name: string;
  repo_url: string;
  isFavorited?: boolean; // ✅ Add this
}







// ✅ UPDATE updateFilteredRepositories method
private updateFilteredRepositories(): void {
  if (!this.currentProject) {
    this.filteredRepositoriesList = [];
    return;
  }
  
  const repos = this.repositoriesByProject[this.currentProject.project_key] || [];
  
  // Filter by search text
  let filtered: Repository[];
  if (!this.repoSearchText.trim()) {
    filtered = repos;
  } else {
    const searchLower = this.repoSearchText.toLowerCase();
    filtered = repos.filter(repo => 
      repo.repo_name.toLowerCase().includes(searchLower) ||
      repo.repo_url.toLowerCase().includes(searchLower)
    );
  }
  
  // ✅ Mark which ones are favorited
  this.filteredRepositoriesList = filtered.map(repo => ({
    ...repo,
    isFavorited: this.checkIsFavorite(repo.repo_key)
  }));
}

// ✅ ADD helper method to check if favorited
private checkIsFavorite(repoKey: string): boolean {
  return Object.values(this.favoriteRepositories).some(repos => 
    repos.some(repo => repo.repo_key === repoKey)
  );
}









// ✅ UPDATE updateFilteredProjects if needed
private updateFilteredProjects(): void {
  if (!this.projectSearchText.trim()) {
    this.filteredProjectsList = this.allProjects;
    return;
  }
  
  const searchLower = this.projectSearchText.toLowerCase();
  this.filteredProjectsList = this.allProjects.filter(project => 
    project.project_name.toLowerCase().includes(searchLower) ||
    project.project_key.toLowerCase().includes(searchLower) ||
    project.project_url.toLowerCase().includes(searchLower)
  );
}







// ✅ UPDATE toggleFavorite - it already calls updateAllCaches
toggleFavorite(repoKey: string, projectKey: string, event?: Event): void {
  if (event) {
    event.stopPropagation();
  }

  this.loadingRepos[repoKey] = true;

  setTimeout(() => {
    if (this.isFavorite(repoKey)) {
      // Remove from favorites
      if (this.favoriteRepositories[projectKey]) {
        this.favoriteRepositories[projectKey] = this.favoriteRepositories[projectKey]
          .filter(repo => repo.repo_key !== repoKey);
        
        if (this.favoriteRepositories[projectKey].length === 0) {
          delete this.favoriteRepositories[projectKey];
        }
      }
    } else {
      // Add to favorites
      const repo = this.repositoriesByProject[projectKey]?.find(r => r.repo_key === repoKey);
      if (repo) {
        if (!this.favoriteRepositories[projectKey]) {
          this.favoriteRepositories[projectKey] = [];
        }
        this.favoriteRepositories[projectKey].push(repo);
      }
    }

    this.loadingRepos[repoKey] = false;
    
    // ✅ This will trigger updateFilteredRepositories which marks favorites
    this.updateAllCaches();
  }, 1000);
}

// ✅ Make sure updateAllCaches calls updateFilteredRepositories
private updateAllCaches(): void {
  this.updateHasFavoritesFlag();
  this.updateFavoriteProjectsList();
  this.updateFilteredRepositories(); // ✅ This will mark isFavorited
}



