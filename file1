.action-btn {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 11px;
    font-weight: 600;
    cursor: pointer;
    border: 2px solid;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
    box-shadow: 0 1px 3px var(--bitbucket-file-comparator-comment-shadow);
    opacity: 1;
}

.btn-icon {
    font-size: 14px;
    font-weight: bold;
    line-height: 1;
}










<!-- Comment Actions -->
<div class="comment-actions" [id]="getCommentId(fileIndex, commentIndex) + '-actions'">

    <!-- Pending State Actions -->
    <ng-container
        *ngIf="getCommentState(fileIndex, commentIndex).status === 'pending' && !getCommentState(fileIndex, commentIndex).isEditing">
        <button class="action-btn btn-accept"
            (click)="acceptComment(fileIndex, commentIndex)">
            <span class="btn-icon">âœ“</span>
            <span class="btn-text">Accept</span>
        </button>
        <button class="action-btn btn-reject"
            (click)="rejectComment(fileIndex, commentIndex)">
            <span class="btn-icon">âœ—</span>
            <span class="btn-text">Reject</span>
        </button>
        <button class="action-btn btn-modify"
            (click)="modifyComment(fileIndex, commentIndex)">
            <span class="btn-icon">âœŽ</span>
            <span class="btn-text">Modify</span>
        </button>
    </ng-container>

    <!-- Editing State Actions -->
    <ng-container *ngIf="getCommentState(fileIndex, commentIndex).isEditing">
        <button class="action-btn btn-save"
            (click)="saveModifiedComment(fileIndex, commentIndex)">
            <span class="btn-icon">ðŸ’¾</span>
            <span class="btn-text">Save</span>
        </button>
        <button class="action-btn btn-cancel"
            (click)="cancelModification(fileIndex, commentIndex)">
            <span class="btn-icon">âœ•</span>
            <span class="btn-text">Cancel</span>
        </button>
    </ng-container>

    <!-- Accepted/Rejected State - Show nothing or just status badge -->
    <ng-container
        *ngIf="getCommentState(fileIndex, commentIndex).status !== 'pending' && !getCommentState(fileIndex, commentIndex).isEditing">
        <!-- No undo button - comment remains in accepted/rejected state -->
    </ng-container>
</div>












bindCommentEvents(commentElement: HTMLElement, fileIndex: number, commentIndex: number): void {
  const commentId = this.getCommentId(fileIndex, commentIndex);
  
  // Find buttons within the cloned element
  const acceptBtn = commentElement.querySelector('.btn-accept');
  const rejectBtn = commentElement.querySelector('.btn-reject');
  const modifyBtn = commentElement.querySelector('.btn-modify');
  const saveBtn = commentElement.querySelector('.btn-save');
  const cancelBtn = commentElement.querySelector('.btn-cancel');
  // Remove: const undoBtn = commentElement.querySelector('.btn-undo');
  
  // Find textarea for two-way binding
  const textarea = commentElement.querySelector('.comment-body-editable') as HTMLTextAreaElement;
  if (textarea) {
    textarea.value = this.editingCommentText[commentId] || '';
    textarea.addEventListener('input', (e) => {
      const target = e.target as HTMLTextAreaElement;
      this.editingCommentText[commentId] = target.value;
    });
  }

  // Bind events
  if (acceptBtn) {
    acceptBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!this.loadingComments[commentId]) {
        this.acceptComment(fileIndex, commentIndex);
      }
    });
  }

  if (rejectBtn) {
    rejectBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!this.loadingComments[commentId]) {
        this.rejectComment(fileIndex, commentIndex);
      }
    });
  }

  if (modifyBtn) {
    modifyBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!this.loadingComments[commentId]) {
        this.modifyComment(fileIndex, commentIndex);
      }
    });
  }

  if (saveBtn) {
    saveBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!this.loadingComments[commentId]) {
        this.saveModifiedComment(fileIndex, commentIndex);
      }
    });
  }

  if (cancelBtn) {
    cancelBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!this.loadingComments[commentId]) {
        this.cancelModification(fileIndex, commentIndex);
      }
    });
  }

  // Remove undo button event binding
}
