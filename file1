/**
 * Copy content to clipboard (fallback method for HTTP)
 */
copyToClipboard(content: string, itemType?: string, itemId?: string): void {
  let contentToCopy = content;
  
  // For assessment questions, copy in a readable format
  if (itemType === 'questions' && this.faqRawData) {
    contentToCopy = this.formatAssessmentQuestionsForCopy();
  }
  
  const textArea = document.createElement('textarea');
  textArea.value = contentToCopy;
  
  // Make the textarea invisible
  textArea.style.position = 'fixed';
  textArea.style.top = '0';
  textArea.style.left = '0';
  textArea.style.width = '2em';
  textArea.style.height = '2em';
  textArea.style.padding = '0';
  textArea.style.border = 'none';
  textArea.style.outline = 'none';
  textArea.style.boxShadow = 'none';
  textArea.style.background = 'transparent';
  textArea.style.opacity = '0';
  
  document.body.appendChild(textArea);
  textArea.focus();
  textArea.select();
  
  try {
    const successful = document.execCommand('copy');
    if (successful) {
      console.log('Content copied to clipboard');
      
      // Show tick icon for this item
      if (itemId) {
        this.copiedItemId = itemId;
        
        // Reset back to copy icon after 1.5 seconds
        setTimeout(() => {
          this.copiedItemId = '';
        }, 1500);
      }
    } else {
      console.error('Failed to copy content');
    }
  } catch (err) {
    console.error('Failed to copy content:', err);
  }
  
  document.body.removeChild(textArea);
}

/**
 * Format assessment questions for copying in readable format
 */
private formatAssessmentQuestionsForCopy(): string {
  try {
    const parsedFaq = typeof this.faqRawData === 'string' ? eval(this.faqRawData) : this.faqRawData;
    
    if (!Array.isArray(parsedFaq) || parsedFaq.length === 0) {
      return 'No assessment questions available';
    }

    let formattedText = '='.repeat(80) + '\n';
    formattedText += 'ASSESSMENT QUESTIONS\n';
    formattedText += '='.repeat(80) + '\n\n';

    parsedFaq.forEach((question: AssessmentQuestion, index: number) => {
      // Question number and text
      formattedText += `Q${index + 1}. ${question.question}\n`;
      formattedText += '-'.repeat(80) + '\n\n';

      // Options
      formattedText += 'Options:\n';
      const optionKeys = Object.keys(question.options);
      optionKeys.forEach(key => {
        const optionValue = question.options[key as keyof MCQOption];
        const isCorrect = question.correct_answer === key;
        formattedText += `  ${key}. ${optionValue}${isCorrect ? ' âœ“ (Correct Answer)' : ''}\n`;
      });
      formattedText += '\n';

      // Correct Answer
      formattedText += `Correct Answer: ${question.correct_answer}\n`;
      const correctOptionValue = question.options[question.correct_answer as keyof MCQOption];
      formattedText += `Answer: ${correctOptionValue}\n\n`;

      // Explanation
      formattedText += `Explanation:\n`;
      formattedText += `${question.explanation}\n\n`;

      // Separator between questions
      if (index < parsedFaq.length - 1) {
        formattedText += '\n' + '='.repeat(80) + '\n\n';
      }
    });

    formattedText += '\n' + '='.repeat(80) + '\n';
    formattedText += `Total Questions: ${parsedFaq.length}\n`;
    formattedText += '='.repeat(80);

    return formattedText;
  } catch (error) {
    console.error('Error formatting assessment questions:', error);
    return 'Error formatting assessment questions';
  }
}
