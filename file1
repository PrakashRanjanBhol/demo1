[
  { "date": "2025-07-05", "language": "Python", "lines": 120 },
  { "date": "2025-07-05", "language": "JavaScript", "lines": 80 },
  { "date": "2025-07-05", "language": "TypeScript", "lines": 150 }
]




import { Component, ElementRef, ViewChild, AfterViewInit } from '@angular/core';
import * as echarts from 'echarts';

@Component({
  selector: 'app-charts',
  templateUrl: './charts.component.html',
  styleUrls: ['./charts.component.scss']
})
export class ChartsComponent implements AfterViewInit {
  @ViewChild('chartContainer') chartContainer!: ElementRef;

  fromDate: string;
  toDate: string;
  todayStr: string = new Date().toISOString().split('T')[0];
  chartInstance: any;
  rawData = this.generateFakeData();

  languageColors: string[] = [
    '#facc15', '#60a5fa', '#f87171', '#38bdf8', '#a78bfa', '#34d399',
    '#fb923c', '#e879f9', '#f472b6', '#c084fc', '#fcd34d', '#4ade80',
    '#06b6d4', '#fca5a5', '#fde68a', '#93c5fd', '#d8b4fe', '#fdba74',
    '#86efac', '#fda4af', '#a5b4fc', '#99f6e4', '#fbbf24', '#cbd5e1',
    '#22d3ee', '#ef4444', '#eab308', '#7c3aed', '#0ea5e9', '#e11d48'
  ];
  languageColorMap: Record<string, string> = {};

  pageIndex: number = 0;
  pageSize: number = 5;
  totalPages: number = 0;
  allPeriodsSorted: string[] = [];
  formattedPeriods: string[] = [];
  periodsSubset: string[] = [];

  constructor() {
    const today = new Date();
    const lastWeek = new Date();
    lastWeek.setDate(today.getDate() - 6);

    this.toDate = today.toISOString().split('T')[0];
    this.fromDate = lastWeek.toISOString().split('T')[0];
  }

  ngAfterViewInit() {
    this.chartInstance = echarts.init(this.chartContainer.nativeElement, 'dark');
    this.updateChart();
  }

  generateFakeData(): { date: string, language: string, lines: number }[] {
    const languages = Array.from({ length: 30 }, (_, i) => `Lang${i + 1}`);
    const startDate = new Date('2024-07-01');
    const endDate = new Date('2025-06-30');
    const data: any[] = [];

    let currentDate = new Date(startDate);
    while (currentDate <= endDate) {
      const dateStr = currentDate.toISOString().split('T')[0];
      const langsToday = [...languages].sort(() => 0.5 - Math.random()).slice(0, Math.floor(Math.random() * 8) + 3);

      langsToday.forEach(lang => {
        data.push({
          date: dateStr,
          language: lang,
          lines: Math.floor(Math.random() * 300 + 50)
        });
      });

      currentDate.setDate(currentDate.getDate() + 1);
    }

    return data;
  }

  getColorForLang(lang: string): string {
    if (!this.languageColorMap[lang]) {
      const index = Object.keys(this.languageColorMap).length % this.languageColors.length;
      this.languageColorMap[lang] = this.languageColors[index];
    }
    return this.languageColorMap[lang];
  }

  getGroupingGranularity(from: string, to: string): 'day' | 'week' | 'month' | 'year' {
    const fromDate = new Date(from);
    const toDate = new Date(to);
    const diffDays = Math.ceil((+toDate - +fromDate) / (1000 * 60 * 60 * 24));

    if (diffDays <= 30) return 'day';
    if (diffDays <= 180) return 'week';
    if (diffDays <= 730) return 'month';
    return 'year';
  }

  formatPeriod(dateStr: string, granularity: string): string {
    const date = new Date(dateStr);
    const y = date.getFullYear();
    const m = (date.getMonth() + 1).toString().padStart(2, '0');
    const d = date.getDate().toString().padStart(2, '0');

    switch (granularity) {
      case 'day':
        return `${y}-${m}-${d}`;
      case 'week': {
        const temp = new Date(date);
        const day = temp.getDay();
        const diff = temp.getDate() - day + (day === 0 ? -6 : 1);
        const weekStart = new Date(temp.setDate(diff));
        const wm = (weekStart.getMonth() + 1).toString().padStart(2, '0');
        const wd = weekStart.getDate().toString().padStart(2, '0');
        return `${weekStart.getFullYear()}-${wm}-${wd}`;
      }
      case 'month':
        return `${y}-${m}`;
      case 'year':
        return `${y}`;
      default:
        return dateStr;
    }
  }

  formatDisplayLabel(dateStr: string, granularity: string): string {
    const date = new Date(dateStr);
    const y = date.getFullYear();
    const m = date.toLocaleString('default', { month: 'short' });
    const d = date.getDate();

    switch (granularity) {
      case 'day': return `${d} ${m} ${y}`;
      case 'week': return `Week of ${d} ${m} ${y}`;
      case 'month': return `${m} ${y}`;
      case 'year': return `${y}`;
      default: return `${d} ${m} ${y}`;
    }
  }

  nextPage() {
    if (this.pageIndex < this.totalPages - 1) {
      this.pageIndex++;
      this.updateChart();
    }
  }

  prevPage() {
    if (this.pageIndex > 0) {
      this.pageIndex--;
      this.updateChart();
    }
  }

  onDateChange(): void {
    this.pageIndex = 0;
    this.updateChart();
  }

  updateChart(): void {
    if (!this.chartInstance) return;

    this.languageColorMap = {};

    const from = this.fromDate || '2024-07-01';
    const to = this.toDate || '2025-06-30';
    const granularity = this.getGroupingGranularity(from, to);

    const filtered = this.rawData.filter(d => d.date >= from && d.date <= to);
    const grouped: Record<string, Record<string, number>> = {};
    const allPeriods = new Set<string>();
    const languageSet = new Set<string>();

    for (const entry of filtered) {
      const period = this.formatPeriod(entry.date, granularity);
      allPeriods.add(period);
      languageSet.add(entry.language);
      grouped[entry.language] = grouped[entry.language] || {};
      grouped[entry.language][period] = (grouped[entry.language][period] || 0) + entry.lines;
    }

    this.allPeriodsSorted = Array.from(allPeriods).sort();
    this.totalPages = Math.ceil(this.allPeriodsSorted.length / this.pageSize);

    const start = this.pageIndex * this.pageSize;
    const end = start + this.pageSize;
    this.periodsSubset = this.allPeriodsSorted.slice(start, end);
    this.formattedPeriods = this.periodsSubset.map(p => this.formatDisplayLabel(p, granularity));
    const languages = Array.from(languageSet).sort();

    const series = languages.map(lang => ({
      name: lang,
      type: 'bar',
      stack: 'total',
      emphasis: { focus: 'series' },
      itemStyle: {
        color: this.getColorForLang(lang)
      },
      data: this.periodsSubset.map(p => grouped[lang]?.[p] || 0)
    }));

    this.chartInstance.setOption({
      backgroundColor: '#2a2a2a', // ‚úÖ updated background
      textStyle: { color: '#ffffff' },
      title: {
        text: `Line of Code by Languages (${granularity.charAt(0).toUpperCase() + granularity.slice(1)})`,
        textStyle: { color: '#ffffff', fontSize: 18, fontWeight: 'bold' },
        left: 'center'
      },
      tooltip: {
        trigger: 'axis',
        axisPointer: { type: 'shadow' },
        backgroundColor: '#333',
        borderColor: '#555',
        textStyle: { color: '#fff' }
      },
      legend: {
        data: languages,
        type: 'scroll',
        top: 30,
        bottom: 0,
        textStyle: { color: '#ddd', fontSize: 12 },
        pageIconColor: '#fff',
        pageTextStyle: { color: '#aaa' },
        padding: [0, 10, 0, 10],
        itemWidth: 14,
        itemHeight: 10
      },
      grid: {
        left: '3%',
        right: '4%',
        bottom: 100,
        top: 80,
        containLabel: true
      },
      xAxis: {
        type: 'category',
        data: this.formattedPeriods,
        axisLabel: {
          rotate: 45,
          interval: 0,
          fontSize: 10,
          color: '#ccc'
        },
        axisLine: { lineStyle: { color: '#999' } },
        splitLine: { show: false }
      },
      yAxis: {
        type: 'value',
        axisLabel: { color: '#ccc' },
        axisLine: { lineStyle: { color: '#999' } },
        splitLine: { lineStyle: { color: '#444' } }
      },
      series
    });
  }

}




<div class="container">
    <h2 class="header-title">üìä Lines of Code Overview</h2>

    <div class="filters">
        <input type="date" [(ngModel)]="fromDate" [max]="toDate" (change)="onDateChange()" />
        <input type="date" [(ngModel)]="toDate" [max]="todayStr" (change)="onDateChange()" />
    </div>

    <div class="pagination-controls">
        <button (click)="prevPage()" [disabled]="pageIndex === 0">‚¨ÖÔ∏è</button>
        <span>Page {{ pageIndex + 1 }} / {{ totalPages }}</span>
        <button (click)="nextPage()" [disabled]="pageIndex >= totalPages - 1">‚û°Ô∏è</button>
    </div>

    <div #chartContainer class="chart-container"></div>
</div>





.container {
    background-color: #2a2a2a;
    /* Updated background */
    color: #ffffff;
    padding: 20px;
    font-family: 'Segoe UI', sans-serif;
    height: 100vh;
    overflow-y: auto;
}

.header-title {
    color: #ffffff;
    font-size: 22px;
    font-weight: 600;
    margin-bottom: 16px;
    text-align: center;
    letter-spacing: 0.5px;
}

.filters {
    display: flex;
    gap: 12px;
    margin-bottom: 20px;
    flex-wrap: wrap;
    justify-content: center;
}

.filters input {
    padding: 6px 12px;
    background-color: #3a3a3a;
    /* Slight contrast from container */
    color: #fff;
    border: 1px solid #555;
    border-radius: 6px;
    font-size: 14px;
}

.pagination-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
}

.pagination-controls button {
    background-color: #444;
    border: 1px solid #666;
    color: #fff;
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.2s ease-in-out;
}

.pagination-controls button:hover:not(:disabled) {
    background-color: #555;
}

.pagination-controls button:disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

.pagination-controls span {
    color: #e0e0e0;
    font-size: 14px;
}

.chart-container {
    width: 100%;
    height: 600px;
    overflow-x: auto;
    background-color: #2a2a2a;
    /* Match container */
}
