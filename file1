import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';

@Component({
  selector: 'app-code-parser',
  template: `
    <div class="code-container">
      <div class="code-section">
        <h3>HTML Code:</h3>
        <pre><code>{{ htmlCode }}</code></pre>
      </div>
      
      <div class="code-section">
        <h3>CSS Code:</h3>
        <pre><code>{{ cssCode }}</code></pre>
      </div>
      
      <div class="code-section">
        <h3>JavaScript Code:</h3>
        <pre><code>{{ jsCode }}</code></pre>
      </div>
    </div>
  `,
  styles: [`
    .code-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .code-section {
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 5px;
    }
    pre {
      background-color: #f5f5f5;
      padding: 10px;
      border-radius: 3px;
      overflow-x: auto;
      white-space: pre-wrap;
    }
  `]
})
export class CodeParserComponent implements OnChanges {
  @Input() chunk: string = '';
  
  htmlCode: string = '';
  cssCode: string = '';
  jsCode: string = '';
  
  private buffer: string = '';
  private currentCodeType: 'html' | 'css' | 'js' | null = null;
  private insideCodeBlock: boolean = false;
  
  ngOnChanges(changes: SimpleChanges): void {
    if (changes['chunk'] && typeof changes['chunk'].currentValue === 'string') {
      this.processChunk(changes['chunk'].currentValue);
    }
  }
  
  private processChunk(newChunk: string): void {
    // Append new chunk to buffer
    this.buffer += newChunk;
    // Parse only complete lines
    this.parseBuffer();
  }
  
  private parseBuffer(): void {
    let newlineIndex: number;

    // Extract and process full lines
    while ((newlineIndex = this.buffer.indexOf('\n')) >= 0) {
      const line = this.buffer.slice(0, newlineIndex);
      this.buffer = this.buffer.slice(newlineIndex + 1);
      this.processLine(line);
    }

    // ⚠️ Buffer may now contain incomplete fragments (keep them!)
  }
  
  private processLine(line: string): void {
    const trimmedLine = line.trim();

    // Detect start/end of code block
    if (trimmedLine.startsWith('```')) {
      if (!this.insideCodeBlock) {
        // Starting a block
        this.insideCodeBlock = true;
        this.currentCodeType = this.detectCodeType(trimmedLine);
      } else {
        // Ending a block
        this.insideCodeBlock = false;
        this.currentCodeType = null;
      }
      return;
    }

    // If inside a block, append line to correct variable
    if (this.insideCodeBlock && this.currentCodeType) {
      const codeContent = line + '\n';
      switch (this.currentCodeType) {
        case 'html': this.htmlCode += codeContent; break;
        case 'css': this.cssCode += codeContent; break;
        case 'js': this.jsCode += codeContent; break;
      }
    }
  }
  
  private detectCodeType(codeBlockStart: string): 'html' | 'css' | 'js' | null {
    const language = codeBlockStart.replace('```', '').toLowerCase().trim();
    
    if (language.includes('html') || language.includes('htm')) return 'html';
    if (language.includes('css')) return 'css';
    if (language.includes('javascript') || language.includes('js') ||
        language.includes('typescript') || language.includes('ts')) return 'js';
    
    return null; // fallback if unknown
  }
  
  public clearAll(): void {
    this.htmlCode = '';
    this.cssCode = '';
    this.jsCode = '';
    this.buffer = '';
    this.currentCodeType = null;
    this.insideCodeBlock = false;
  }
  
  public getAllCode(): { html: string, css: string, js: string } {
    return { html: this.htmlCode, css: this.cssCode, js: this.jsCode };
  }
}
