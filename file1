import { Injectable } from '@angular/core';

export interface ToolCommand {
  tool: string;
  content: any;
}

export interface WriteModifyContent {
  reasoning: string;
  files: Array<{
    file_path: string;
    file_name: string;
    original_code: string;
    modified_code: string;
  }>;
}

@Injectable({
  providedIn: 'root'
})
export class ToolParserService {
  private pendingQueue: ToolCommand[] = [];
  private isWaitingForApproval = false;
  private isStreamComplete = false;
  private currentPendingData: ToolCommand | null = null;
  private buffer = '';

  public isWaitingForUserApproval = false;

  // Callbacks
  private onUpdateCallback?: () => void;
  private onLogCallback?: (tool: ToolCommand) => void;
  private onCompletionCallback?: () => void;

  // Cancellation
  private abortController: AbortController | null = null;
  private isCancelled = false;

  setUpdateCallback(callback: () => void): void {
    this.onUpdateCallback = callback;
  }

  setLogCallback(callback: (tool: ToolCommand) => void): void {
    this.onLogCallback = callback;
  }

  setCompletionCallback(callback: () => void): void {
    this.onCompletionCallback = callback;
  }

  private triggerUpdate(): void {
    if (this.onUpdateCallback) {
      this.onUpdateCallback();
    }
  }

  async startStreaming(apiUrl: string, options?: RequestInit): Promise<void> {
    try {
      this.isCancelled = false;
      this.isStreamComplete = false;
      this.pendingQueue = [];
      this.isWaitingForApproval = false;
      this.buffer = '';

      this.abortController = new AbortController();

      const fetchOptions: RequestInit = {
        ...options,
        signal: this.abortController.signal
      };

      const response = await fetch(apiUrl, fetchOptions);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('No reader available');
      }

      const decoder = new TextDecoder();

      while (true) {
        if (this.isCancelled) {
          console.log('Streaming cancelled by user');
          reader.cancel();
          break;
        }

        const { done, value } = await reader.read();

        if (done) {
          this.isStreamComplete = true;

          // Check if we're done or still waiting
          if (!this.isWaitingForApproval && this.pendingQueue.length === 0) {
            if (this.onCompletionCallback) {
              this.onCompletionCallback();
            }
          }
          break;
        }

        const chunk = decoder.decode(value, { stream: true });

        // Process each character in the chunk
        for (let char of chunk) {
          const result = this.processChunk(char);

          if (result.success && result.data) {
            let toolData = result.data;

            // Handle tool data
            if (toolData.tool) {
              // Validate WRITE/MODIFY tools have files
              if ((toolData.tool === 'WRITE' || toolData.tool === 'MODIFY')) {
                const content = toolData.content as WriteModifyContent;
                if (!content.files || !Array.isArray(content.files) || content.files.length === 0) {
                  console.warn(`âš ï¸ Ignoring ${toolData.tool} tool - empty files array`);
                  continue;
                }
              }

              this.pendingQueue.push(toolData);
              if (!this.isWaitingForApproval) {
                this.processQueue();
              }
            }
          }
        }
      }

    } catch (error: any) {
      this.isStreamComplete = true;
      if (error.name === 'AbortError') {
        console.log('Streaming aborted');
      } else {
        console.error('Streaming error:', error);
        throw error;
      }
    } finally {
      this.abortController = null;
    }
  }

  private processChunk(char: string): { success: boolean; data: any } {
    this.buffer += char;

    try {
      const parsed = JSON.parse(this.buffer);
      this.buffer = '';
      return { success: true, data: parsed };
    } catch (error) {
      return { success: false, data: null };
    }
  }

  approveAndContinue(): void {
    if (this.currentPendingData && this.onLogCallback) {
      console.log('âœ… APPROVED AND LOGGED:');
      this.onLogCallback(this.currentPendingData);
    }

    this.currentPendingData = null;
    this.isWaitingForApproval = false;
    this.isWaitingForUserApproval = false;

    this.triggerUpdate();

    // Process next item in queue
    this.processQueue();
  }

  private processQueue(): void {
    if (this.pendingQueue.length > 0 && !this.isWaitingForApproval) {
      const nextItem = this.pendingQueue.shift();
      if (nextItem) {
        this.handleParsedJSON(nextItem);
      }
    } else if (this.pendingQueue.length === 0 && this.isStreamComplete && !this.isWaitingForApproval) {
      // All done
      if (this.onCompletionCallback) {
        this.onCompletionCallback();
      }
    }
  }

  private handleParsedJSON(data: ToolCommand): void {
    const tool = data.tool;

    if (tool === 'READ') {
      // READ tool - log immediately
      if (this.onLogCallback) {
        this.onLogCallback(data);
      }

      // Continue processing queue
      this.processQueue();
    } else if (tool === 'WRITE' || tool === 'MODIFY') {
      // WRITE/MODIFY tool - require approval
      if (this.onLogCallback) {
        this.onLogCallback(data);
      }

      this.isWaitingForApproval = true;
      this.isWaitingForUserApproval = true;
      this.currentPendingData = data;

      this.triggerUpdate();
    } else {
      // Unknown tool - log immediately
      if (this.onLogCallback) {
        this.onLogCallback(data);
      }

      // Continue processing queue
      this.processQueue();
    }
  }

  cancelStreaming(): void {
    console.log('Cancelling streaming...');
    this.isCancelled = true;

    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }

    this.cleanup();
  }

  cleanup(): void {
    this.pendingQueue = [];
    this.currentPendingData = null;
    this.isWaitingForApproval = false;
    this.isWaitingForUserApproval = false;
    this.isStreamComplete = false;
    this.buffer = '';
    this.onUpdateCallback = undefined;
    this.onLogCallback = undefined;
    this.onCompletionCallback = undefined;
    this.abortController = null;
    this.isCancelled = false;
  }

  reset(): void {
    this.cleanup();
    this.triggerUpdate();
  }
}





















import { Component, ChangeDetectorRef } from '@angular/core';
import { ToolParserService, ToolCommand, WriteModifyContent } from './services/tool-parser.service';

@Component({
  selector: 'app-tool-processor',
  templateUrl: './tool-processor.component.html',
  styleUrls: ['./tool-processor.component.css']
})
export class ToolProcessorComponent {

  constructor(
    public toolParser: ToolParserService,
    private cdr: ChangeDetectorRef
  ) {}

  onApprove(): void {
    console.log('User clicked OK - Executing and continuing...');
    this.toolParser.approveAndContinue();
  }

  onCancel(): void {
    console.log('User clicked Cancel');
    this.toolParser.cancelStreaming();
  }

  async handleStreamingResponse(): Promise<void> {
    let isFirstChunk = true;

    this.toolParser.setUpdateCallback(() => {
      this.cdr.detectChanges();
    });

    this.toolParser.setLogCallback((tool: ToolCommand) => {
      if (isFirstChunk) {
        console.log('ðŸŽ‰ First chunk received!');
        isFirstChunk = false;
      }

      try {
        if (tool.tool === 'READ') {
          console.log('ðŸ“– READ Tool:');
          const content = typeof tool.content === 'string'
            ? tool.content
            : JSON.stringify(tool.content);
          console.log(content);
          console.log('');
        } else if (tool.tool === 'WRITE') {
          console.log('âš ï¸ WRITE Tool detected:');
          console.log(tool.content);
          console.log('');
        } else if (tool.tool === 'MODIFY') {
          console.log('âš ï¸ MODIFY Tool detected:');
          console.log(tool.content);
          console.log('');
        }
      } catch (error) {
        console.error('Error logging tool:', error);
        console.log('Tool (raw):', tool);
      }
    });

    this.toolParser.setCompletionCallback(() => {
      console.log('ðŸŽŠ All tasks completed - Nothing pending!');
    });

    try {
      const apiUrl = 'https://your-api.com/stream';

      const options: RequestInit = {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer your-token-here'
        },
        body: JSON.stringify({
          query: 'your query here'
        })
      };

      await this.toolParser.startStreaming(apiUrl, options);

      console.log('âœ… Streaming completed successfully');

    } catch (error: any) {
      if (error.name === 'AbortError') {
        console.log('âš ï¸ Streaming was cancelled');
      } else {
        console.error('âŒ Error:', error);
      }
    } finally {
      this.toolParser.cleanup();
    }
  }

  simulateStreaming(): void {
    let isFirstChunk = true;

    this.toolParser.setUpdateCallback(() => {
      this.cdr.detectChanges();
    });

    this.toolParser.setLogCallback((tool: ToolCommand) => {
      if (isFirstChunk) {
        console.log('ðŸŽ‰ First chunk received!');
        isFirstChunk = false;
      }

      try {
        if (tool.tool === 'READ') {
          console.log('ðŸ“– READ Tool:');
          const content = typeof tool.content === 'string'
            ? tool.content
            : JSON.stringify(tool.content);
          console.log(content);
          console.log('');
        } else if (tool.tool === 'WRITE') {
          console.log('âš ï¸ WRITE Tool detected:');
          console.log(tool.content);
          console.log('');
        } else if (tool.tool === 'MODIFY') {
          console.log('âš ï¸ MODIFY Tool detected:');
          console.log(tool.content);
          console.log('');
        }
      } catch (error) {
        console.error('Error logging tool:', error);
        console.log('Tool (raw):', tool);
      }
    });

    this.toolParser.setCompletionCallback(() => {
      console.log('ðŸŽŠ All tasks completed - Nothing pending!');
    });

    console.log('=== Starting Simulation ===\n');

    const data = [
      '{"tool": "READ", "content": "First READ - logs immediately"}',
      '{"tool": "READ", "content": "Second READ - logs immediately"}',
      '{"tool": "WRITE", "content": {"reasoning": "Writing file", "files": [{"file_path": "/src", "file_name":"app.js", "original_code":"", "modified_code":"code"}]}}',
      '{"tool": "READ", "content": "Third READ - will NOT log until OK is clicked"}',
      '{"tool": "READ", "content": "Fourth READ - will NOT log until OK is clicked"}',
      '{"tool": "MODIFY", "content": {"reasoning": "Modifying file", "files": [{"file_path": "/src", "file_name":"app.js", "original_code":"old", "modified_code":"new"}]}}',
      '{"tool": "READ", "content": "Fifth READ - will NOT log until OK is clicked"}',
      '{"tool": "READ", "content": "Sixth READ - will log after OK"}',
    ];

    let index = 0;
    const interval = setInterval(() => {
      if (index < data.length) {
        console.log(`\n--- Chunk #${index + 1} received ---`);
        try {
          // Simulate character-by-character streaming
          const chunk = data[index];
          for (let char of chunk) {
            // This simulates the streaming API
            // In real usage, the service handles this internally
          }
          // For simulation, just add the whole chunk at once
          // In reality, startStreaming processes char by char
          console.log('Processing:', chunk);
        } catch (error) {
          console.error('Error processing chunk:', error);
        }
        index++;
      } else {
        clearInterval(interval);
        console.log('\n=== âœ… Simulation complete - Use handleStreamingResponse() for real API ===');
      }
    }, 1000);
  }
}
