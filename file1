import { jsonrepair } from 'jsonrepair';

// Add this property at the top of the class
private brokenChunkBuffer = '';

// Modify startStreaming method
async startStreaming(apiUrl: string, options?: RequestInit): Promise<void> {
  try {
    this.isCancelled = false;
    this.isStreamingActive = true;
    this.brokenChunkBuffer = '';  // Reset buffer
    
    this.abortController = new AbortController();
    
    const fetchOptions: RequestInit = {
      ...options,
      signal: this.abortController.signal
    };

    const response = await fetch(apiUrl, fetchOptions);

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const reader = response.body?.getReader();
    if (!reader) {
      throw new Error('No reader available');
    }

    const decoder = new TextDecoder();

    while (true) {
      if (this.isCancelled) {
        console.log('Streaming cancelled by user');
        reader.cancel();
        break;
      }

      const { done, value } = await reader.read();

      if (done) {
        // Process any remaining broken buffer at the end
        if (this.brokenChunkBuffer.trim() && !this.isCancelled) {
          console.log('Processing final broken chunk buffer');
          this.tryProcessChunk(this.brokenChunkBuffer);
        }
        break;
      }

      const chunk = decoder.decode(value, { stream: true });
      
      // Try to repair and process the chunk
      this.tryProcessChunk(chunk);
    }

    this.isStreamingActive = false;

    if (this.processingQueue.length === 0 && !this.waitingForApproval && this.onCompletionCallback) {
      this.onCompletionCallback();
    }

  } catch (error: any) {
    this.isStreamingActive = false;
    if (error.name === 'AbortError') {
      console.log('Streaming aborted');
    } else {
      console.error('Streaming error:', error);
      throw error;
    }
  } finally {
    this.abortController = null;
    this.brokenChunkBuffer = '';
  }
}

// Add new method to try processing chunks with jsonrepair
private tryProcessChunk(chunk: string): void {
  // If we have broken chunk buffer, prepend it
  const fullChunk = this.brokenChunkBuffer + chunk;
  
  try {
    // Try to repair the JSON
    const repairedChunk = jsonrepair(fullChunk);
    
    console.log('✅ JSON repaired successfully');
    
    // Clear the broken buffer since repair succeeded
    this.brokenChunkBuffer = '';
    
    // Process the repaired chunk using existing logic
    const processedBuffer = this.processBuffer(repairedChunk);
    
    processedBuffer.completeObjects.forEach(obj => {
      if (!this.isCancelled) {
        this.addToolFromStream(obj);
      }
    });
    
    // If there's remaining content, store it in broken buffer
    if (processedBuffer.remaining.trim()) {
      this.brokenChunkBuffer = processedBuffer.remaining;
    }
    
  } catch (error) {
    // JSON repair failed, add to broken buffer and wait for next chunk
    console.warn('⚠️ JSON repair failed, waiting for next chunk...');
    this.brokenChunkBuffer = fullChunk;
  }
}

// Modify cleanup to clear broken buffer
cleanup(): void {
  this.processingQueue = [];
  this.currentWriteModifyTool = null;
  this.isProcessing = false;
  this.waitingForApproval = false;
  this.isWaitingForUserApproval = false;
  this.isStreamingActive = false;
  this.brokenChunkBuffer = '';  // Clear broken buffer
  this.onUpdateCallback = undefined;
  this.onLogCallback = undefined;
  this.onCompletionCallback = undefined;
  this.abortController = null;
  this.isCancelled = false;
}
