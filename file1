// Track editing state and comment states
editingComments = new Map<string, string>(); // commentId -> editText
commentStates = new Map<string, CommentState>();
processingComments = new Map<string, 'accept' | 'reject' | 'save'>(); // Track which action is being processed
isDarkMode = false; // Track theme mode










isProcessing(comment: AIComment): boolean {
  return this.processingComments.has(this.getCommentId(comment));
}

isProcessingAction(comment: AIComment, action: 'accept' | 'reject' | 'save'): boolean {
  const commentId = this.getCommentId(comment);
  return this.processingComments.get(commentId) === action;
}

acceptComment(comment: AIComment): void {
  if (!this.selectedFile || this.isActionDisabled(comment)) return;
  
  const commentId = this.getCommentId(comment);
  this.processingComments.set(commentId, 'accept');
  
  // Simulate API call delay
  setTimeout(() => {
    const displayText = this.getDisplayText(comment);
    this.saveCommentState(
      this.selectedFile!.file_path,
      comment.line,
      comment.side,
      'accepted',
      displayText
    );
    this.processingComments.delete(commentId);
  }, 800);
}

rejectComment(comment: AIComment): void {
  if (!this.selectedFile || this.isActionDisabled(comment)) return;
  
  const commentId = this.getCommentId(comment);
  this.processingComments.set(commentId, 'reject');
  
  // Simulate API call delay
  setTimeout(() => {
    const displayText = this.getDisplayText(comment);
    this.saveCommentState(
      this.selectedFile!.file_path,
      comment.line,
      comment.side,
      'rejected',
      displayText
    );
    this.processingComments.delete(commentId);
  }, 800);
}

saveComment(comment: AIComment): void {
  if (!this.selectedFile) return;
  
  const commentId = this.getCommentId(comment);
  this.processingComments.set(commentId, 'save');
  
  // Simulate API call delay
  setTimeout(() => {
    const newText = this.getEditText(comment);
    const state = this.getCommentState(comment);
    this.saveCommentState(
      this.selectedFile!.file_path,
      comment.line,
      comment.side,
      state.status,
      newText
    );
    this.editingComments.delete(commentId);
    this.processingComments.delete(commentId);
  }, 800);
}














<button 
  class="comment-btn accept" 
  *ngIf="!isEditing(line.comment)"
  [disabled]="isActionDisabled(line.comment)"
  (click)="acceptComment(line.comment)">
  <span *ngIf="!isProcessingAction(line.comment, 'accept')">âœ“ Accept</span>
  <span *ngIf="isProcessingAction(line.comment, 'accept')" class="spinner-container">
    <span class="spinner"></span>
    <span>Accepting...</span>
  </span>
</button>
<button 
  class="comment-btn reject" 
  *ngIf="!isEditing(line.comment)"
  [disabled]="isActionDisabled(line.comment)"
  (click)="rejectComment(line.comment)">
  <span *ngIf="!isProcessingAction(line.comment, 'reject')">âœ— Reject</span>
  <span *ngIf="isProcessingAction(line.comment, 'reject')" class="spinner-container">
    <span class="spinner"></span>
    <span>Rejecting...</span>
  </span>
</button>











<button 
  class="comment-btn save" 
  *ngIf="isEditing(line.comment)"
  [disabled]="isProcessing(line.comment)"
  (click)="saveComment(line.comment)">
  <span *ngIf="!isProcessingAction(line.comment, 'save')">ðŸ’¾ Save</span>
  <span *ngIf="isProcessingAction(line.comment, 'save')" class="spinner-container">
    <span class="spinner"></span>
    <span>Saving...</span>
  </span>
</button>



