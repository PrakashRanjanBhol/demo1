import React, { useState, useMemo } from 'react';
import ReactECharts from 'echarts-for-react';
import { Dropdown } from 'primereact/dropdown';
import { Dialog } from 'primereact/dialog';
import styles from './ScatterChart.module.css';

const ScatterChart = () => {
    const response = [
        { defect_type: 'Test', defect_category: 'Line Defect', xcoord: 120, ycoord: 440 },
        { defect_type: 'Actual', defect_category: 'ABC', xcoord: 130, ycoord: 430 },
        { defect_type: 'Test', defect_category: 'Line Defect', xcoord: 140, ycoord: 420 },
        { defect_type: 'Actual', defect_category: 'ABC', xcoord: 150, ycoord: 410 }
    ];

    const cords = [
        [[10, 11], [20, 21]],
        [[32, 32], [41, 42]]
    ];

    const allTypes = Array.from(new Set(response.map(item => item.defect_type)));
    const [selectedType, setSelectedType] = useState(allTypes[0]);
    const [visible, setVisible] = useState(false);
    const [legendState, setLegendState] = useState({});

    const filteredData = useMemo(
        () => response.filter(item => item.defect_type === selectedType),
        [selectedType]
    );

    const hasLineDefect = useMemo(
        () => filteredData.some(item => item.defect_category === 'Line Defect'),
        [filteredData]
    );

    const groupedScatter = useMemo(() => {
        const result = {};
        filteredData.forEach(item => {
            if (item.defect_category !== 'Line Defect') {
                const label = `${item.defect_category} (Points)`;
                if (!result[label]) result[label] = [];
                result[label].push([item.xcoord, item.ycoord]);
            }
        });
        return result;
    }, [filteredData]);

    const scatterSeries = Object.entries(groupedScatter).map(([category, data], index) => ({
        name: category,
        type: 'scatter',
        data,
        symbolSize: 12,
        itemStyle: {
            color: ['#91cc75', '#fac858', '#ee6666', '#73c0de'][index % 4]
        }
    }));

    const actualLineSeries = hasLineDefect
        ? [{
            name: 'Line Defect (Lines)',
            type: 'line',
            data: cords.flatMap(pair => [...pair, [null, null]]),
            lineStyle: {
                type: 'dashed',
                width: 2,
                color: '#ff0'  // changed to yellow
            },
            symbol: 'circle',
            symbolSize: 8,
            itemStyle: { color: '#ff0' }, // yellow points if symbol shown
            emphasis: { focus: 'series' },
            legendHoverLink: true
        }]
        : [];

    const endpointData = hasLineDefect
        ? cords.flatMap(([start, end]) => [
            { value: start, label: 'Start Point' },
            { value: end, label: 'End Point' }
        ])
        : [];

    const lineLegendKey = 'Line Defect (Lines)';
    const lineVisible = legendState[lineLegendKey] !== false; // default to true

    const endpointSeries = hasLineDefect && lineVisible
        ? [{
            name: 'Line Endpoints',
            type: 'scatter',
            data: endpointData.map(p => p.value),
            symbolSize: 10,
            itemStyle: { color: '#fff' },
            tooltip: {
                formatter: (params) => {
                    const point = endpointData[params.dataIndex];
                    return `${point.label}<br/>X: ${point.value[0]}<br/>Y: ${point.value[1]}`;
                }
            }
        }]
        : [];

    const legendEntries = [
        ...Object.keys(groupedScatter),
        ...(hasLineDefect ? [lineLegendKey] : [])
    ];

    const chartOption = {
        title: {
            text: `Scatter Plot - ${selectedType}`,
            left: 'center',
            textStyle: { color: '#fff' }
        },
        legend: {
            top: 30,
            textStyle: { color: '#ccc' },
            data: legendEntries,
            selected: Object.fromEntries(
                legendEntries.map(name => [name, legendState[name] !== false])
            )
        },
        tooltip: {
            trigger: 'item',
            formatter: params =>
                `Series: ${params.seriesName}<br/>X: ${params.data[0]}<br/>Y: ${params.data[1]}`
        },
        xAxis: {
            type: 'value',
            name: 'X Coord',
            nameTextStyle: { color: '#ccc' },
            axisLabel: { color: '#aaa' },
            splitLine: { lineStyle: { type: 'dashed', color: '#444' } }
        },
        yAxis: {
            type: 'value',
            name: 'Y Coord',
            nameTextStyle: { color: '#ccc' },
            axisLabel: { color: '#aaa' },
            splitLine: { lineStyle: { type: 'dashed', color: '#444' } }
        },
        series: [
            ...scatterSeries,
            ...actualLineSeries,
            ...endpointSeries
        ]
    };

    const handleLegendChange = (e) => {
        setLegendState(prev => ({
            ...prev,
            ...e.selected
        }));
    };

    return (
        <>
            <div className={styles.container}>
                <div className={styles.chartWrapper}>
                    <i
                        className={`pi pi-window-maximize ${styles.expandIcon}`}
                        onClick={() => setVisible(true)}
                        title="Expand"
                    />
                    <ReactECharts
                        option={chartOption}
                        style={{ height: '100%', width: '100%' }}
                        onEvents={{ legendselectchanged: handleLegendChange }}
                    />
                </div>
                <div className={styles.dropdownWrapper}>
                    <Dropdown
                        value={selectedType}
                        options={allTypes.map(type => ({ label: type, value: type }))}
                        onChange={(e) => setSelectedType(e.value)}
                        placeholder="Select defect_type"
                        className={styles.dropdown}
                    />
                </div>
            </div>

            <Dialog
                header={`Full View - ${selectedType}`}
                visible={visible}
                onHide={() => setVisible(false)}
                modal
                dismissableMask
                maximizable
                style={{ width: '90vw', height: '90vh' }}
                contentStyle={{ height: 'calc(100% - 3rem)' }}
            >
                <ReactECharts
                    option={chartOption}
                    style={{ height: '100%', width: '100%' }}
                    onEvents={{ legendselectchanged: handleLegendChange }}
                />
            </Dialog>
        </>
    );
};

export default ScatterChart;
