/**
 * Map API response to result items
 */
private mapResponseToResultItems(data: any): void {
  this.resultItems = [];

  // Add Summary with markdown rendering
  if (data.summary) {
    const htmlContent: any = marked(data.summary);
    this.resultItems.push({
      id: 'summary-1',
      title: 'Summary',
      icon: 'document',
      content: data.summary,
      type: 'summary',
      htmlContent: this.sanitizer.bypassSecurityTrustHtml(htmlContent)
    });
  }

  // Add Keywords - FIX: Add type annotation for k
  if (data.keywords && Array.isArray(data.keywords) && data.keywords.length > 0) {
    this.resultItems.push({
      id: 'keywords-1',
      title: 'Key Topics',
      icon: 'tag',
      content: data.keywords.map((k: string) => `â€¢ ${k}`).join(' '),
      type: 'keywords',
      keywords: data.keywords
    });
  }

  // Add Assessment Questions (FAQ as MCQ)
  if (data.faq) {
    try {
      // Parse the JSON string
      const parsedFaq = typeof data.faq === 'string' ? JSON.parse(data.faq) : data.faq;
      
      if (Array.isArray(parsedFaq) && parsedFaq.length > 0) {
        this.resultItems.push({
          id: 'assessment-1',
          title: 'Assessment Questions',
          icon: 'question',
          content: `${parsedFaq.length} questions`,
          type: 'questions',
          assessmentQuestions: parsedFaq
        });
      }
    } catch (error) {
      console.error('Error parsing FAQ JSON:', error);
    }
  }
}

/**
 * Get option value by key - FIX: Add proper typing
 */
getOptionValue(options: MCQOption, key: string): string {
  return options[key as keyof MCQOption];
}





<!-- Replace this line -->
<span class="option-text">{{ question.options[optionKey] }}</span>

<!-- With this line -->
<span class="option-text">{{ getOptionValue(question.options, optionKey) }}</span>
