import { Component, OnInit, OnDestroy, ElementRef, ViewChild, AfterViewInit, HostListener } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import { marked } from 'marked';
import hljs from 'highlight.js';
import { forkJoin, Observable, Subject } from 'rxjs';
import { map, catchError, takeUntil } from 'rxjs/operators';
import { of } from 'rxjs';

interface MarkdownFile {
  folder: string;
  file: string;
}

interface ProcessedFile {
  folderName: string;
  fileName: string;
  content: string;
  path: string;
}

interface TocItem {
  id: string;
  text: string;
  level: number;
}

@Component({
  selector: 'app-documentation',
  templateUrl: './documentation.component.html',
  styleUrls: ['./documentation.component.scss']
})
export class DocumentationComponent implements OnInit, AfterViewInit, OnDestroy {
  @ViewChild('sidebar', { static: false }) sidebar!: ElementRef<HTMLDivElement>;
  @ViewChild('content', { static: false }) content!: ElementRef<HTMLDivElement>;
  @ViewChild('mainContent', { static: false }) mainContent!: ElementRef<HTMLDivElement>;
  @ViewChild('contentBody', { static: false }) contentBodyRef!: ElementRef<HTMLDivElement>;
  @ViewChild('tocContainer', { static: false }) tocContainerRef!: ElementRef<HTMLDivElement>;

  private destroy$ = new Subject<void>();

  htmlContent: SafeHtml = '';
  tocItems: TocItem[] = [];
  activeSection: number = 0;
  isLoading: boolean = true;
  loadingError: string = '';

  // Define your markdown file structure
  private markdownFiles: MarkdownFile[] = [
    { folder: 'Page1', file: 'page1.md' },
    { folder: 'Page2', file: 'page2.md' },
    { folder: 'Page3', file: 'page3.md' },
    { folder: 'Page4', file: 'page4.md' }
  ];

  constructor(
    private http: HttpClient,
    private sanitizer: DomSanitizer
  ) {
    // Configure marked options
    marked.setOptions({
      gfm: true,
      breaks: false,
      pedantic: false
    });
  }

  ngOnInit(): void {
    this.loadAllMarkdownFiles();
  }

  ngAfterViewInit(): void {
    setTimeout(() => {
      this.setupEventListeners();
    }, 100);
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  private setupEventListeners(): void {
    if (this.content?.nativeElement || this.contentBodyRef?.nativeElement) {
      const scrollElement = this.content?.nativeElement || this.contentBodyRef?.nativeElement;
      if (scrollElement) {
        scrollElement.addEventListener('scroll', () => {
          this.updateActiveSection();
        });
      }
    }
  }

  private async loadAllMarkdownFiles(): Promise<void> {
    this.isLoading = true;
    this.loadingError = '';

    try {
      const fileRequests: Observable<ProcessedFile>[] = this.markdownFiles.map(({ folder, file }) => {
        const path = `assets/markdown/${folder}/${file}`;
        return this.http.get(path, { responseType: 'text' }).pipe(
          map(content => ({
            folderName: folder,
            fileName: file,
            content,
            path
          })),
          catchError(error => {
            console.warn(`Failed to load ${path}:`, error);
            return of({
              folderName: folder,
              fileName: file,
              content: `# ${file}\n\nError loading content from ${path}`,
              path
            });
          }),
          takeUntil(this.destroy$)
        );
      });

      forkJoin(fileRequests)
        .pipe(takeUntil(this.destroy$))
        .subscribe({
          next: (markdownFiles) => {
            this.processMarkdownFiles(markdownFiles);
            this.isLoading = false;
          },
          error: (error) => {
            console.error('Error loading markdown files:', error);
            this.loadingError = 'Failed to load documentation files';
            this.isLoading = false;
          }
        });
    } catch (error) {
      console.error('Error in loadAllMarkdownFiles:', error);
      this.loadingError = 'Failed to initialize documentation loading';
      this.isLoading = false;
    }
  }

  private processMarkdownFiles(markdownFiles: ProcessedFile[]): void {
    let combinedMarkdown = '';

    markdownFiles.forEach((file) => {
      let content = file.content;

      // ðŸ”¹ If no heading exists in the file, fallback to filename as header
      if (!/^#{1,6}\s/m.test(content.trim())) {
        content = `# ${this.formatFileName(file.fileName)}\n\n` + content;
      }

      combinedMarkdown += content + '\n\n';
    });

    const rawHtml = this.parseMarkdown(combinedMarkdown);
    this.htmlContent = this.sanitizer.bypassSecurityTrustHtml(rawHtml);

    setTimeout(() => {
      this.generateTOC();
      this.applySyntaxHighlighting();
    }, 100);
  }

  private formatFileName(fileName: string): string {
    return fileName.replace(/\.md$/, '').replace(/([a-z])([0-9])/gi, '$1 $2');
  }

  private applySyntaxHighlighting(): void {
    const contentElement = this.content?.nativeElement || this.contentBodyRef?.nativeElement;
    if (contentElement) {
      const codeBlocks = contentElement.querySelectorAll('pre code');
      codeBlocks.forEach((block: any) => {
        hljs.highlightElement(block);
      });
    }
  }

  generateTOC(): void {
    const contentElement = this.content?.nativeElement || this.contentBodyRef?.nativeElement;
    if (!contentElement) return;

    const headers = contentElement.querySelectorAll('h1, h2, h3, h4, h5, h6');
    this.tocItems = [];

    headers.forEach((header: any, index: number) => {
      const level = parseInt(header.tagName.charAt(1));
      const text = header.textContent?.replace(/\s+/g, ' ').trim() || '';
      const id = 'heading-' + index;

      header.id = id;
      this.tocItems.push({ id, text, level });
    });
  }

  updateActiveSection(): void {
    const contentElement = this.content?.nativeElement || this.contentBodyRef?.nativeElement;
    if (!contentElement) return;

    const headers = contentElement.querySelectorAll('h1, h2, h3, h4, h5, h6');
    let currentSection = 0;
    const scrollPos = contentElement.scrollTop + 50;

    headers.forEach((header: any, index: number) => {
      const headerTop = header.offsetTop;
      if (headerTop <= scrollPos) {
        currentSection = index;
      }
    });

    if (this.activeSection !== currentSection) {
      this.activeSection = currentSection;
      this.updateSidebarScroll();
    }
  }

  private updateSidebarScroll(): void {
    const sidebarElement = this.sidebar?.nativeElement;
    const tocElement = this.tocContainerRef?.nativeElement;

    if (!sidebarElement && !tocElement) return;

    const container = tocElement || sidebarElement;
    const activeLinks = container.querySelectorAll('a');
    const activeLink = activeLinks[this.activeSection];

    if (activeLink) {
      activeLink.scrollIntoView({
        block: 'nearest',
        behavior: 'smooth'
      });
    }
  }

  scrollToSection(event: Event, id: string, index: number): void {
    event.preventDefault();

    const element = document.getElementById(id);
    const contentElement = this.content?.nativeElement || this.contentBodyRef?.nativeElement;

    if (element && contentElement) {
      const containerTop = contentElement.offsetTop;
      const elementTop = element.offsetTop;

      contentElement.scrollTo({
        top: elementTop - containerTop - 20,
        behavior: 'smooth'
      });
    }

    this.activeSection = index;
  }

  onScroll(): void {
    this.updateActiveSection();
  }

  @HostListener('window:resize')
  onResize(): void {
    setTimeout(() => this.updateActiveSection(), 100);
  }

  parseMarkdown(md: string): string {
    return marked.parse(md, { async: false }) as string;
  }

  reloadContent(): void {
    this.loadAllMarkdownFiles();
  }
}
