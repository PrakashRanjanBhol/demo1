insertCommentsAtLines(file: FileData, fileIndex: number): void {
  file.ai_comments.forEach((comment, commentIndex) => {
    const commentId = this.getCommentId(fileIndex, commentIndex);
    let commentElement = document.getElementById(`comment-${commentId}`);

    if (!commentElement) {
      console.warn(`Comment element not found in DOM: comment-${commentId}`);
      return;
    }

    // Clone the comment element to preserve it
    const commentClone = commentElement.cloneNode(true) as HTMLElement;

    // Re-bind event listeners on the cloned element
    this.bindCommentEvents(commentClone, fileIndex, commentIndex);

    // Find the diff container
    const diffContainer = document.querySelector(`#diff-output-${fileIndex}`);
    if (!diffContainer) {
      console.warn(`Diff container not found for file index: ${fileIndex}`);
      return;
    }

    // Get all rows from the diff
    const rows = diffContainer.querySelectorAll('.d2h-diff-tbody tr');
    let commentInserted = false;

    rows.forEach((row) => {
      if (commentInserted) return;

      if (this.viewMode === 'side-by-side') {
        // In side-by-side mode, look for line numbers directly in the row
        const lineNumberElements = row.querySelectorAll('.d2h-code-side-linenumber');
        
        if (lineNumberElements.length === 0) return; // Skip rows without line numbers
        
        Array.from(lineNumberElements).forEach((lineNumElement, index) => {
          if (commentInserted) return;
          
          const lineText = lineNumElement.textContent?.trim() || '';
          const lineNum = parseInt(lineText);
          
          if (isNaN(lineNum) || lineNum !== comment.line) return;
          
          // In side-by-side mode:
          // - Even indices (0, 2, 4...) are left side (old file/FROM)
          // - Odd indices (1, 3, 5...) are right side (new file/TO)
          const isLeftSide = index % 2 === 0;
          const isRightSide = index % 2 === 1;
          
          // Check if this matches the comment's side
          const shouldInsertHere = (comment.side === 'FROM' && isLeftSide) || 
                                  (comment.side === 'TO' && isRightSide);
          
          if (!shouldInsertHere) {
            return;
          }

          const nextRow = row.nextElementSibling;
          if (nextRow && nextRow.classList.contains('comment-row')) {
            commentInserted = true;
            return;
          }

          const commentRow = document.createElement('tr');
          commentRow.className = 'comment-row';

          const commentCell = document.createElement('td');
          commentCell.className = 'comment-cell';
          
          // Count total columns in the row
          const totalColumns = row.querySelectorAll('td').length;
          commentCell.setAttribute('colspan', totalColumns.toString());
          commentCell.style.padding = '0';
          commentCell.style.border = 'none';
          commentCell.style.backgroundColor = 'var(--bitbucket-file-comparator-bg-overlay)';

          const wrapperDiv = document.createElement('div');
          wrapperDiv.className = 'comment-wrapper';
          wrapperDiv.style.width = '100%';
          wrapperDiv.style.display = 'block';

          commentClone.style.display = 'block';
          commentClone.style.visibility = 'visible';
          commentClone.style.opacity = '1';

          wrapperDiv.appendChild(commentClone);
          commentCell.appendChild(wrapperDiv);
          commentRow.appendChild(commentCell);

          row.parentNode?.insertBefore(commentRow, row.nextSibling);

          commentInserted = true;
          console.log(`✓ Comment inserted for line ${comment.line} (side: ${comment.side})`);
        });
      } else {
        // Line-by-line (unified) mode
        const lineNumberElements = row.querySelectorAll('.d2h-code-linenumber');
        
        if (lineNumberElements.length === 0) return; // Skip rows without line numbers
        
        Array.from(lineNumberElements).forEach((lineNumElement, index) => {
          if (commentInserted) return;
          
          const lineText = lineNumElement.textContent?.trim() || '';
          const lineNum = parseInt(lineText);

          if (isNaN(lineNum) || lineNum !== comment.line) return;

          // In unified view:
          // - Index 0 is old file line number (FROM)
          // - Index 1 is new file line number (TO)
          const shouldInsertHere = (comment.side === 'FROM' && index === 0) || 
                                  (comment.side === 'TO' && index === 1);
          
          if (!shouldInsertHere) {
            return;
          }

          const nextRow = row.nextElementSibling;
          if (nextRow && nextRow.classList.contains('comment-row')) {
            commentInserted = true;
            return;
          }

          const commentRow = document.createElement('tr');
          commentRow.className = 'comment-row';

          const commentCell = document.createElement('td');
          commentCell.className = 'comment-cell';
          commentCell.setAttribute('colspan', '4');
          commentCell.style.padding = '0';
          commentCell.style.border = 'none';
          commentCell.style.backgroundColor = 'var(--bitbucket-file-comparator-bg-overlay)';

          const wrapperDiv = document.createElement('div');
          wrapperDiv.className = 'comment-wrapper';
          wrapperDiv.style.width = '100%';
          wrapperDiv.style.display = 'block';

          commentClone.style.display = 'block';
          commentClone.style.visibility = 'visible';
          commentClone.style.opacity = '1';

          wrapperDiv.appendChild(commentClone);
          commentCell.appendChild(wrapperDiv);
          commentRow.appendChild(commentCell);

          row.parentNode?.insertBefore(commentRow, row.nextSibling);

          commentInserted = true;
          console.log(`✓ Comment inserted for line ${comment.line} (side: ${comment.side})`);
        });
      }
    });

    if (!commentInserted) {
      console.warn(`Could not insert comment for line ${comment.line} (side: ${comment.side}) in file ${file.file_path}`);
      
      // Debug: Show what line numbers are available
      if (this.viewMode === 'side-by-side') {
        const allLineNums = diffContainer.querySelectorAll('.d2h-code-side-linenumber');
        console.log('Available side-by-side line numbers:', 
          Array.from(allLineNums).map((el, idx) => ({
            index: idx,
            line: el.textContent?.trim(),
            side: idx % 2 === 0 ? 'FROM (left)' : 'TO (right)'
          }))
        );
      } else {
        const allLineNums = diffContainer.querySelectorAll('.d2h-code-linenumber');
        console.log('Available unified line numbers:', 
          Array.from(allLineNums).map((el, idx) => ({
            index: idx,
            line: el.textContent?.trim()
          }))
        );
      }
    }
  });
}
