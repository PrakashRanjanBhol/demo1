import { Component, OnInit, AfterViewInit, ElementRef, ViewChild, HostListener } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { marked } from 'marked';
import hljs from 'highlight.js';
import { forkJoin, Observable } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { of } from 'rxjs';

interface MarkdownFile {
  folderName: string;
  fileName: string;
  content: string;
  path: string;
}

@Component({
  selector: 'app-documentation',
  templateUrl: './documentation.component.html',
  styleUrls: ['./documentation.component.scss']
})
export class DocumentationComponent implements OnInit, AfterViewInit {
  @ViewChild('sidebar') sidebar!: ElementRef;
  @ViewChild('content') content!: ElementRef;
  @ViewChild('mainContent') mainContent!: ElementRef;

  htmlContent: string = '';
  tocItems: Array<{ id: string, text: string, level: number }> = [];
  activeSection: number = 0;
  isLoading: boolean = true;
  loadingError: string = '';

  // Define your markdown file structure
  private markdownFiles = [
    { folder: 'Page1', file: 'page1.md' },
    { folder: 'Page2', file: 'page2.md' },
    { folder: 'Page3', file: 'page3.md' },
    { folder: 'Page4', file: 'page4.md' }
  ];

  constructor(private http: HttpClient) {
    marked.setOptions({
      gfm: true,
      breaks: false,
      pedantic: false
    });
  }

  ngOnInit() {
    this.loadAllMarkdownFiles();
  }

  ngAfterViewInit() {
    // Wait for content to load before generating TOC
  }

  private loadAllMarkdownFiles() {
    this.isLoading = true;
    this.loadingError = '';

    const fileRequests: Observable<MarkdownFile>[] = this.markdownFiles.map(({ folder, file }) => {
      const path = `assets/markdown/${folder}/${file}`;
      return this.http.get(path, { responseType: 'text' }).pipe(
        map(content => ({
          folderName: folder,
          fileName: file,
          content,
          path
        })),
        catchError(error => {
          console.warn(`Failed to load ${path}:`, error);
          return of({
            folderName: folder,
            fileName: file,
            content: `# Error Loading Content\n\nFailed to load content from ${path}`,
            path
          });
        })
      );
    });

    forkJoin(fileRequests).subscribe({
      next: (markdownFiles) => {
        this.processMarkdownFiles(markdownFiles);
        this.isLoading = false;
      },
      error: (error) => {
        console.error('Error loading markdown files:', error);
        this.loadingError = 'Failed to load documentation files';
        this.isLoading = false;
      }
    });
  }

  private processMarkdownFiles(markdownFiles: MarkdownFile[]) {
    let combinedMarkdown = '';

    markdownFiles.forEach((file, index) => {
      // Simply add the markdown content as-is, using existing headers from .md files
      let content = file.content.trim();
      
      // Add some spacing between files
      if (index > 0) {
        combinedMarkdown += '\n\n';
      }
      
      combinedMarkdown += content;
    });

    this.htmlContent = this.parseMarkdown(combinedMarkdown);

    // Generate TOC after content is processed
    setTimeout(() => {
      this.generateTOC();
      this.applySyntaxHighlighting();
      this.setupScrollListener();
    }, 100);
  }

  private applySyntaxHighlighting() {
    if (this.content?.nativeElement) {
      this.content.nativeElement.querySelectorAll('pre code').forEach((block: HTMLElement) => {
        hljs.highlightElement(block);
      });
    }
  }

  private setupScrollListener() {
    if (this.content?.nativeElement) {
      this.content.nativeElement.addEventListener('scroll', () => {
        this.updateActiveSection();
      });
    }
  }

  generateTOC() {
    if (!this.content?.nativeElement) return;

    const headers = this.content.nativeElement.querySelectorAll('h1, h2, h3, h4, h5, h6');
    this.tocItems = [];

    headers.forEach((header: HTMLElement, index: number) => {
      const level = parseInt(header.tagName.charAt(1));
      const text = header.textContent?.replace(/\s+/g, ' ').trim() || '';
      const id = 'heading-' + index;

      header.id = id;
      this.tocItems.push({ id, text, level });
    });
  }

  updateActiveSection() {
    if (!this.content?.nativeElement) return;

    const headers = this.content.nativeElement.querySelectorAll('h1, h2, h3, h4, h5, h6');
    let currentSection = 0;

    const scrollContainer = this.content.nativeElement;
    const scrollPos = scrollContainer.scrollTop + 50; // Adjust offset as needed

    headers.forEach((header: HTMLElement, index: number) => {
      const headerTop = header.offsetTop;
      if (headerTop <= scrollPos) {
        currentSection = index;
      }
    });

    if (this.activeSection !== currentSection) {
      this.activeSection = currentSection;
      this.updateSidebarScroll();
    }
  }

  private updateSidebarScroll() {
    if (!this.sidebar?.nativeElement) return;

    const activeLink = this.sidebar.nativeElement.querySelectorAll('a')[this.activeSection];
    if (activeLink) {
      activeLink.scrollIntoView({
        block: 'nearest',
        behavior: 'smooth'
      });
    }
  }

  scrollToSection(event: Event, id: string, index: number) {
    event.preventDefault();

    const element = document.getElementById(id);
    if (element && this.content?.nativeElement) {
      // Scroll within the content container
      const containerTop = this.content.nativeElement.offsetTop;
      const elementTop = element.offsetTop;

      this.content.nativeElement.scrollTo({
        top: elementTop - containerTop - 20, // Add small offset
        behavior: 'smooth'
      });
    }

    this.activeSection = index;
  }

  @HostListener('window:resize')
  onResize() {
    // Recalculate positions on window resize
    setTimeout(() => this.updateActiveSection(), 100);
  }

  parseMarkdown(md: string): string {
    return marked.parse(md, { async: false }) as string;
  }

  // Utility method to reload content if needed
  reloadContent() {
    this.loadAllMarkdownFiles();
  }
}
